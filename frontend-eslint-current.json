[{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/config/EnvManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/constants/httpStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/constants/intervals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/AdminController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TIME_CONFIG' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { AgentConfigService } from '@/services/AgentConfigService';\nimport { ApiResponse } from '@/types';\nimport { safeLogger as logger } from '@/utils/logSanitizer';\nimport { HTTP_STATUS } from '@/constants/httpStatus';\nimport { TIME_CONSTANTS, TIME_UNITS, TIME_CONFIG } from '@/constants/intervals';\n\n// 创建服务实例\nconst configService = new AgentConfigService();\n\n/**\n * 管理员控制器\n * 提供管理接口和监控接口\n *\n * @swagger\n * tags:\n *   name: Admin\n *   description: 管理后台接口（需要管理员权限）\n */\n\n/**\n * 获取配置健康状态\n * GET /api/admin/config/health\n *\n * @swagger\n * /api/admin/config/health:\n *   get:\n *     summary: 获取配置健康状态\n *     tags: [Admin]\n *     description: 获取智能体配置的健康状态，包括总数、激活状态、无效配置等统计信息\n *     security:\n *       - bearerAuth: []\n *     responses:\n *       200:\n *         description: 成功返回配置健康状态\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 code:\n *                   type: number\n *                   example: 200\n *                 message:\n *                   type: string\n *                   example: success\n *                 data:\n *                   type: object\n *                   properties:\n *                     totalConfigs:\n *                       type: number\n *                       description: 总配置数\n *                     activeConfigs:\n *                       type: number\n *                       description: 激活配置数\n *                     inactiveConfigs:\n *                       type: number\n *                       description: 未激活配置数\n *                     invalidConfigs:\n *                       type: number\n *                       description: 无效配置数\n *                     hasUnresolvedPlaceholders:\n *                       type: number\n *                       description: 包含未解析占位符的配置数\n *                     snapshotComparison:\n *                       type: object\n *                       properties:\n *                         isEqual:\n *                           type: boolean\n *                           description: 数据库与文件配置是否一致\n *                         dbOnlyCount:\n *                           type: number\n *                           description: 仅存在于数据库的配置数\n *                         fileOnlyCount:\n *                           type: number\n *                           description: 仅存在于文件的配置数\n *                         differenceCount:\n *                           type: number\n *                           description: 存在差异的配置数\n *       500:\n *         description: 服务器内部错误\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 code:\n *                   type: number\n *                   example: 500\n *                 message:\n *                   type: string\n *                   example: 获取配置健康状态失败\n *                 data:\n *                   type: object\n *                   nullable: true\n *                   example: null\n */\nexport async function getConfigHealth(\n  req: Request,\n  res: Response,\n): Promise<Response> {\n  try {\n    const healthStatus = await configService.getConfigHealthStatus();\n\n    const response: ApiResponse<typeof healthStatus> = {\n      code: 200,\n      message: 'success',\n      data: healthStatus,\n    };\n\n    return res.json(response);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('[AdminController] 获取配置健康状态失败', {\n      error: errorMessage,\n      type: error instanceof Error ? error.constructor.name : 'Unknown',\n    });\n\n    const response: ApiResponse<null> = {\n      code: HTTP_STATUS.INTERNAL_SERVER_ERROR,\n      message: '获取配置健康状态失败',\n      data: null,\n    };\n\n    return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(response);\n  }\n}\n\n/**\n * 执行配置快照对比\n * GET /api/admin/config/compare\n *\n * @swagger\n * /api/admin/config/compare:\n *   get:\n *     summary: 执行配置快照对比\n *     tags: [Admin]\n *     description: 对比数据库和配置文件中的智能体配置\n *     security:\n *       - bearerAuth: []\n *     responses:\n *       200:\n *         description: 成功返回配置对比结果\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 code:\n *                   type: number\n *                   example: 200\n *                 message:\n *                   type: string\n *                   example: success\n *                 data:\n *                   type: object\n *                   properties:\n *                     isEqual:\n *                       type: boolean\n *                       description: 数据库与文件配置是否一致\n *                     dbOnly:\n *                       type: array\n *                       items:\n *                         $ref: '#/components/schemas/Agent'\n *                       description: 仅存在于数据库的配置\n *                     fileOnly:\n *                       type: array\n *                       items:\n *                         $ref: '#/components/schemas/Agent'\n *                       description: 仅存在于文件的配置\n *                     differences:\n *                       type: array\n *                       items:\n *                         type: object\n *                         properties:\n *                           id:\n *                             type: string\n *                           field:\n *                             type: string\n *                           dbValue:\n *                             type: object\n *                           fileValue:\n *                             type: object\n *                       description: 存在差异的配置项\n *       500:\n *         description: 服务器内部错误\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 code:\n *                   type: number\n *                   example: 500\n *                 message:\n *                   type: string\n *                   example: 配置快照对比失败\n *                 data:\n *                   type: object\n *                   nullable: true\n *                   example: null\n */\nexport async function compareConfigSnapshot(\n  req: Request,\n  res: Response,\n): Promise<Response> {\n  try {\n    const comparisonResult = await configService.compareConfigSnapshot();\n\n    const response: ApiResponse<typeof comparisonResult> = {\n      code: 200,\n      message: 'success',\n      data: comparisonResult,\n    };\n\n    return res.json(response);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('[AdminController] 配置快照对比失败', {\n      error: errorMessage,\n      type: error instanceof Error ? error.constructor.name : 'Unknown',\n    });\n\n    const response: ApiResponse<null> = {\n      code: HTTP_STATUS.INTERNAL_SERVER_ERROR,\n      message: '配置快照对比失败',\n      data: null,\n    };\n\n    return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(response);\n  }\n}\n\n/**\n * 清理废弃配置\n * POST /api/admin/config/cleanup\n *\n * @swagger\n * /api/admin/config/cleanup:\n *   post:\n *     summary: 清理废弃配置\n *     tags: [Admin]\n *     description: 删除不再使用的配置项（非激活状态且长时间未更新的配置）\n *     security:\n *       - bearerAuth: []\n *     responses:\n *       200:\n *         description: 成功清理废弃配置\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 code:\n *                   type: number\n *                   example: 200\n *                 message:\n *                   type: string\n *                   example: 成功清理 2 个废弃配置\n *                 data:\n *                   type: object\n *                   properties:\n *                     deletedCount:\n *                       type: number\n *                       description: 已删除的配置数量\n *                     deletedIds:\n *                       type: array\n *                       items:\n *                         type: string\n *                       description: 已删除的配置ID列表\n *       500:\n *         description: 服务器内部错误\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 code:\n *                   type: number\n *                   example: 500\n *                 message:\n *                   type: string\n *                   example: 清理废弃配置失败\n *                 data:\n *                   type: object\n *                   nullable: true\n *                   example: null\n */\nexport async function cleanupObsoleteConfigs(\n  req: Request,\n  res: Response,\n): Promise<Response> {\n  try {\n    const cleanupResult = await configService.cleanupObsoleteConfigs();\n\n    const response: ApiResponse<typeof cleanupResult> = {\n      code: 200,\n      message: `成功清理 ${cleanupResult.deletedCount} 个废弃配置`,\n      data: cleanupResult,\n    };\n\n    return res.json(response);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('[AdminController] 清理废弃配置失败', {\n      error: errorMessage,\n      type: error instanceof Error ? error.constructor.name : 'Unknown',\n    });\n\n    const response: ApiResponse<null> = {\n      code: HTTP_STATUS.INTERNAL_SERVER_ERROR,\n      message: '清理废弃配置失败',\n      data: null,\n    };\n\n    return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(response);\n  }\n}\n\n/**\n * 获取所有配置详情\n * GET /api/admin/config/details\n *\n * @swagger\n * /api/admin/config/details:\n *   get:\n *     summary: 获取所有配置详情\n *     tags: [Admin]\n *     description: 获取所有智能体配置的详细信息\n *     security:\n *       - bearerAuth: []\n *     responses:\n *       200:\n *         description: 成功返回所有配置详情\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 code:\n *                   type: number\n *                   example: 200\n *                 message:\n *                   type: string\n *                   example: success\n *                 data:\n *                   type: array\n *                   items:\n *                     $ref: '#/components/schemas/Agent'\n *       500:\n *         description: 服务器内部错误\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 code:\n *                   type: number\n *                   example: 500\n *                 message:\n *                   type: string\n *                   example: 获取配置详情失败\n *                 data:\n *                   type: object\n *                   nullable: true\n *                   example: null\n */\nexport async function getConfigDetails(\n  req: Request,\n  res: Response,\n): Promise<Response> {\n  try {\n    const configs = await configService.getAllAgents();\n\n    // 获取详细的配置信息\n    const detailedConfigs = [];\n    for (const config of configs) {\n      const fullConfig = await configService.getAgent(config.id);\n      if (fullConfig) {\n        detailedConfigs.push(fullConfig);\n      }\n    }\n\n    const response: ApiResponse<typeof detailedConfigs> = {\n      code: 200,\n      message: 'success',\n      data: detailedConfigs,\n    };\n\n    return res.json(response);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('[AdminController] 获取配置详情失败', {\n      error: errorMessage,\n      type: error instanceof Error ? error.constructor.name : 'Unknown',\n    });\n\n    const response: ApiResponse<null> = {\n      code: HTTP_STATUS.INTERNAL_SERVER_ERROR,\n      message: '获取配置详情失败',\n      data: null,\n    };\n\n    return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(response);\n  }\n}\n\nimport os from 'os';\nimport { authService } from '@/services/authInstance';\nimport { withClient, hashPassword } from '@/utils/db';\nimport { analyticsService } from '@/services/analyticsInstance';\nimport {\n  AuthenticationError,\n  AuthorizationError,\n  BusinessLogicError,\n} from '@/types/errors';\n\n// 使用全局单例的 authService（见 services/authInstance.ts）\n\nasync function ensureAuth(req: Request): Promise<{ id: string; username: string; role?: string }> {\n  const auth = req.headers['authorization'];\n  const token = (auth ?? '').replace(/^Bearer\\s+/i, '').trim();\n  if (!token) {\n    throw new AuthenticationError({\n      message: '未提供认证令牌',\n      code: 'UNAUTHORIZED',\n    });\n  }\n  return authService.profile(token);\n}\n\nasync function ensureAdminAuth(req: Request): Promise<{ id: string; username: string; role?: string }> {\n  const user = await ensureAuth(req);\n  if (!user || user.role !== 'admin') {\n    throw new AuthorizationError({\n      message: '需要管理员权限',\n      code: 'FORBIDDEN',\n      resource: 'admin',\n      action: 'access',\n    });\n  }\n  return user;\n}\n\nfunction parseDateInput(value?: string): Date | null {\n  if (!value) {\n    return null;\n  }\n  const date = new Date(value);\n  if (Number.isNaN(date.getTime())) {\n    return null;\n  }\n  return date;\n}\n\nfunction startOfDay(date: Date): Date {\n  const d = new Date(date);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\n\nfunction endOfDay(date: Date): Date {\n  const d = new Date(date);\n  d.setHours(\n    TIME_CONSTANTS.END_OF_DAY_HOUR,\n    TIME_CONSTANTS.END_OF_DAY_MINUTE,\n    TIME_CONSTANTS.END_OF_DAY_SECOND,\n    TIME_CONSTANTS.MILLISECOND_OF_DAY,\n  );\n  return d;\n}\n\nexport class AdminController {\n  static async systemInfo(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n      const memTotal = os.totalmem();\n      const memFree = os.freemem();\n      const memUsed = memTotal - memFree;\n      const load = os.loadavg ? os.loadavg() : [0, 0, 0];\n      const cpuCount = os.cpus()?.length ?? 0;\n      const info = {\n        platform: os.platform(),\n        release: os.release(),\n        arch: os.arch(),\n        nodeVersion: process.version,\n        uptimeSec: Math.floor(process.uptime()),\n        memory: {\n          total: memTotal,\n          free: memFree,\n          used: memUsed,\n          rss: process.memoryUsage().rss,\n        },\n        cpu: {\n          count: cpuCount,\n          load1: load[0] ?? 0,\n          load5: load[1] ?? 0,\n          load15: load[2] ?? 0,\n        },\n      };\n      return res.json({ data: info });\n    } catch (e: unknown) {\n      return res.status(HTTP_STATUS.UNAUTHORIZED).json({\n        code: 'UNAUTHORIZED',\n        message: '未授权',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  static async users(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n      const data = await withClient(async (client) => {\n        const { rows } = await client.query(\n          'SELECT id, username, role, status, created_at, updated_at FROM users ORDER BY id DESC',\n        );\n        return rows as Array<{\n          id: string;\n          username: string;\n          role: string;\n          status: string;\n          created_at: Date;\n          updated_at: Date;\n        }>;\n      });\n      return res.json({ data });\n    } catch (e: unknown) {\n      return res.status(HTTP_STATUS.UNAUTHORIZED).json({\n        code: 'UNAUTHORIZED',\n        message: '未授权',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  static async logs(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n      const {\n        level,\n        start,\n        end,\n        page = '1',\n        pageSize = '20',\n      } = req.query as {\n        level?: string;\n        start?: string;\n        end?: string;\n        page?: string;\n        pageSize?: string;\n      };\n      const conditions: string[] = [];\n      const params: (string | number | Date)[] = [];\n      let idx = 1;\n      if (level) {\n        conditions.push(`level = $${idx++}`);\n        params.push(level);\n      }\n      if (start) {\n        conditions.push(`timestamp >= $${idx++}`);\n        params.push(new Date(start));\n      }\n      if (end) {\n        conditions.push(`timestamp <= $${idx++}`);\n        params.push(new Date(end));\n      }\n      const where = conditions.length\n        ? `WHERE ${conditions.join(' AND ')}`\n        : '';\n\n      const pg = await withClient(async (client) => {\n        const { rows: totalRows } = await client.query(\n          `SELECT COUNT(*)::int AS count FROM logs ${where}`,\n          params,\n        );\n        const total = (totalRows[0] as { count: number })?.count ?? 0;\n        const p = Math.max(1, parseInt(String(page), 10) ?? 1);\n        const ps = Math.min(\n          TIME_CONSTANTS.MAX_PAGE_SIZE,\n          Math.max(1, parseInt(String(pageSize), 10) ?? TIME_CONSTANTS.DEFAULT_PAGE_SIZE),\n        );\n        const offset = (p - 1) * ps;\n        const { rows } = await client.query(\n          `SELECT id, timestamp, level, message FROM logs ${where} ORDER BY timestamp DESC LIMIT $${idx} OFFSET $${\n            idx + 1\n          }`,\n          [...params, ps, offset],\n        );\n        return { rows, total, page: p, pageSize: ps };\n      });\n      return res.json({\n        data: pg.rows,\n        total: pg.total,\n        page: pg.page,\n        pageSize: pg.pageSize,\n      });\n    } catch (e: unknown) {\n      return res.status(HTTP_STATUS.UNAUTHORIZED).json({\n        code: 'UNAUTHORIZED',\n        message: '未授权',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  static async logsExport(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n      const { level, start, end } = req.query as {\n        level?: string;\n        start?: string;\n        end?: string;\n      };\n      const conditions: string[] = [];\n      const params: (string | number | Date)[] = [];\n      let idx = 1;\n      if (level) {\n        conditions.push(`level = $${idx++}`);\n        params.push(level);\n      }\n      if (start) {\n        conditions.push(`timestamp >= $${idx++}`);\n        params.push(new Date(start));\n      }\n      if (end) {\n        conditions.push(`timestamp <= $${idx++}`);\n        params.push(new Date(end));\n      }\n      const where = conditions.length\n        ? `WHERE ${conditions.join(' AND ')}`\n        : '';\n\n      const rows = await withClient(async (client) => {\n        const { rows } = await client.query(\n          `SELECT id, timestamp, level, message FROM logs ${where} ORDER BY timestamp DESC LIMIT 50000`,\n          params,\n        );\n        return rows as Array<{\n          id: number;\n          timestamp: string;\n          level: string;\n          message: string;\n        }>;\n      });\n\n      res.setHeader('Content-Type', 'text/csv; charset=utf-8');\n      res.setHeader('Content-Disposition', 'attachment; filename=\"logs.csv\"');\n      const header = 'id,timestamp,level,message\\n';\n      const body = rows\n        .map(\n          (r) =>\n            `${r.id},${new Date(r.timestamp).toISOString()},${r.level},\"${(\n              r.message || ''\n            ).replace(/\"/g, '\"\"')}\"`,\n        )\n        .join('\\n');\n      return res.status(HTTP_STATUS.OK).send(header + body);\n    } catch (e: unknown) {\n      return res.status(HTTP_STATUS.UNAUTHORIZED).json({\n        code: 'UNAUTHORIZED',\n        message: '未授权',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  static async provinceHeatmap(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n\n      const {\n        start: startRaw,\n        end: endRaw,\n        agentId,\n      } = req.query as {\n        start?: string;\n        end?: string;\n        agentId?: string;\n      };\n\n      const parsedStart = startRaw ? parseDateInput(startRaw) : null;\n      if (startRaw && !parsedStart) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'start 参数格式不合法',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const parsedEnd = endRaw ? parseDateInput(endRaw) : null;\n      if (endRaw && !parsedEnd) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'end 参数格式不合法',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const now = new Date();\n      let startDate = parsedStart ? new Date(parsedStart) : startOfDay(now);\n      let endDate = parsedEnd ? new Date(parsedEnd) : endOfDay(now);\n\n      if (!parsedStart) {\n        startDate = startOfDay(startDate);\n      }\n      if (!parsedEnd) {\n        endDate = endOfDay(endDate);\n      }\n\n      if (startDate.getTime() > endDate.getTime()) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: '开始时间必须早于结束时间',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const maxRangeMs = 60 * TIME_UNITS.DAY; // 60 天\n      if (endDate.getTime() - startDate.getTime() > maxRangeMs) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: '时间范围不能超过60天',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const filterAgentId = agentId && agentId !== 'all' ? agentId : null;\n\n      const data = await analyticsService.getProvinceHeatmap({\n        start: startDate,\n        end: endDate,\n        agentId: filterAgentId,\n      });\n\n      return res.json({ data });\n    } catch (error: unknown) {\n      if (error instanceof Error && error.message === 'UNAUTHORIZED') {\n        return res.status(HTTP_STATUS.UNAUTHORIZED).json({\n          code: 'UNAUTHORIZED',\n          message: '未授权',\n          timestamp: new Date().toISOString(),\n        });\n      }\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error('[AdminController] provinceHeatmap failed', {\n        error: errorMessage,\n        type: error instanceof Error ? error.constructor.name : 'Unknown',\n      });\n      return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({\n        code: 'INTERNAL_ERROR',\n        message: '获取地域热点数据失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  static async conversationSeries(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n\n      const {\n        start: startRaw,\n        end: endRaw,\n        agentId,\n      } = req.query as {\n        start?: string;\n        end?: string;\n        agentId?: string;\n      };\n\n      const parsedStart = startRaw ? parseDateInput(startRaw) : null;\n      if (startRaw && !parsedStart) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'start 参数格式不合法',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const parsedEnd = endRaw ? parseDateInput(endRaw) : null;\n      if (endRaw && !parsedEnd) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'end 参数格式不合法',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const now = new Date();\n      let startDate = parsedStart\n        ? new Date(parsedStart)\n        : new Date(now.getFullYear(), now.getMonth(), 1);\n      let endDate = parsedEnd ? new Date(parsedEnd) : endOfDay(now);\n\n      startDate = startOfDay(startDate);\n      endDate = endOfDay(endDate);\n\n      if (startDate.getTime() > endDate.getTime()) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: '开始时间必须早于结束时间',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const maxRangeMs = 90 * TIME_UNITS.DAY; // 最长 90 天\n      if (endDate.getTime() - startDate.getTime() > maxRangeMs) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: '时间范围不能超过90天',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const filterAgentId = agentId && agentId !== 'all' ? agentId : null;\n\n      const data = await analyticsService.getConversationSeries({\n        start: startDate,\n        end: endDate,\n        agentId: filterAgentId,\n      });\n\n      return res.json({ data });\n    } catch (error: unknown) {\n      if (error instanceof Error && error.message === 'UNAUTHORIZED') {\n        return res.status(HTTP_STATUS.UNAUTHORIZED).json({\n          code: 'UNAUTHORIZED',\n          message: '未授权',\n          timestamp: new Date().toISOString(),\n        });\n      }\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error('[AdminController] conversationSeries failed', {\n        error: errorMessage,\n        type: error instanceof Error ? error.constructor.name : 'Unknown',\n      });\n      return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({\n        code: 'INTERNAL_ERROR',\n        message: '获取智能体对话趋势失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  static async conversationAgents(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n\n      const { start: startRaw, end: endRaw } = req.query as {\n        start?: string;\n        end?: string;\n      };\n\n      const parsedStart = startRaw ? parseDateInput(startRaw) : null;\n      if (startRaw && !parsedStart) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'start 参数格式不合法',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const parsedEnd = endRaw ? parseDateInput(endRaw) : null;\n      if (endRaw && !parsedEnd) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'end 参数格式不合法',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const now = new Date();\n      let startDate = parsedStart\n        ? new Date(parsedStart)\n        : new Date(now.getFullYear(), now.getMonth(), 1);\n      let endDate = parsedEnd ? new Date(parsedEnd) : endOfDay(now);\n\n      startDate = startOfDay(startDate);\n      endDate = endOfDay(endDate);\n\n      if (startDate.getTime() > endDate.getTime()) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: '开始时间必须早于结束时间',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const maxRangeMs = 180 * TIME_UNITS.DAY;\n      if (endDate.getTime() - startDate.getTime() > maxRangeMs) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: '时间范围不能超过180天',\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      const data = await analyticsService.getAgentTotals({\n        start: startDate,\n        end: endDate,\n      });\n\n      return res.json({ data });\n    } catch (error: unknown) {\n      if (error instanceof Error && error.message === 'UNAUTHORIZED') {\n        return res.status(HTTP_STATUS.UNAUTHORIZED).json({\n          code: 'UNAUTHORIZED',\n          message: '未授权',\n          timestamp: new Date().toISOString(),\n        });\n      }\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error('[AdminController] conversationAgents failed', {\n        error: errorMessage,\n        type: error instanceof Error ? error.constructor.name : 'Unknown',\n      });\n      return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({\n        code: 'INTERNAL_ERROR',\n        message: '获取智能体会话对比失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  // ========== 用户管理：新增 / 更新 / 重置密码 ==========\n  static async createUser(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n      const {\n        username,\n        password,\n        role = 'user',\n        status = 'active',\n      }: {\n        username?: string;\n        password?: string;\n        role?: string;\n        status?: string;\n      } = req.body || {};\n      if (!username || !password) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'username/password 必填',\n          timestamp: new Date().toISOString(),\n        });\n      }\n      const data = await withClient(async (client) => {\n        const exists = await client.query(\n          'SELECT 1 FROM users WHERE username=$1 LIMIT 1',\n          [username],\n        );\n        if (exists.rowCount && exists.rowCount > 0) {\n          throw new BusinessLogicError({\n            message: '用户名已存在',\n            code: 'USER_EXISTS',\n            rule: 'unique_username',\n          });\n        }\n        // 使用安全哈希存储密码\n        const { salt, hash } = hashPassword(password);\n\n        const { rows } = await client.query(\n          'INSERT INTO users(username, password_salt, password_hash, role, status) VALUES ($1,$2,$3,$4,$5) RETURNING id, username, role, status, created_at, updated_at',\n          [username, salt, hash, role, status],\n        );\n        return rows[0];\n      });\n      return res.json({ data });\n    } catch (e: unknown) {\n      if (e instanceof Error && e.message === 'USER_EXISTS') {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'USER_EXISTS',\n          message: '用户名已存在',\n          timestamp: new Date().toISOString(),\n        });\n      }\n      return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({\n        code: 'INTERNAL_ERROR',\n        message: '创建用户失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  static async updateUser(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n      const { id, role, status }: {\n        id?: string;\n        role?: string;\n        status?: string;\n      } = req.body || {};\n      if (!id) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'id 必填',\n          timestamp: new Date().toISOString(),\n        });\n      }\n      const fields: string[] = [];\n      const params: (string | number | Date)[] = [];\n      let idx = 1;\n      if (typeof role === 'string') {\n        fields.push(`role=$${idx++}`);\n        params.push(role);\n      }\n      if (typeof status === 'string') {\n        fields.push(`status=$${idx++}`);\n        params.push(status);\n      }\n      fields.push('updated_at=NOW()');\n      const sql = `UPDATE users SET ${fields.join(\n        ', ',\n      )} WHERE id=$${idx} RETURNING id, username, role, status, created_at, updated_at`;\n      params.push(id);\n      const data = await withClient(async (client) => {\n        const { rows } = await client.query(sql, params);\n        return rows[0];\n      });\n      return res.json({ data });\n    } catch (e: unknown) {\n      return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({\n        code: 'INTERNAL_ERROR',\n        message: '更新用户失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  static async resetUserPassword(req: Request, res: Response): Promise<Response> {\n    try {\n      await ensureAdminAuth(req);\n      const { id, newPassword }: {\n        id?: string;\n        newPassword?: string;\n      } = req.body || {};\n      if (!id) {\n        return res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'BAD_REQUEST',\n          message: 'id 必填',\n          timestamp: new Date().toISOString(),\n        });\n      }\n      const pwd =\n        typeof newPassword === 'string' && newPassword.length >= TIME_CONSTANTS.MIN_PASSWORD_LENGTH\n          ? newPassword\n          : Math.random().toString(36).slice(-TIME_CONSTANTS.RANDOM_RANGE);\n\n      // 使用安全哈希存储密码\n      const { salt, hash } = hashPassword(pwd);\n\n      await withClient(async (client) => {\n        await client.query(\n          'UPDATE users SET password_salt=$1, password_hash=$2, updated_at=NOW() WHERE id=$3',\n          [salt, hash, id],\n        );\n      });\n\n      logger.warn('[AdminController] 管理员重置用户密码', {\n        userId: id,\n        newPasswordLength: pwd.length,\n        timestamp: new Date().toISOString(),\n      });\n\n      return res.json({ ok: true, newPassword: pwd });\n    } catch (e: unknown) {\n      return res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({\n        code: 'INTERNAL_ERROR',\n        message: '重置密码失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/AgentController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":110,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":113,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7815,7818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7815,7818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":123,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":126,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7828,7831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7828,7831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7982,7985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7982,7985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":381,"column":116,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":381,"endColumn":119,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12828,12831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12828,12831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":381,"column":129,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":381,"endColumn":132,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12841,12844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12841,12844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":385,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12995,12998],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12995,12998],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":434,"column":105,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":108,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14842,14845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14842,14845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":434,"column":118,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":121,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14855,14858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14855,14858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":438,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":438,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15009,15012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15009,15012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":478,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":478,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16470,16473],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16470,16473],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":478,"column":107,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":478,"endColumn":110,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16483,16486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16483,16486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":482,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":482,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16637,16640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16637,16640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":488,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":488,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16825,16828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16825,16828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":488,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":488,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16840,16843],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16840,16843],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":488,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":488,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16853,16856],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16853,16856],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":488,"column":114,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":488,"endColumn":117,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16865,16868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16865,16868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\nimport Joi from 'joi';\n\nimport { AgentConfigService } from '@/services/AgentConfigService';\nimport { ChatProxyService } from '@/services/ChatProxyService';\nimport { ChatInitService } from '@/services/ChatInitService';\nimport { DifyInitService } from '@/services/DifyInitService';\nimport { ApiError, AgentConfig } from '@/types';\nimport { ApiResponseHandler } from '@/utils/apiResponse';\nimport logger from '@/utils/logger';\nimport { HTTP_STATUS } from '@/constants/httpStatus';\nimport { JsonValue } from '@/types/dynamic';\nimport { authService } from '@/services/authInstance';\nimport { AuthenticationError, AuthorizationError, ValidationError } from '@/types/errors';\nasync function ensureAdminAuth(req: Request) {\n  const auth = req.headers['authorization'];\n  const token = (auth || '').replace(/^Bearer\\s+/i, '').trim();\n  if (!token) {\n    throw new AuthenticationError({\n      message: '未提供认证令牌',\n      code: 'UNAUTHORIZED',\n    });\n  }\n  const user = await authService.profile(token);\n  if (!user || user.role !== 'admin') {\n    throw new AuthorizationError({\n      message: '需要管理员权限',\n      code: 'FORBIDDEN',\n      resource: 'admin',\n      action: 'access',\n    });\n  }\n  return user;\n}\n\nfunction handleAdminAuthError(error: unknown, res: Response): boolean {\n  if (error instanceof Error && error.message === 'UNAUTHORIZED') {\n    res.status(HTTP_STATUS.FORBIDDEN).json({\n      code: 'UNAUTHORIZED',\n      message: '需要管理员权限',\n      timestamp: new Date().toISOString(),\n    });\n    return true;\n  }\n  return false;\n}\n\n/**\n * 智能体控制器\n */\nexport class AgentController {\n  private agentService: AgentConfigService;\n  private chatService: ChatProxyService;\n  private chatInitService: ChatInitService;\n  private difyInitService: DifyInitService;\n  private createAgentSchema = Joi.object({\n    id: Joi.string().optional(),\n    name: Joi.string().max(120).required(),\n    description: Joi.string().allow('').default(''),\n    provider: Joi.string().valid('fastgpt', 'openai', 'anthropic', 'dify', 'custom').required(),\n    endpoint: Joi.string().uri({ allowRelative: false }).required(),\n    apiKey: Joi.string().required(),\n    appId: Joi.string().optional(),\n    model: Joi.string().max(120).required(),\n    maxTokens: Joi.number().min(1).max(32768).optional(),\n    temperature: Joi.number().min(0).max(2).optional(),\n    systemPrompt: Joi.string().allow('').optional(),\n    capabilities: Joi.array().items(Joi.string()).default([]),\n    rateLimit: Joi.object({\n      requestsPerMinute: Joi.number().min(0).optional(),\n      tokensPerMinute: Joi.number().min(0).optional(),\n    }).optional(),\n    isActive: Joi.boolean().optional(),\n    features: Joi.object({\n      supportsChatId: Joi.boolean().optional(),\n      supportsStream: Joi.boolean().optional(),\n      supportsDetail: Joi.boolean().optional(),\n      supportsFiles: Joi.boolean().optional(),\n      supportsImages: Joi.boolean().optional(),\n      streamingConfig: Joi.object({\n        enabled: Joi.boolean().optional(),\n        endpoint: Joi.string().valid('same', 'different').optional(),\n        statusEvents: Joi.boolean().optional(),\n        flowNodeStatus: Joi.boolean().optional(),\n      }).optional(),\n    }).optional(),\n  });\n  private updateAgentSchema = Joi.object({\n    name: Joi.string().max(120).optional(),\n    description: Joi.string().allow('').optional(),\n    provider: Joi.string().valid('fastgpt', 'openai', 'anthropic', 'dify', 'custom').optional(),\n    endpoint: Joi.string().uri({ allowRelative: false }).optional(),\n    apiKey: Joi.string().optional(),\n    appId: Joi.string().optional(),\n    model: Joi.string().max(120).optional(),\n    maxTokens: Joi.number().min(1).max(32768).optional(),\n    temperature: Joi.number().min(0).max(2).optional(),\n    systemPrompt: Joi.string().allow('').optional(),\n    capabilities: Joi.array().items(Joi.string()).optional(),\n    rateLimit: Joi.object({\n      requestsPerMinute: Joi.number().min(0).optional(),\n      tokensPerMinute: Joi.number().min(0).optional(),\n    }).optional(),\n    isActive: Joi.boolean().optional(),\n    features: Joi.object({\n      supportsChatId: Joi.boolean().optional(),\n      supportsStream: Joi.boolean().optional(),\n      supportsDetail: Joi.boolean().optional(),\n      supportsFiles: Joi.boolean().optional(),\n      supportsImages: Joi.boolean().optional(),\n      streamingConfig: Joi.object({\n        enabled: Joi.boolean().optional(),\n        endpoint: Joi.string().valid('same', 'different').optional(),\n        statusEvents: Joi.boolean().optional(),\n        flowNodeStatus: Joi.boolean().optional(),\n      }).optional(),\n    }).optional(),\n  });\n  private importSchema = Joi.object({\n    agents: Joi.array().items(this.createAgentSchema).min(1).required(),\n  });\n\n  constructor() {\n    this.agentService = new AgentConfigService();\n    this.chatService = new ChatProxyService(this.agentService);\n    this.chatInitService = new ChatInitService(this.agentService);\n    this.difyInitService = new DifyInitService(this.agentService);\n  }\n\n  /**\n   * 获取可用智能体列表\n   * GET /api/agents\n   */\n  getAgents = async (req: Request, res: Response, _next: NextFunction): Promise<void> => {\n    try {\n      const includeInactive = req.query.includeInactive === 'true';\n\n      const agents = includeInactive\n        ? await this.agentService.getAllAgents()\n        : await this.agentService.getAvailableAgents();\n\n      ApiResponseHandler.sendSuccess(res, agents, {\n        message: '获取智能体列表成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n        metadata: { extra: { total: agents.length } },\n      });\n    } catch (error) {\n      logger.error('获取智能体列表失败', { error: error as Error });\n      const apiError: ApiError = {\n        code: 'GET_AGENTS_FAILED',\n        message: '获取智能体列表失败',\n        timestamp: new Date().toISOString(),\n      };\n\n      if (process.env.NODE_ENV === 'development') {\n        apiError.details = { error: error instanceof Error ? error.message : String(error) } as JsonValue;\n      }\n\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(apiError);\n    }\n  };\n\n  /**\n   * 获取特定智能体信息\n   * GET /api/agents/:id\n   */\n  getAgent = async (req: Request, res: Response, _next: NextFunction): Promise<void> => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        const apiError: ApiError = {\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(HTTP_STATUS.BAD_REQUEST).json(apiError);\n        return;\n      }\n\n      const config = await this.agentService.getAgent(id);\n\n      if (!config) {\n        const apiError: ApiError = {\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${id}`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(404).json(apiError);\n        return;\n      }\n\n      // 转换为安全的Agent对象（不包含敏感信息）\n      const agent = this.toSafeAgent(config);\n\n      ApiResponseHandler.sendSuccess(res, agent, {\n        message: '获取智能体信息成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('获取智能体信息失败', { error: error as Error });\n      const apiError: ApiError = {\n        code: 'GET_AGENT_FAILED',\n        message: '获取智能体信息失败',\n        timestamp: new Date().toISOString(),\n      };\n\n      if (process.env.NODE_ENV === 'development') {\n        apiError.details = { error: error instanceof Error ? error.message : String(error) } as JsonValue;\n      }\n\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(apiError);\n    }\n  };\n\n  createAgent = async (req: Request, res: Response): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n      const { error, value } = this.createAgentSchema.validate(req.body, { abortEarly: false }) as { error?: any; value?: any };\n      if (error) {\n        res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'VALIDATION_ERROR',\n          message: error.details.map((d: any) => d.message).join('; '),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const created = await this.agentService.createAgent(value);\n      ApiResponseHandler.sendCreated(res, this.toSafeAgent(created), {\n        message: '创建智能体成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      if (handleAdminAuthError(error, res)) {\n        return;\n      }\n      logger.error('创建智能体失败', { error: error as Error });\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({\n        code: 'CREATE_AGENT_FAILED',\n        message: '创建智能体失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  };\n\n  /**\n   * 检查智能体状态\n   * GET /api/agents/:id/status\n   */\n  getAgentStatus = async (req: Request, res: Response, _next: NextFunction): Promise<void> => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        const apiError: ApiError = {\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(HTTP_STATUS.BAD_REQUEST).json(apiError);\n        return;\n      }\n\n      const healthStatus = await this.agentService.checkAgentHealth(id);\n\n      ApiResponseHandler.sendSuccess(res, healthStatus, {\n        message: '获取智能体状态成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('检查智能体状态失败', { error: error as Error });\n      const apiError: ApiError = {\n        code: 'GET_AGENT_STATUS_FAILED',\n        message: '检查智能体状态失败',\n        timestamp: new Date().toISOString(),\n      };\n\n      if (process.env.NODE_ENV === 'development') {\n        apiError.details = { error: error instanceof Error ? error.message : String(error) } as JsonValue;\n      }\n\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(apiError);\n    }\n  };\n\n  /**\n   * 重新加载智能体配置\n   * POST /api/agents/reload\n   */\n  reloadAgents = async (req: Request, res: Response, _next: NextFunction): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n      const configs = await this.agentService.reloadAgents();\n\n      ApiResponseHandler.sendSuccess(res, {\n        totalAgents: configs.length,\n        activeAgents: configs.filter(c => c.isActive).length,\n      }, {\n        message: '智能体配置已重新加载',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      if (handleAdminAuthError(error, res)) {\n        return;\n      }\n      logger.error('重新加载智能体配置失败', { error: error as Error });\n      const apiError: ApiError = {\n        code: 'RELOAD_AGENTS_FAILED',\n        message: '重新加载智能体配置失败',\n        timestamp: new Date().toISOString(),\n      };\n\n      if (process.env.NODE_ENV === 'development') {\n        apiError.details = { error: error instanceof Error ? error.message : String(error) } as JsonValue;\n      }\n\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(apiError);\n    }\n  };\n\n  /**\n   * 验证智能体配置\n   * GET /api/agents/:id/validate\n   */\n  validateAgent = async (req: Request, res: Response, _next: NextFunction): Promise<void> => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        const apiError: ApiError = {\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(HTTP_STATUS.BAD_REQUEST).json(apiError);\n        return;\n      }\n\n      const isValid = await this.chatService.validateAgentConfig(id);\n      const config = await this.agentService.getAgent(id);\n\n      ApiResponseHandler.sendSuccess(res, {\n        agentId: id,\n        isValid,\n        exists: !!config,\n        isActive: config?.isActive || false,\n      }, {\n        message: '验证智能体配置成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('验证智能体配置失败', { error: error as Error });\n\n      const apiError: ApiError = {\n        code: 'VALIDATE_AGENT_FAILED',\n        message: '验证智能体配置失败',\n        timestamp: new Date().toISOString(),\n      };\n\n      if (process.env.NODE_ENV === 'development') {\n        apiError.details = { error: error instanceof Error ? error.message : String(error) } as JsonValue;\n      }\n\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json(apiError);\n    }\n  };\n\n  /**\n   * 更新智能体配置（启用/禁用、编辑）\n   * POST /api/agents/:id/update\n   */\n  updateAgent = async (req: Request, res: Response, _next: NextFunction): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n      const { id } = req.params;\n      if (!id) {\n        res.status(HTTP_STATUS.BAD_REQUEST).json({ code: 'INVALID_AGENT_ID', message: '智能体ID不能为空', timestamp: new Date().toISOString() });\n        return;\n      }\n      const { error, value } = this.updateAgentSchema.validate(req.body || {}, { abortEarly: false }) as { error?: any; value?: any };\n      if (error) {\n        res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'VALIDATION_ERROR',\n          message: error.details.map((d: any) => d.message).join('; '),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n      await this.agentService.updateAgent(id, value as Partial<AgentConfig>);\n      const latest = await this.agentService.getAgent(id);\n      ApiResponseHandler.sendSuccess(res, latest ? this.toSafeAgent(latest) : null, {\n        message: '更新智能体成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      if (handleAdminAuthError(error, res)) {\n        return;\n      }\n      logger.error('更新智能体失败', { error: error as Error });\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({ code: 'UPDATE_AGENT_FAILED', message: '更新智能体失败', timestamp: new Date().toISOString() });\n    }\n  };\n\n  deleteAgent = async (req: Request, res: Response): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n      const { id } = req.params;\n      if (!id) {\n        res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n      await this.agentService.deleteAgent(id);\n      ApiResponseHandler.sendSuccess(res, null, {\n        message: '删除智能体成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      if (handleAdminAuthError(error, res)) {\n        return;\n      }\n      logger.error('删除智能体失败', { error: error as Error });\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({ code: 'DELETE_AGENT_FAILED', message: '删除智能体失败', timestamp: new Date().toISOString() });\n    }\n  };\n\n  importAgents = async (req: Request, res: Response): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n      const { error, value } = this.importSchema.validate(req.body, { abortEarly: false }) as { error?: any; value?: any };\n      if (error) {\n        res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'VALIDATION_ERROR',\n          message: error.details.map((d: any) => d.message).join('; '),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n      const agents = await this.agentService.importAgents((value).agents);\n      ApiResponseHandler.sendSuccess(res, agents.map((agent) => this.toSafeAgent(agent)), {\n        message: '导入智能体成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      if (handleAdminAuthError(error, res)) {\n        return;\n      }\n      logger.error('导入智能体失败', { error: error as Error });\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({ code: 'IMPORT_AGENT_FAILED', message: '导入智能体失败', timestamp: new Date().toISOString() });\n    }\n  };\n\n  /**\n   * 自动获取智能体信息\n   * POST /api/admin/agents/fetch-info\n   * Body: { provider: 'fastgpt' | 'dify', endpoint: string, apiKey: string, appId?: string }\n   */\n  fetchAgentInfo = async (req: Request, res: Response): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n\n      // 验证请求体\n      const schema = Joi.object({\n        provider: Joi.string().valid('fastgpt', 'dify').required(),\n        endpoint: Joi.string().uri({ allowRelative: false }).required(),\n        apiKey: Joi.string().required(),\n        appId: Joi.string().when('provider', {\n          is: 'fastgpt',\n          then: Joi.required(),\n          otherwise: Joi.optional(),\n        }),\n      });\n\n      const { error, value } = schema.validate(req.body, { abortEarly: false }) as { error?: any; value?: any };\n      if (error) {\n        res.status(HTTP_STATUS.BAD_REQUEST).json({\n          code: 'VALIDATION_ERROR',\n          message: error.details.map((d: any) => d.message).join('; '),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const { provider, endpoint, apiKey, appId } = value as { provider: any; endpoint: any; apiKey: any; appId: any };\n\n      // 构造临时智能体配置用于API调用\n      const tempAgent: AgentConfig = {\n        id: 'temp-' + Date.now(),\n        name: 'Temporary Agent',\n        description: '',\n        provider: provider as 'fastgpt' | 'dify',\n        endpoint,\n        apiKey,\n        appId: appId || '',\n        model: '',\n        isActive: true,\n        capabilities: [],\n        features: {\n          supportsChatId: true,\n          supportsStream: true,\n          supportsDetail: false,\n          supportsFiles: false,\n          supportsImages: false,\n          streamingConfig: {\n            enabled: true,\n            endpoint: 'same',\n            statusEvents: false,\n            flowNodeStatus: false,\n          },\n        },\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      };\n\n      let agentInfo: Record<string, JsonValue> = {};\n\n      if (provider === 'fastgpt') {\n        // 调用FastGPT初始化接口\n        // getInitData的第一个参数是agentId（将作为标识查找agent配置）\n        // 因为我们的tempAgent没有在数据库中，所以需要先注册或直接使用appId\n        // 这里我们需要修改实现：直接使用appId调用API\n        if (!appId) {\n          throw new ValidationError({\n            message: 'FastGPT需要提供appId',\n            code: 'MISSING_APP_ID',\n            field: 'appId',\n          });\n        }\n\n        // 临时注册agent用于API调用\n        const agentId = 'temp-fetch-' + Date.now();\n        tempAgent.id = agentId;\n\n        // 临时存储agent配置（不保存到数据库）\n        // 实际实现中，我们应该调用chatInitService内部方法直接使用agent配置\n        // 为了简化，这里我们构造响应数据\n        agentInfo = {\n          name: '请在创建后通过FastGPT控制台查看完整配置',\n          description: '自动获取功能仅支持基本信息',\n          model: '',\n          systemPrompt: '',\n          temperature: 0.7,\n          maxTokens: 4000,\n          capabilities: [],\n          features: {\n            supportsChatId: true,\n            supportsStream: true,\n            supportsDetail: true,\n            supportsFiles: true,\n            supportsImages: false,\n            streamingConfig: {\n              enabled: true,\n              endpoint: 'same',\n              statusEvents: true,\n              flowNodeStatus: true,\n            },\n          },\n        };\n      } else if (provider === 'dify') {\n        // 调用Dify初始化接口\n        const difyInfo = await this.difyInitService.fetchAppInfoByCredentials(endpoint, apiKey);\n\n        agentInfo = {\n          name: difyInfo.name,\n          description: difyInfo.description,\n          model: difyInfo.model,\n          systemPrompt: '',\n          temperature: difyInfo.temperature || 0.7,\n          maxTokens: difyInfo.maxTokens || 4000,\n          capabilities: difyInfo.capabilities,\n          features: difyInfo.features,\n        };\n      }\n\n      ApiResponseHandler.sendSuccess(res, agentInfo, {\n        message: '获取智能体信息成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      if (handleAdminAuthError(error, res)) {\n        return;\n      }\n      logger.error('获取智能体信息失败', { error: error as Error });\n      res.status(HTTP_STATUS.INTERNAL_SERVER_ERROR).json({\n        code: 'FETCH_AGENT_INFO_FAILED',\n        message: error instanceof Error ? error.message : '获取智能体信息失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  };\n\n  private toSafeAgent(config: AgentConfig) {\n    return {\n      id: config.id,\n      name: config.name,\n      description: config.description,\n      endpoint: config.endpoint,\n      model: config.model,\n      status: config.isActive ? 'active' : 'inactive',\n      capabilities: config.capabilities,\n      provider: config.provider,\n      features: config.features,\n      rateLimit: config.rateLimit,\n      systemPrompt: config.systemPrompt,\n      temperature: config.temperature,\n      maxTokens: config.maxTokens,\n      appId: config.appId,\n      createdAt: config.createdAt,\n      updatedAt: config.updatedAt,\n    };\n  }\n\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/AuditController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[682,685],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[682,685],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2769,2772],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2769,2772],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4229,4232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4229,4232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":230,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6176,6179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6176,6179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":280,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7415,7418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7415,7418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { auditService } from '@/services/AuditService';\nimport { AuditAction, AuditStatus, ResourceType } from '@/types/audit';\nimport logger from '@/utils/logger';\nimport { ApiResponseHandler } from '@/utils/apiResponse';\n\n/**\n * 审计日志控制器\n */\nexport class AuditController {\n  /**\n   * 查询审计日志\n   * GET /api/audit/logs\n   */\n  async query(req: Request, res: Response) {\n    try {\n      const {\n        userId,\n        action,\n        resourceType,\n        resourceId,\n        status,\n        startDate,\n        endDate,\n        limit,\n        offset,\n        orderBy,\n        orderDirection,\n      } = req.query;\n\n      const queryParams: any = {};\n\n      // 只添加非 undefined 的属性\n      if (userId) {\n        queryParams.userId = userId as string;\n      }\n      if (action) {\n        queryParams.action = Array.isArray(action)\n          ? (action as AuditAction[])\n          : (action as AuditAction);\n      }\n      if (resourceType) {\n        queryParams.resourceType = resourceType as ResourceType;\n      }\n      if (resourceId) {\n        queryParams.resourceId = resourceId as string;\n      }\n      if (status) {\n        queryParams.status = status as AuditStatus;\n      }\n      if (startDate) {\n        queryParams.startDate = new Date(startDate as string);\n      }\n      if (endDate) {\n        queryParams.endDate = new Date(endDate as string);\n      }\n      if (limit) {\n        queryParams.limit = parseInt(limit as string, 10);\n      }\n      if (offset) {\n        queryParams.offset = parseInt(offset as string, 10);\n      }\n      if (orderBy) {\n        queryParams.orderBy = orderBy as 'timestamp' | 'action' | 'status';\n      }\n      if (orderDirection) {\n        queryParams.orderDirection = orderDirection as 'ASC' | 'DESC';\n      }\n\n      const result = await auditService.query(queryParams);\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '查询审计日志成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('Failed to query audit logs', {\n        component: 'AuditController',\n        error,\n      });\n\n      res.status(500).json({\n        success: false,\n        message: 'Failed to query audit logs',\n        error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined,\n      });\n    }\n  }\n\n  /**\n   * 获取用户审计日志\n   * GET /api/audit/users/:userId\n   */\n  async getUserLogs(req: Request, res: Response) {\n    try {\n      const { userId } = req.params;\n      if (!userId) {\n        return res.status(400).json({\n          success: false,\n          code: 'INVALID_USER_ID',\n          message: '用户ID不能为空',\n        });\n      }\n\n      const { limit, offset, startDate, endDate } = req.query;\n\n      const options: any = {};\n      if (limit) {\n        options.limit = parseInt(limit as string, 10);\n      }\n      if (offset) {\n        options.offset = parseInt(offset as string, 10);\n      }\n      if (startDate) {\n        options.startDate = new Date(startDate as string);\n      }\n      if (endDate) {\n        options.endDate = new Date(endDate as string);\n      }\n\n      const result = await auditService.getUserAuditLogs(userId, options);\n\n      return ApiResponseHandler.sendSuccess(res, result, {\n        message: '获取用户审计日志成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('Failed to get user audit logs', {\n        component: 'AuditController',\n        error,\n        userId: req.params.userId,\n      });\n\n      return res.status(500).json({\n        success: false,\n        message: 'Failed to get user audit logs',\n        error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined,\n      });\n    }\n  }\n\n  /**\n   * 获取资源审计日志\n   * GET /api/audit/resources/:resourceType/:resourceId\n   */\n  async getResourceLogs(req: Request, res: Response) {\n    try {\n      const { resourceType, resourceId } = req.params;\n      if (!resourceType || !resourceId) {\n        return res.status(400).json({\n          success: false,\n          code: 'INVALID_PARAMETERS',\n          message: '资源类型和资源ID不能为空',\n        });\n      }\n\n      const { limit, offset } = req.query;\n\n      const options: any = {};\n      if (limit) {\n        options.limit = parseInt(limit as string, 10);\n      }\n      if (offset) {\n        options.offset = parseInt(offset as string, 10);\n      }\n\n      const result = await auditService.getResourceAuditLogs(\n        resourceType as ResourceType,\n        resourceId,\n        options,\n      );\n\n      return ApiResponseHandler.sendSuccess(res, result, {\n        message: '获取资源审计日志成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('Failed to get resource audit logs', {\n        component: 'AuditController',\n        error,\n        resourceType: req.params.resourceType,\n        resourceId: req.params.resourceId,\n      });\n\n      return res.status(500).json({\n        success: false,\n        message: 'Failed to get resource audit logs',\n        error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined,\n      });\n    }\n  }\n\n  /**\n   * 获取最近的审计日志\n   * GET /api/audit/recent\n   */\n  async getRecentLogs(req: Request, res: Response) {\n    try {\n      const { limit } = req.query;\n      const logs = await auditService.getRecentLogs(\n        limit ? parseInt(limit as string, 10) : undefined,\n      );\n\n      ApiResponseHandler.sendSuccess(res, logs, {\n        message: '获取最近审计日志成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('Failed to get recent audit logs', {\n        component: 'AuditController',\n        error,\n      });\n\n      res.status(500).json({\n        success: false,\n        message: 'Failed to get recent audit logs',\n        error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined,\n      });\n    }\n  }\n\n  /**\n   * 获取失败的审计日志\n   * GET /api/audit/failures\n   */\n  async getFailedLogs(req: Request, res: Response) {\n    try {\n      const { limit, offset, startDate, endDate } = req.query;\n\n      const options: any = {};\n      if (limit) {\n        options.limit = parseInt(limit as string, 10);\n      }\n      if (offset) {\n        options.offset = parseInt(offset as string, 10);\n      }\n      if (startDate) {\n        options.startDate = new Date(startDate as string);\n      }\n      if (endDate) {\n        options.endDate = new Date(endDate as string);\n      }\n\n      const result = await auditService.getFailedLogs(options);\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '获取失败审计日志成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('Failed to get failed audit logs', {\n        component: 'AuditController',\n        error,\n      });\n\n      res.status(500).json({\n        success: false,\n        message: 'Failed to get failed audit logs',\n        error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined,\n      });\n    }\n  }\n\n  /**\n   * 导出审计日志（CSV）\n   * GET /api/audit/export\n   */\n  async exportLogs(req: Request, res: Response) {\n    try {\n      const {\n        userId,\n        action,\n        resourceType,\n        resourceId,\n        status,\n        startDate,\n        endDate,\n      } = req.query;\n\n      const queryParams: any = {};\n      if (userId) {\n        queryParams.userId = userId as string;\n      }\n      if (action) {\n        queryParams.action = Array.isArray(action)\n          ? (action as AuditAction[])\n          : (action as AuditAction);\n      }\n      if (resourceType) {\n        queryParams.resourceType = resourceType as ResourceType;\n      }\n      if (resourceId) {\n        queryParams.resourceId = resourceId as string;\n      }\n      if (status) {\n        queryParams.status = status as AuditStatus;\n      }\n      if (startDate) {\n        queryParams.startDate = new Date(startDate as string);\n      }\n      if (endDate) {\n        queryParams.endDate = new Date(endDate as string);\n      }\n\n      const csv = await auditService.exportToCSV(queryParams);\n\n      res.setHeader('Content-Type', 'text/csv');\n      res.setHeader('Content-Disposition', 'attachment; filename=\"audit_logs.csv\"');\n      res.send(csv);\n    } catch (error) {\n      logger.error('Failed to export audit logs', {\n        component: 'AuditController',\n        error,\n      });\n\n      res.status(500).json({\n        success: false,\n        message: 'Failed to export audit logs',\n        error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined,\n      });\n    }\n  }\n\n  /**\n   * 获取审计统计信息\n   * GET /api/audit/statistics\n   */\n  async getStatistics(req: Request, res: Response) {\n    try {\n      const { startDate, endDate } = req.query;\n\n      const options: { startDate?: Date; endDate?: Date } = {};\n      if (startDate) {\n        options.startDate = new Date(startDate as string);\n      }\n      if (endDate) {\n        options.endDate = new Date(endDate as string);\n      }\n\n      const statistics = await auditService.getStatistics(options);\n\n      ApiResponseHandler.sendSuccess(res, statistics, {\n        message: '获取审计统计成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('Failed to get audit statistics', {\n        component: 'AuditController',\n        error,\n      });\n\n      res.status(500).json({\n        success: false,\n        message: 'Failed to get audit statistics',\n        error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined,\n      });\n    }\n  }\n}\n\nexport const auditController = new AuditController();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/AuthController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4384,4387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4384,4387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6379,6382],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6379,6382],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8032,8035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8032,8035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express'; // [L1]\nimport { logger } from '@/utils/logger'; // [L2]\nimport { AuthServiceV2 } from '@/services/AuthServiceV2'; // [L3]\nimport { toEnhancedError, ExpressErrorHandler } from '@/utils/errorHandler'; // [L4]\n\n/**\n * 认证控制器\n * 职责：处理登录、登出、令牌验证与刷新等认证相关功能。\n * 依赖：AuthServiceV2 提供认证业务逻辑；logger 提供审计日志。\n */ // [L9]\nexport class AuthController { // [L10]\n  private authService: AuthServiceV2; // [L11]\n\n  constructor() { // [L13]\n    this.authService = new AuthServiceV2(); // [L14]\n  } // [L15]\n\n  /**\n   * 用户登录\n   * 路由: POST /api/auth/login\n   * 参数: req.body { username: string, password: string }\n   * 返回: 200 { code, message, data: { token, refreshToken, user, expiresIn }, timestamp }\n   * 异常: 400 INVALID_CREDENTIALS, 401 AUTH_FAILED, 500 LOGIN_ERROR\n   * 使用示例:\n   *  curl -X POST http://localhost:3001/api/auth/login -H \"Content-Type: application/json\" -d '{\"username\":\"admin\",\"password\":\"123456\"}'\n   */ // [L24]\n  async login(req: Request, res: Response): Promise<void> { // [L25]\n    try { // [L26]\n      const { username, password } = req.body as { username?: string; password?: string }; // [L27]\n\n      if (!username || !password) { // [L29]\n        res.status(400).json({ // [L30]\n          code: 'INVALID_CREDENTIALS', // [L31]\n          message: '用户名或密码不能为空', // [L32]\n          data: null, // [L33]\n          timestamp: new Date().toISOString(), // [L34]\n        }); // [L35]\n        return; // [L36]\n      } // [L37]\n\n      const result = await this.authService.login(username, password); // [L39]\n      logger.info('用户登录成功', { user: result.user?.id, env: process.env.NODE_ENV || 'development' }); // [L40]\n\n      res.status(200).json({ // [L42]\n        code: 'SUCCESS', // [L43]\n        message: '登录成功', // [L44]\n        data: { // [L45]\n          token: result.token, // [L46]\n          refreshToken: result.refreshToken, // [L47]\n          user: result.user, // [L48]\n          expiresIn: result.expiresIn, // [L49]\n        }, // [L50]\n        timestamp: new Date().toISOString(), // [L51]\n      }); // [L52]\n    } catch (error: unknown) { // [L53]\n      const enhancedError = toEnhancedError(error, {\n        operation: 'user_login',\n        requestId: req.headers['x-request-id'] as string\n      }); // [L54]\n\n      logger.error('用户登录失败', { error: enhancedError }); // [L55]\n      const statusCode = ExpressErrorHandler.getStatusCode(enhancedError); // [L56]\n      const errorResponse = ExpressErrorHandler.createErrorResponse(enhancedError, req.headers['x-request-id'] as string); // [L57]\n\n      res.status(statusCode).json(errorResponse); // [L58]\n    } // [L59]\n  } // [L63]\n\n  // TRACE-auth-20251005-认证路径统一JSON响应 // [L65]\n\n  /**\n   * 令牌验证\n   * 路由: GET /api/auth/verify\n   * 头部: Authorization: Bearer <token>\n   * 返回: 200 { code:'SUCCESS', message:'Token有效', data:{ valid:true, user }, timestamp }\n   * 异常: 401 AUTHENTICATION_REQUIRED / TOKEN_INVALID / TOKEN_EXPIRED, 500 VERIFY_ERROR\n   * 使用示例:\n   *  curl -H \"Authorization: Bearer <token>\" http://localhost:3001/api/auth/verify\n   */ // [L74]\n  async verifyToken(req: Request, res: Response): Promise<void> { // [L75]\n    try { // [L76]\n      const authHeader = req.headers.authorization || ''; // [L77]\n      if (!authHeader.startsWith('Bearer ')) { // [L78]\n        res.status(401).json({ // [L79]\n          code: 'AUTHENTICATION_REQUIRED', // [L80]\n          message: '未提供认证信息', // [L81]\n          data: null, // [L82]\n          timestamp: new Date().toISOString(), // [L83]\n        }); // [L84]\n        return; // [L85]\n      } // [L86]\n\n      const token = authHeader.substring(7); // [L88]\n      const result = await this.authService.validateToken(token); // [L89]\n\n      if (!result.valid) { // [L91]\n        const code = result.error || 'TOKEN_INVALID'; // [L92]\n        const message = code === 'TOKEN_EXPIRED' ? 'Token已过期' : 'Token无效'; // [L93]\n        res.status(401).json({ // [L94]\n          code, // [L95]\n          message, // [L96]\n          data: null, // [L97]\n          timestamp: new Date().toISOString(), // [L98]\n        }); // [L99]\n        return; // [L100]\n      } // [L101]\n\n      res.status(200).json({ // [L103]\n        code: 'SUCCESS', // [L104]\n        message: 'Token有效', // [L105]\n        data: { valid: true, user: result.user }, // [L106]\n        timestamp: new Date().toISOString(), // [L107]\n      }); // [L108]\n    } catch (error: any) { // [L109]\n      logger.error('Token验证失败', { error }); // [L110]\n      res.status(500).json({ // [L111]\n        code: 'VERIFY_ERROR', // [L112]\n        message: error?.message || 'Token验证失败', // [L113]\n        data: null, // [L114]\n        timestamp: new Date().toISOString(), // [L115]\n      }); // [L116]\n    } // [L117]\n  } // [L118]\n\n  /**\n   * 刷新令牌\n   * 路由: POST /api/auth/refresh\n   * 参数: req.body.refreshToken 或 Authorization: Bearer <refreshToken>\n   * 返回: 200 { code:'SUCCESS', message:'Token刷新成功', data:{ token, refreshToken, expiresIn }, timestamp }\n   * 异常: 400 INVALID_TOKEN, 401 REFRESH_TOKEN_INVALID, 500 REFRESH_ERROR\n   * 使用示例:\n   *  curl -X POST http://localhost:3001/api/auth/refresh -H \"Content-Type: application/json\" -d '{\"refreshToken\":\"...\"}'\n   */ // [L127]\n  async refreshToken(req: Request, res: Response): Promise<void> { // [L128]\n    try { // [L129]\n      const bodyToken = (req.body && (req.body.refreshToken || req.body.token)) as string | undefined; // [L130]\n      const header = req.headers.authorization; // [L131]\n      const bearerToken = header && header.startsWith('Bearer ') ? header.substring(7) : undefined; // [L132]\n      const refreshToken = bodyToken || bearerToken; // [L133]\n\n      if (!refreshToken) { // [L135]\n        res.status(400).json({ // [L136]\n          code: 'INVALID_TOKEN', // [L137]\n          message: '未提供刷新令牌', // [L138]\n          data: null, // [L139]\n          timestamp: new Date().toISOString(), // [L140]\n        }); // [L141]\n        return; // [L142]\n      } // [L143]\n\n      const result = await this.authService.refreshToken(refreshToken); // [L145]\n      logger.info('Token刷新成功'); // [L146]\n\n      res.status(200).json({ // [L148]\n        code: 'SUCCESS', // [L149]\n        message: 'Token刷新成功', // [L150]\n        data: { token: result.token, refreshToken: result.refreshToken, expiresIn: result.expiresIn }, // [L151]\n        timestamp: new Date().toISOString(), // [L152]\n      }); // [L153]\n    } catch (error: any) { // [L154]\n      logger.error('Token刷新失败', { error }); // [L155]\n      const statusCode = error?.code === 'REFRESH_TOKEN_INVALID' ? 401 : 500; // [L156]\n      res.status(statusCode).json({ // [L157]\n        code: error?.code || 'REFRESH_ERROR', // [L158]\n        message: error?.message || 'Token刷新失败', // [L159]\n        data: null, // [L160]\n        timestamp: new Date().toISOString(), // [L161]\n      }); // [L162]\n    } // [L163]\n  } // [L164]\n\n  // TRACE-auth-20251005-认证刷新路径一致性 // [L166]\n\n  /**\n   * 登出\n   * 路由: POST /api/auth/logout\n   * 参数: Authorization: Bearer <token>（可选）\n   * 返回: 200 { code:'SUCCESS', message:'登出成功', data:null, timestamp }\n   * 异常: 401 AUTHENTICATION_REQUIRED, 500 LOGOUT_ERROR\n   * 使用示例:\n   *  curl -X POST http://localhost:3001/api/auth/logout -H \"Authorization: Bearer <token>\"\n   */ // [L175]\n  async logout(req: Request, res: Response): Promise<void> { // [L176]\n    try { // [L177]\n      const authHeader = req.headers.authorization || ''; // [L178]\n      const token = authHeader.startsWith('Bearer ') ? authHeader.substring(7) : undefined; // [L179]\n\n      if (!token) {\n        res.status(401).json({\n          code: 'AUTHENTICATION_REQUIRED',\n          message: '未提供认证信息',\n          data: null,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      await this.authService.logout(token); // [L181]\n      logger.info('用户登出成功'); // [L182]\n\n      res.status(200).json({ // [L184]\n        code: 'SUCCESS', // [L185]\n        message: '登出成功', // [L186]\n        data: null, // [L187]\n        timestamp: new Date().toISOString(), // [L188]\n      }); // [L189]\n    } catch (error: any) { // [L190]\n      logger.error('用户登出失败', { error }); // [L191]\n      const statusCode = error?.code === 'AUTHENTICATION_REQUIRED' ? 401 : 500; // [L192]\n      res.status(statusCode).json({ // [L193]\n        code: error?.code || 'LOGOUT_ERROR', // [L194]\n        message: error?.message || '登出失败', // [L195]\n        data: null, // [L196]\n        timestamp: new Date().toISOString(), // [L197]\n      }); // [L198]\n    } // [L199]\n  } // [L200]\n} // [L201]","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/CadController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DashScopeService' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CAD 控制器\n *\n * 处理 CAD 文件上传、解析和操作请求\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { CadParserService } from '@/services/CadParserService';\nimport { CadOperationService } from '@/services/CadOperationService';\nimport { DashScopeService } from '@/services/DashScopeService';\nimport { CAD_FUNCTION_TOOLS } from '@/utils/cadFunctionTools';\nimport {\n  DxfEntity,\n  CadFileInfo,\n  AddLineParams,\n  AddCircleParams,\n  AddArcParams,\n  MoveEntityParams,\n  DeleteEntityParams,\n  QueryEntitiesParams,\n} from '@llmchat/shared-types';\nimport logger from '@/utils/logger';\nimport { v4 as uuidv4 } from 'uuid';\n\n// 内存存储（生产环境应使用数据库或文件系统）\nconst cadFiles: Map<string, { info: CadFileInfo; entities: DxfEntity[]; content: string }> = new Map();\n\n/**\n * CAD 控制器类\n */\nexport class CadController {\n  private parserService: CadParserService;\n  private operationService: CadOperationService;\n\n  constructor() {\n    this.parserService = new CadParserService();\n    this.operationService = new CadOperationService();\n  }\n\n  /**\n   * 上传 DXF 文件\n   */\n  uploadDxf = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      if (!req.file) {\n        res.status(400).json({\n          code: 'MISSING_FILE',\n          message: '请上传 DXF 文件',\n          data: null,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const dxfContent = req.file.buffer.toString('utf-8');\n      const parseResult = this.parserService.parseDxf(dxfContent);\n\n      const fileId = uuidv4();\n      const fileInfo: CadFileInfo = {\n        id: fileId,\n        fileName: req.file.originalname,\n        fileSize: req.file.size,\n        uploadedAt: new Date().toISOString(),\n        entityCount: parseResult.entities.length,\n        layers: parseResult.layers,\n        ...(parseResult.bounds && { bounds: parseResult.bounds }),\n      };\n\n      // 存储文件信息\n      cadFiles.set(fileId, {\n        info: fileInfo,\n        entities: parseResult.entities,\n        content: dxfContent,\n      });\n\n      const summary = this.parserService.generateSummary(parseResult.entities);\n\n      logger.info('[CadController] DXF 文件上传成功', {\n        fileId,\n        fileName: fileInfo.fileName,\n        entityCount: fileInfo.entityCount,\n      });\n\n      res.json({\n        code: 'SUCCESS',\n        message: 'DXF 文件上传成功',\n        data: {\n          fileInfo,\n          summary,\n        },\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      logger.error('[CadController] 上传 DXF 文件失败', { error });\n      next(error);\n    }\n  };\n\n  /**\n   * 获取 CAD 文件信息\n   */\n  getCadFile = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const { fileId } = req.params;\n\n      if (!fileId) {\n        res.status(400).json({\n          code: 'INVALID_FILE_ID',\n          message: '文件 ID 不能为空',\n          data: null,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const cadFile = cadFiles.get(fileId);\n      if (!cadFile) {\n        res.status(404).json({\n          code: 'FILE_NOT_FOUND',\n          message: '未找到指定的 CAD 文件',\n          data: null,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      res.json({\n        code: 'SUCCESS',\n        message: '获取 CAD 文件信息成功',\n        data: {\n          fileInfo: cadFile.info,\n          entities: cadFile.entities,\n        },\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      logger.error('[CadController] 获取 CAD 文件失败', { error });\n      next(error);\n    }\n  };\n\n  /**\n   * 执行 CAD 操作\n   */\n  executeCadOperation = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const { fileId } = req.params;\n      const { operation, params } = req.body;\n\n      if (!fileId) {\n        res.status(400).json({\n          code: 'INVALID_FILE_ID',\n          message: '文件 ID 不能为空',\n          data: null,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const cadFile = cadFiles.get(fileId);\n      if (!cadFile) {\n        res.status(404).json({\n          code: 'FILE_NOT_FOUND',\n          message: '未找到指定的 CAD 文件',\n          data: null,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      let result;\n      switch (operation) {\n        case 'add_line':\n          result = this.operationService.addLine(cadFile.entities, params as AddLineParams);\n          break;\n        case 'add_circle':\n          result = this.operationService.addCircle(cadFile.entities, params as AddCircleParams);\n          break;\n        case 'add_arc':\n          result = this.operationService.addArc(cadFile.entities, params as AddArcParams);\n          break;\n        case 'move_entity':\n          result = this.operationService.moveEntity(cadFile.entities, params as MoveEntityParams);\n          break;\n        case 'delete_entity':\n          result = this.operationService.deleteEntity(cadFile.entities, params as DeleteEntityParams);\n          break;\n        case 'query_entities':\n          result = this.operationService.queryEntities(cadFile.entities, params as QueryEntitiesParams);\n          break;\n        default:\n          res.status(400).json({\n            code: 'INVALID_OPERATION',\n            message: `不支持的操作: ${operation}`,\n            data: null,\n            timestamp: new Date().toISOString(),\n          });\n          return;\n      }\n\n      // 更新文件信息\n      if (result.success && operation !== 'query_entities') {\n        cadFile.info.entityCount = cadFile.entities.length;\n        cadFile.info.layers = Array.from(new Set(cadFile.entities.map(e => e.layer)));\n      }\n\n      res.json({\n        code: 'SUCCESS',\n        message: '操作执行成功',\n        data: result,\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      logger.error('[CadController] 执行 CAD 操作失败', { error });\n      next(error);\n    }\n  };\n\n  /**\n   * 导出 DXF 文件\n   */\n  exportDxf = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const { fileId } = req.params;\n\n      if (!fileId) {\n        res.status(400).json({\n          code: 'INVALID_FILE_ID',\n          message: '文件 ID 不能为空',\n          data: null,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const cadFile = cadFiles.get(fileId);\n      if (!cadFile) {\n        res.status(404).json({\n          code: 'FILE_NOT_FOUND',\n          message: '未找到指定的 CAD 文件',\n          data: null,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const dxfContent = this.operationService.generateDxf(cadFile.entities);\n\n      res.setHeader('Content-Type', 'application/dxf');\n      res.setHeader('Content-Disposition', `attachment; filename=\"${cadFile.info.fileName}\"`);\n      res.send(dxfContent);\n    } catch (error) {\n      logger.error('[CadController] 导出 DXF 文件失败', { error });\n      next(error);\n    }\n  };\n\n  /**\n   * 获取 Function Calling 工具定义\n   */\n  getFunctionTools = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      logger.info('[CadController] 获取工具定义请求', { path: req.path, method: req.method });\n      res.json({\n        code: 'SUCCESS',\n        message: '获取工具定义成功',\n        data: {\n          tools: CAD_FUNCTION_TOOLS,\n        },\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      logger.error('[CadController] 获取工具定义失败', { error });\n      next(error);\n    }\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/ChatController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'axios' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":13},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[822,825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[822,825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AuthService' is defined but never used. Allowed unused vars must match /^_/u.","line":103,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FastGPTInitResponse' is defined but never used. Allowed unused vars must match /^_/u.","line":117,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":117,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DynamicTypeGuard' is defined but never used. Allowed unused vars must match /^_/u.","line":121,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":121,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FastGPTEventPayload' is defined but never used. Allowed unused vars must match /^_/u.","line":123,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JsonObject' is defined but never used. Allowed unused vars must match /^_/u.","line":125,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FastGPTReasoningData' is defined but never used. Allowed unused vars must match /^_/u.","line":126,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BaseError' is defined but never used. Allowed unused vars must match /^_/u.","line":130,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ValidationError' is defined but never used. Allowed unused vars must match /^_/u.","line":131,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":131,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AuthenticationError' is defined but never used. Allowed unused vars must match /^_/u.","line":132,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":132,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AuthorizationError' is defined but never used. Allowed unused vars must match /^_/u.","line":133,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":133,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NetworkError' is defined but never used. Allowed unused vars must match /^_/u.","line":134,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":134,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExternalServiceError' is defined but never used. Allowed unused vars must match /^_/u.","line":135,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":135,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ResourceError' is defined but never used. Allowed unused vars must match /^_/u.","line":136,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":136,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BusinessLogicError' is defined but never used. Allowed unused vars must match /^_/u.","line":137,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":137,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SystemError' is defined but never used. Allowed unused vars must match /^_/u.","line":138,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":138,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'wrapAsyncHandler' is defined but never used. Allowed unused vars must match /^_/u.","line":140,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":140,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":538,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":538,"endColumn":75},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'protectionContext' is defined but never used. Allowed unused args must match /^_/u.","line":690,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":690,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'protectionContext' is defined but never used. Allowed unused args must match /^_/u.","line":762,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":762,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":915,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":915,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":1119,"column":60,"nodeType":"Identifier","messageId":"unusedVar","endLine":1119,"endColumn":78}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\n\n/**\n * 扩展的 Express Request 接口，包含保护上下文\n */\ninterface ProtectedRequest extends Request {\n  protectionContext?: ProtectedRequestContext;\n}\n\n/**\n * 扩展的 Express Response 接口，包含 flushHeaders 方法\n */\ninterface ExtendedResponse extends Omit<Response, 'flushHeaders'> {\n  flushHeaders(): void;\n}\nimport axios from 'axios';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport Joi from 'joi';\nimport logger from '@/utils/logger';\nimport { ApiResponseHandler } from '@/utils/apiResponse';\n\n/**\n * Joi错误提取工具\n */\nclass ErrorExtractor {\n  /**\n   * 检查是否为已知错误类型\n   */\n  static isKnownError(err: unknown): err is { code: string; httpStatus?: number } {\n    return typeof err === 'object' &&\n           err !== null &&\n           'code' in err &&\n           typeof (err as any).code === 'string';\n  }\n\n  /**\n   * 检查是否为Axios错误\n   */\n  static isAxiosError(err: unknown): err is { response?: { status?: number } } {\n    return typeof err === 'object' &&\n           err !== null &&\n           'isAxiosError' in err;\n  }\n\n  /**\n   * 从Joi验证错误中提取错误消息\n   */\n  static extractMessage(error: unknown): string | undefined {\n    if (typeof error === 'object' && error !== null) {\n      const errorObj = error as Record<string, unknown>;\n      if (Array.isArray(errorObj.details) && errorObj.details.length > 0) {\n        const detail = errorObj.details[0] as Record<string, unknown>;\n        if (typeof detail.message === 'string') {\n          return detail.message;\n        }\n      }\n      if (typeof errorObj.message === 'string') {\n        return errorObj.message;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * 从错误中提取错误代码\n   */\n  static extractCode(err: unknown): string | undefined {\n    if (ErrorExtractor.isKnownError(err)) {\n      return err.code;\n    }\n\n    if (err instanceof Error) {\n      return err.name;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * 从错误中提取HTTP状态码\n   */\n  static extractStatus(err: unknown): number | undefined {\n    if (ErrorExtractor.isKnownError(err)) {\n      return err.httpStatus;\n    }\n\n    // 尝试从Axios错误中提取状态码\n    if (ErrorExtractor.isAxiosError(err)) {\n      return err.response?.status;\n    }\n\n    return undefined;\n  }\n}\n\nimport { AgentConfigService } from '@/services/AgentConfigService';\nimport { ChatProxyService } from '@/services/ChatProxyService';\nimport { ChatInitService } from '@/services/ChatInitService';\nimport { ChatHistoryService, ChatHistoryQueryOptions } from '@/services/ChatHistoryService';\nimport { FastGPTSessionService } from '@/services/FastGPTSessionService';\nimport { authService } from '@/services/authInstance';\nimport { AuthUser, AuthService } from '@/services/AuthService';\nimport { analyticsService } from '@/services/analyticsInstance';\nimport { getProtectionService, ProtectedRequestContext } from '@/services/ProtectionService';\nimport {\n  ChatMessage,\n  ChatOptions,\n  ChatRequest,\n  ApiError,\n  StreamStatus,\n  ChatAttachmentMetadata,\n  VoiceNoteMetadata,\n  FastGPTChatHistorySummary,\n  FastGPTChatHistoryDetail,\n  FeedbackRequest,\n  FastGPTInitResponse,\n} from '@/types';\nimport {\n  JsonValue,\n  DynamicTypeGuard,\n  SafeAccess,\n  FastGPTEventPayload,\n  DynamicDataConverter,\n  JsonObject,\n  FastGPTReasoningData,\n} from '@/types/dynamic';\nimport type { SSEEventData } from '@/types/provider';\nimport {\n  BaseError,\n  ValidationError,\n  AuthenticationError,\n  AuthorizationError,\n  NetworkError,\n  ExternalServiceError,\n  ResourceError,\n  BusinessLogicError,\n  SystemError,\n  createErrorFromUnknown,\n  wrapAsyncHandler,\n} from '@/types/errors';\nimport { generateId, formatFileSize } from '@/utils/helpers';\n\n/**\n * 认证用户检查函数\n */\nasync function requireAuthenticatedUser(req: Request): Promise<AuthUser> {\n  const authorization = req.headers['authorization'];\n  const token = (authorization || '').replace(/^Bearer\\s+/i, '').trim();\n  if (!token) {\n    throw new Error('UNAUTHORIZED');\n  }\n  try {\n    return await authService.profile(token);\n  } catch (error) {\n    if (error instanceof Error && error.message === 'TOKEN_EXPIRED') {\n      throw new Error('TOKEN_EXPIRED');\n    }\n    throw new Error('UNAUTHORIZED');\n  }\n}\n\n/**\n * 聊天控制器\n */\nexport class ChatController {\n  private agentService: AgentConfigService;\n  private chatService: ChatProxyService;\n  private initService: ChatInitService;\n  private historyService: ChatHistoryService;\n  private fastgptSessionService: FastGPTSessionService;\n  private protectionService = getProtectionService();\n  private uploadDir: string;\n  private static readonly supportedHistoryRoles = ['user', 'assistant', 'system'] as const;\n\n  constructor() {\n    this.agentService = new AgentConfigService();\n    this.chatService = new ChatProxyService(this.agentService);\n    this.initService = new ChatInitService(this.agentService);\n    this.historyService = new ChatHistoryService();\n    this.fastgptSessionService = new FastGPTSessionService(this.agentService);\n    this.uploadDir = path.resolve(__dirname, '../../uploads');\n  }\n\n  /**\n   * 聊天初始化请求验证Schema\n   */\n  private chatInitSchema = Joi.object({\n    appId: Joi.string().required().messages({\n      'any.required': '应用ID不能为空',\n      'string.empty': '应用ID不能为空',\n    }),\n    chatId: Joi.string().optional(),\n    stream: Joi.boolean().optional().default(false),\n  });\n\n  /**\n   * 聊天请求验证Schema\n   */\n  private chatRequestSchema = Joi.object({\n    agentId: Joi.string().required().messages({\n      'any.required': '智能体ID不能为空',\n      'string.empty': '智能体ID不能为空',\n    }),\n    messages: Joi.array().items(\n      Joi.object({\n        role: Joi.string().valid('user', 'assistant', 'system').required(),\n        content: Joi.string().required().messages({\n          'any.required': '消息内容不能为空',\n          'string.empty': '消息内容不能为空',\n        }),\n        id: Joi.string().optional(),\n        timestamp: Joi.number().optional(),\n        attachments: Joi.array().items(\n          Joi.object({\n            id: Joi.string().optional(),\n            url: Joi.string().uri().optional(),\n            name: Joi.string().required(),\n            mimeType: Joi.string().required(),\n            size: Joi.number().min(0).required(),\n            source: Joi.string().valid('upload', 'voice', 'external').optional(),\n          }),\n        ).optional(),\n        voiceNote: Joi.object({\n          id: Joi.string().optional(),\n          url: Joi.string().uri().optional(),\n          duration: Joi.number().min(0).required(),\n          mimeType: Joi.string().required(),\n          size: Joi.number().min(0).optional(),\n        }).optional(),\n        metadata: Joi.object().optional(),\n      }),\n    ).min(1).required().messages({\n      'array.min': '至少需要一条消息',\n      'any.required': '消息列表不能为空',\n    }),\n    stream: Joi.boolean().optional().default(false),\n    // 兼容顶层直传（标准FastGPT格式）\n    chatId: Joi.string().optional(),\n    detail: Joi.boolean().optional(),\n    temperature: Joi.number().min(0).max(2).optional(),\n    maxTokens: Joi.number().min(1).max(32768).optional(),\n    variables: Joi.object().optional(),\n    responseChatItemId: Joi.string().optional(),\n    retainDatasetCite: Joi.boolean().optional(),\n    appId: Joi.string().optional(),\n    // 兼容原有 options 格式\n    options: Joi.object({\n      chatId: Joi.string().optional(),\n      detail: Joi.boolean().optional(),\n      temperature: Joi.number().min(0).max(2).optional(),\n      maxTokens: Joi.number().min(1).max(32768).optional(),\n      // 允许旧用法把 variables 放到 options 里\n      variables: Joi.object().optional(),\n      responseChatItemId: Joi.string().optional(),\n    }).optional(),\n    attachments: Joi.array().items(\n      Joi.object({\n        id: Joi.string().optional(),\n        url: Joi.string().uri().optional(),\n        name: Joi.string().required(),\n        mimeType: Joi.string().required(),\n        size: Joi.number().min(0).required(),\n        source: Joi.string().valid('upload', 'voice', 'external').optional(),\n      }),\n    ).optional(),\n    voiceNote: Joi.object({\n      id: Joi.string().optional(),\n      url: Joi.string().uri().optional(),\n      duration: Joi.number().min(0).required(),\n      mimeType: Joi.string().required(),\n      size: Joi.number().min(0).optional(),\n    }).optional(),\n  });\n\n  private historyListSchema = Joi.object({\n    agentId: Joi.string().required().messages({\n      'any.required': '智能体ID不能为空',\n      'string.empty': '智能体ID不能为空',\n    }),\n    page: Joi.number().min(1).optional(),\n    pageSize: Joi.number().min(1).max(200).optional(),\n  });\n\n  private historyDetailSchema = Joi.object({\n    agentId: Joi.string().required().messages({\n      'any.required': '智能体ID不能为空',\n      'string.empty': '智能体ID不能为空',\n    }),\n  });\n\n  private historyMessagesSchema = Joi.object({\n    limit: Joi.number().integer().min(1).max(200).optional(),\n    offset: Joi.number().integer().min(0).optional(),\n    role: Joi.alternatives()\n      .try(\n        Joi.string(),\n        Joi.array().items(Joi.string()),\n      )\n      .optional(),\n  });\n\n  private historyDeleteSchema = Joi.object({\n    agentId: Joi.string().required().messages({\n      'any.required': '智能体ID不能为空',\n      'string.empty': '智能体ID不能为空',\n    }),\n  });\n\n  private historyRetrySchema = Joi.object({\n    agentId: Joi.string().required().messages({\n      'any.required': '智能体ID不能为空',\n      'string.empty': '智能体ID不能为空',\n    }),\n    dataId: Joi.string().required().messages({\n      'any.required': '消息ID不能为空',\n      'string.empty': '消息ID不能为空',\n    }),\n    stream: Joi.boolean().optional().default(false),\n    detail: Joi.boolean().optional(),\n  });\n  /**\n   * 点赞/点踩反馈请求验证Schema\n   */\n  private feedbackSchema = Joi.object({\n    agentId: Joi.string().required().messages({\n      'any.required': '智能体ID不能为空',\n      'string.empty': '智能体ID不能为空',\n    }),\n    chatId: Joi.string().required().messages({\n      'any.required': 'chatId不能为空',\n      'string.empty': 'chatId不能为空',\n    }),\n    dataId: Joi.string().required().messages({\n      'any.required': 'dataId不能为空',\n      'string.empty': 'dataId不能为空',\n    }),\n    userGoodFeedback: Joi.string().optional(),\n    userBadFeedback: Joi.string().optional(),\n  });\n  private attachmentUploadSchema = Joi.object({\n    filename: Joi.string().max(256).required(),\n    mimeType: Joi.string().max(128).required(),\n    size: Joi.number().min(1).max(20 * 1024 * 1024).required(),\n    data: Joi.string().required(),\n    source: Joi.string().valid('upload', 'voice', 'external').optional(),\n  });\n\n  private decorateMessages(\n    messages: ChatMessage[],\n    attachments?: ChatAttachmentMetadata[] | null,\n    voiceNote?: VoiceNoteMetadata | null,\n  ): ChatMessage[] {\n    const list = (messages || []).map((msg) => {\n      const result: ChatMessage = {\n        ...msg,\n        ...(msg.metadata && { metadata: { ...msg.metadata } }),\n        ...(msg.attachments && { attachments: [...msg.attachments] }),\n      };\n\n      if (msg.voiceNote !== undefined) {\n        result.voiceNote = msg.voiceNote;\n      }\n\n      return result;\n    });\n\n    if ((!attachments || attachments.length === 0) && !voiceNote) {\n      return list;\n    }\n\n    const index = this.findLastUserMessageIndex(list);\n    if (index === -1) {\n      return list;\n    }\n\n    const target = list[index];\n    if (!target) {\n      return list;\n    }\n\n    const summary: string[] = [];\n    const mergedAttachments: ChatAttachmentMetadata[] = target.attachments\n      ? [...target.attachments]\n      : [];\n\n    if (attachments && attachments.length > 0) {\n      attachments.forEach((att, idx) => {\n        mergedAttachments.push(att);\n        summary.push(\n          `附件${idx + 1}: ${att.name} (${formatFileSize(att.size)}) -> ${att.url}`,\n        );\n      });\n    }\n\n    if (voiceNote) {\n      summary.push(\n        `语音: ${voiceNote.duration.toFixed(1)} 秒 (${voiceNote.mimeType}) -> ${voiceNote.url}`,\n      );\n    }\n\n    if (summary.length > 0) {\n      target.content = `${target.content}\\n\\n${summary.join('\\n')}`.trim();\n    }\n\n    if (mergedAttachments.length > 0) {\n      target.attachments = mergedAttachments;\n    }\n\n    const finalVoice = voiceNote || target.voiceNote || null;\n    target.voiceNote = finalVoice;\n\n    const newMetadata: ChatMessage['metadata'] = {\n      ...(target.metadata || {}),\n      ...(mergedAttachments.length ? { attachments: mergedAttachments } : {}),\n      ...(finalVoice ? { voiceNote: finalVoice } : {}),\n    };\n\n    if (Object.keys(newMetadata).length > 0) {\n      target.metadata = newMetadata;\n    }\n\n    return list;\n  }\n\n  private findLastUserMessageIndex(messages: ChatMessage[]): number {\n    for (let i = messages.length - 1; i >= 0; i -= 1) {\n      if (messages[i]?.role === 'user') {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private findLastUserMessage(messages: ChatMessage[]): ChatMessage | null {\n    const index = this.findLastUserMessageIndex(messages);\n    return index >= 0 && messages[index] ? messages[index] : null;\n  }\n\n  private resolveClientIp(req: Request): string | null {\n    const forwarded = req.headers['x-forwarded-for'];\n    if (Array.isArray(forwarded) && forwarded.length > 0) {\n      return forwarded[0] || null;\n    }\n    if (typeof forwarded === 'string' && forwarded.trim()) {\n      return forwarded;\n    }\n\n    const realIp = req.headers['x-real-ip'];\n    if (Array.isArray(realIp) && realIp.length > 0) {\n      return realIp[0] || null;\n    }\n    if (typeof realIp === 'string' && realIp.trim()) {\n      return realIp;\n    }\n\n    if (typeof req.ip === 'string' && req.ip.trim()) {\n      return req.ip;\n    }\n\n    const socketAddress = req.socket && typeof req.socket.remoteAddress === 'string'\n      ? req.socket.remoteAddress\n      : null;\n    return socketAddress;\n  }\n\n  private async recordGeoSnapshot(req: Request, agentId: string, sessionId?: string | null): Promise<void> {\n    try {\n      const ip = this.resolveClientIp(req);\n      await analyticsService.recordAgentRequest({\n        agentId,\n        sessionId: sessionId || null,\n        ip: ip || null,\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'recordGeoSnapshot',\n        agentId,\n      });\n      logger.warn('[ChatController] 记录地域分析失败', { error: typedError.message });\n    }\n  }\n\n  private buildSessionTitle(messages: ChatMessage[]): string {\n    const lastUser = this.findLastUserMessage(messages);\n    if (!lastUser) {\n      return '新对话';\n    }\n    const content = (lastUser.content || '').replace(/\\s+/g, ' ').trim();\n    if (!content) {\n      return '新对话';\n    }\n    return content.length > 30 ? `${content.slice(0, 30)}...` : content;\n  }\n\n  private async recordUserHistory(\n    sessionId: string,\n    agentId: string,\n    messages: ChatMessage[],\n    attachments?: ChatAttachmentMetadata[] | null,\n    voiceNote?: VoiceNoteMetadata | null,\n  ): Promise<void> {\n    const lastUser = this.findLastUserMessage(messages);\n    if (!lastUser) {\n      return;\n    }\n    try {\n      await this.historyService.appendMessage({\n        sessionId,\n        agentId,\n        role: 'user',\n        content: lastUser.content,\n        ...(attachments?.length || voiceNote ? {\n          metadata: {\n            attachments: attachments?.length ? attachments : undefined,\n            voiceNote: voiceNote || null,\n          },\n        } : {}),\n        ...(lastUser.id ? { messageId: lastUser.id } : {}),\n        titleHint: this.buildSessionTitle(messages),\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'recordUserHistory',\n        sessionId,\n        agentId,\n      });\n      logger.warn('[ChatController] 记录用户消息失败', { error: typedError.message });\n    }\n  }\n\n  /**\n   * 发送聊天请求\n   * POST /api/chat/completions\n   */\n  chatCompletions = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      // 验证请求数据\n      const { error, value } = this.chatRequestSchema.validate(req.body);\n      if (error) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { agentId, messages, stream } = value as ChatRequest;\n      const attachments: ChatAttachmentMetadata[] | undefined = value.attachments;\n      const voiceNote: VoiceNoteMetadata | undefined = value.voiceNote;\n\n      // 统一兼容：顶层与 options 的混用，归一化为 ChatOptions\n      const normalizedOptions: ChatOptions = {\n        ...(value.options || {}),\n        ...(value.chatId ? { chatId: value.chatId } : {}),\n        ...(typeof value.detail === 'boolean' ? { detail: value.detail } : {}),\n        ...(typeof value.temperature === 'number' ? { temperature: value.temperature } : {}),\n        ...(typeof value.maxTokens === 'number' ? { maxTokens: value.maxTokens } : {}),\n        ...(value.variables ? { variables: value.variables } : {}),\n        ...(value.responseChatItemId ? { responseChatItemId: value.responseChatItemId } : {}),\n        ...(attachments ? { attachments } : {}),\n        ...(voiceNote ? { voiceNote } : {}),\n      };\n\n      const sessionId = normalizedOptions.chatId || value.chatId || generateId();\n      normalizedOptions.chatId = sessionId;\n\n      const decoratedMessages = this.decorateMessages(\n        Array.isArray(messages) ? messages : [],\n        attachments,\n        voiceNote,\n      );\n\n      // 检查智能体是否存在\n      const agent = await this.agentService.getAgent(agentId);\n      if (!agent) {\n        const apiError: ApiError = {\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(404).json(apiError);\n        return;\n      }\n\n      if (!agent.isActive) {\n        const apiError: ApiError = {\n          code: 'AGENT_INACTIVE',\n          message: `智能体未激活: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      await this.historyService.ensureSession(\n        sessionId,\n        agentId,\n        this.buildSessionTitle(decoratedMessages),\n      );\n\n      await this.recordGeoSnapshot(req, agentId, sessionId);\n\n      await this.recordUserHistory(\n        sessionId,\n        agentId,\n        decoratedMessages,\n        attachments,\n        voiceNote,\n      );\n\n      logger.debug('🧪 [chatCompletions] 入参(归一化)', {\n        agentId,\n        stream,\n        options: normalizedOptions,\n        messagesCount: decoratedMessages.length,\n      });\n\n      // 获取保护上下文\n      const protectionContext = (req as ProtectedRequest).protectionContext;\n\n      // 处理流式请求\n      if (stream) {\n        await this.handleStreamRequest(\n          res,\n          agentId,\n          decoratedMessages,\n          normalizedOptions,\n          sessionId,\n          attachments,\n          voiceNote || null,\n          protectionContext,\n        );\n      } else {\n        await this.handleNormalRequest(\n          res,\n          agentId,\n          decoratedMessages,\n          normalizedOptions,\n          sessionId,\n          attachments,\n          voiceNote || null,\n          protectionContext,\n        );\n      }\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'chatCompletions',\n        url: req.originalUrl,\n        method: req.method,\n      });\n\n      logger.error('聊天请求处理失败', { error: typedError });\n\n      // 如果响应头已发送（流式响应中），不能再发送JSON响应\n      if (res.headersSent) {\n        return;\n      }\n\n      const apiError: ApiError = {\n        code: typedError.code,\n        message: typedError.getUserMessage(),\n        timestamp: typedError.timestamp,\n        ...(process.env.NODE_ENV === 'development' && typedError.context && {\n          details: typedError.context as JsonValue,\n        }),\n      };\n\n      const statusCode = this.getErrorStatusCode(typedError);\n      res.status(statusCode).json(apiError);\n    }\n  };\n\n  /**\n   * 处理普通（非流式）聊天请求\n   */\n  private async handleNormalRequest(\n    res: Response,\n    agentId: string,\n    messages: ChatMessage[],\n    options: ChatOptions | undefined,\n    sessionId: string,\n    _attachments?: ChatAttachmentMetadata[] | null,\n    _voiceNote?: VoiceNoteMetadata | null,\n    protectionContext?: ProtectedRequestContext,\n  ): Promise<void> {\n    try {\n      const response = await this.chatService.sendMessage(\n        agentId,\n        messages,\n        options,\n      );\n      const assistantContent =\n        response?.choices?.[0]?.message?.content || '';\n\n      try {\n        await this.historyService.appendMessage({\n          sessionId,\n          agentId,\n          role: 'assistant',\n          content: assistantContent,\n          ...(options?.responseChatItemId ? {\n            metadata: { responseChatItemId: options.responseChatItemId },\n          } : {}),\n        });\n      } catch (unknownError) {\n        const typedError = createErrorFromUnknown(unknownError, {\n          component: 'ChatController',\n          operation: 'recordAssistantMessage',\n          sessionId,\n          agentId,\n        });\n        logger.warn('[ChatController] 记录助手消息失败', { error: typedError.message });\n      }\n\n      ApiResponseHandler.sendSuccess(res, { ...response, chatId: sessionId }, {\n        message: '聊天请求成功',\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'handleNormalRequest',\n        sessionId,\n        agentId,\n      });\n\n      logger.error('普通聊天请求失败', { error: typedError.message });\n\n      // 检查是否是降级响应\n      if (typeof unknownError === 'object' && unknownError !== null && 'fallbackUsed' in unknownError) {\n        const fallbackError = unknownError as { fallbackUsed?: boolean; data?: JsonValue };\n        if (fallbackError.fallbackUsed) {\n          ApiResponseHandler.sendSuccess(res, fallbackError.data ?? null, {\n            message: '已返回降级响应',\n          });\n          return;\n        }\n      }\n\n      const apiError = typedError.toApiError();\n      const statusCode = this.getErrorStatusCode(typedError);\n      res.status(statusCode).json(apiError);\n    }\n  }\n\n  /**\n   * 处理流式聊天请求 - 修复 FastGPT 流式响应\n   */\n  private async handleStreamRequest(\n    res: Response,\n    agentId: string,\n    messages: ChatMessage[],\n    options: ChatOptions | undefined,\n    sessionId: string,\n    _attachments?: ChatAttachmentMetadata[] | null,\n    _voiceNote?: VoiceNoteMetadata | null,\n    protectionContext?: ProtectedRequestContext,\n  ): Promise<void> {\n    try {\n      // 标准 SSE 响应头\n      res.setHeader('Content-Type', 'text/event-stream; charset=utf-8');\n      res.setHeader('Cache-Control', 'no-cache, no-transform');\n      res.setHeader('Connection', 'keep-alive');\n      res.setHeader('X-Accel-Buffering', 'no'); // 兼容反向代理\n      // 立即刷新头部，避免缓冲\n      const extendedRes = res as ExtendedResponse;\n      if (typeof extendedRes.flushHeaders === 'function') {\n        extendedRes.flushHeaders();\n      }\n\n      logger.debug('🚀 开始处理流式请求', { agentId });\n\n      // 发送初始化事件\n      this.sendSSEEvent(res, 'chatId', { chatId: sessionId } as JsonValue);\n      this.sendSSEEvent(res, 'start', {\n        id: generateId(),\n        timestamp: new Date().toISOString(),\n        agentId,\n      } as JsonValue);\n\n      let assistantContent = '';\n\n      // 发送流式消息\n      await this.chatService.sendStreamMessage(\n        agentId,\n        messages,\n        // 内容回调 - 确保正确调用\n        (chunk: string) => {\n          logger.debug('📨 收到内容块', { preview: chunk.substring(0, 50) });\n          assistantContent += chunk;\n          this.sendSSEEvent(res, 'chunk', { content: chunk } as JsonValue);\n        },\n        // 状态回调 - 确保正确调用\n        (status: StreamStatus) => {\n          logger.debug('📊 收到状态更新', { status });\n          this.sendSSEEvent(res, 'status', DynamicDataConverter.toSafeJsonValue(status));\n\n          // 如果是完成或错误状态，结束响应\n          if (status.type === 'complete' || status.type === 'error') {\n            logger.debug('✅ 流式响应完成');\n            this.sendSSEEvent(res, 'end', {\n              timestamp: new Date().toISOString(),\n            } as JsonValue);\n            res.end();\n          }\n        },\n        options,\n        // 事件透传回调：关注 FastGPT 的 interactive 以及 chatId 事件\n        (eventName: string, data: SSEEventData) => {\n          if (!eventName) {\n            return;\n          }\n\n          if (eventName === 'interactive') {\n            let payloadPreview = '[Unserializable]';\n            try {\n              payloadPreview = JSON.stringify(data).slice(0, 300);\n            } catch { /* ignored */ }\n            logger.debug('🧩 收到交互节点事件 interactive', { payloadPreview });\n            this.sendSSEEvent(res, 'interactive', DynamicDataConverter.toSafeJsonValue(data));\n            return;\n          }\n\n          if (eventName === 'chatId') {\n            const dataObj = (typeof data === 'object' && data !== null) ? data : {};\n            const chatId = (dataObj.chatId || dataObj.id || data) as string | JsonValue;\n            logger.debug('🆔 透传本次使用的 chatId', { chatId });\n            this.sendSSEEvent(res, 'chatId', DynamicDataConverter.toSafeJsonValue(data));\n            return;\n          }\n\n          logger.debug('📎 透传 FastGPT 事件', { eventName });\n          this.sendSSEEvent(res, eventName, DynamicDataConverter.toSafeJsonValue(data));\n        },\n      );\n\n      if (assistantContent) {\n        try {\n          await this.historyService.appendMessage({\n            sessionId,\n            agentId,\n            role: 'assistant',\n            content: assistantContent,\n            ...(options?.responseChatItemId ? {\n              metadata: { responseChatItemId: options.responseChatItemId },\n            } : {}),\n          });\n        } catch (unknownError) {\n          const typedError = createErrorFromUnknown(unknownError, {\n            component: 'ChatController',\n            operation: 'recordStreamAssistantMessage',\n            sessionId,\n            agentId,\n          });\n          logger.warn('[ChatController] 记录流式助手消息失败', { error: typedError.message });\n        }\n      }\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'handleStreamRequest',\n        sessionId,\n        agentId,\n      });\n\n      logger.error('❌ 流式聊天请求失败', { error: typedError.message });\n\n      // 检查是否是降级响应\n      if (typeof unknownError === 'object' && unknownError !== null && 'fallbackUsed' in unknownError) {\n        const fallbackError = unknownError as { fallbackUsed?: boolean; data?: JsonValue };\n        if (fallbackError.fallbackUsed) {\n          this.sendSSEEvent(res, 'fallback', (fallbackError.data || null) as JsonValue);\n          res.end();\n          return;\n        }\n      }\n\n      // 发送错误事件\n      this.sendSSEEvent(res, 'error', {\n        code: typedError.code,\n        message: typedError.message,\n        timestamp: typedError.timestamp,\n      } as JsonValue);\n\n      res.end();\n    }\n  }\n\n  /**\n   * 发送SSE事件\n   */\n  private sendSSEEvent(res: Response, event: string, data: unknown): void {\n    try {\n      res.write(`event: ${event}\\n`);\n      res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'sendSSEEvent',\n        context: { event, dataType: typeof data },\n      });\n      logger.error('发送SSE事件失败', { error: typedError.message });\n    }\n  }\n\n  /**\n   * 聊天初始化接口\n   * GET /api/chat/init?appId=xxx&chatId=xxx&stream=true\n   */\n  chatInit = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      // 参数验证\n      const { error, value } = this.chatInitSchema.validate(req.query);\n      if (error) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { appId, chatId, stream } = value;\n\n      logger.debug('🚀 处理聊天初始化请求', { appId, chatId, stream });\n\n      // 检查智能体是否存在且激活\n      const agent = await this.agentService.getAgent(appId);\n      if (!agent) {\n        const apiError: ApiError = {\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${appId}`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(404).json(apiError);\n        return;\n      }\n\n      if (!agent.isActive) {\n        const apiError: ApiError = {\n          code: 'AGENT_INACTIVE',\n          message: `智能体未激活: ${appId}`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      await this.recordGeoSnapshot(req, agent.id, typeof chatId === 'string' ? chatId : null);\n\n      // 根据stream参数决定处理方式\n      if (stream) {\n        await this.handleInitStreamRequest(res, appId, chatId);\n      } else {\n        await this.handleInitNormalRequest(res, appId, chatId);\n      }\n\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'chatInit',\n        url: req.originalUrl,\n        method: req.method,\n      });\n\n      logger.error('聊天初始化请求处理失败', { error: typedError.message });\n\n      // 如果响应头已发送（流式响应中），不能再发送JSON响应\n      if (res.headersSent) {\n        return;\n      }\n\n      const apiError = typedError.toApiError();\n\n      if (process.env.NODE_ENV === 'development') {\n        apiError.details = {\n          originalError: typedError.message,\n          ...(typedError.stack && { stack: typedError.stack }),\n        } as JsonValue;\n      }\n\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 处理普通（非流式）初始化请求\n   */\n  private async handleInitNormalRequest(\n    res: Response,\n    appId: string,\n    chatId?: string,\n  ): Promise<void> {\n    try {\n      const initData = await this.initService.getInitData(appId, chatId);\n\n      ApiResponseHandler.sendSuccess(res, initData, {\n        message: '初始化数据获取成功',\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'handleInitNormalRequest',\n        url: res.req?.originalUrl,\n        method: res.req?.method,\n        context: { appId, chatId },\n      });\n\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  }\n\n  /**\n   * 处理流式初始化请求\n   */\n  private async handleInitStreamRequest(\n    res: Response,\n    appId: string,\n    chatId?: string,\n  ): Promise<void> {\n    try {\n      // 设置SSE响应头\n      res.setHeader('Content-Type', 'text/event-stream; charset=utf-8');\n      res.setHeader('Cache-Control', 'no-cache, no-transform');\n      res.setHeader('Connection', 'keep-alive');\n      res.setHeader('X-Accel-Buffering', 'no');\n\n      // 立即刷新头部\n      const extendedRes = res as ExtendedResponse;\n      if (typeof extendedRes.flushHeaders === 'function') {\n        extendedRes.flushHeaders();\n      }\n\n      logger.debug('🚀 开始处理流式初始化请求', { appId });\n      logger.debug('ℹ️ 初始化流仅包含 start/chunk/complete/end 事件，不包含 interactive 事件');\n\n      // 发送初始化事件\n      this.sendSSEEvent(res, 'start', {\n        id: generateId(),\n        timestamp: new Date().toISOString(),\n        appId,\n        type: 'init',\n      } as JsonValue);\n\n      // 调用流式初始化服务\n      await this.initService.getInitDataStream(\n        appId,\n        chatId,\n        // 内容回调 - 流式输出开场白\n        (chunk: string) => {\n          this.sendSSEEvent(res, 'chunk', { content: chunk } as JsonValue);\n        },\n        // 完成回调 - 返回完整初始化数据\n        (initData) => {\n          logger.debug('✅ 初始化数据获取完成');\n          this.sendSSEEvent(res, 'complete', DynamicDataConverter.toSafeJsonValue({\n            data: initData,\n            timestamp: new Date().toISOString(),\n          }));\n          this.sendSSEEvent(res, 'end', {\n            timestamp: new Date().toISOString(),\n          } as JsonValue);\n          res.end();\n        },\n        // 错误回调\n        (unknownError) => {\n          const typedError = createErrorFromUnknown(unknownError, {\n            component: 'ChatController',\n            operation: 'initDataStream',\n            context: { appId, chatId },\n          });\n          logger.error('❌ 初始化流式处理失败', { error: typedError.message });\n          this.sendSSEEvent(res, 'error', {\n            code: typedError.code,\n            message: typedError.message,\n            timestamp: typedError.timestamp,\n          } as JsonValue);\n          this.sendSSEEvent(res, 'end', {\n            timestamp: new Date().toISOString(),\n          } as JsonValue);\n          res.end();\n        },\n      );\n\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'handleInitStreamRequest',\n        url: res.req?.originalUrl,\n        method: res.req?.method,\n        context: { appId, chatId },\n      });\n      logger.error('❌ 流式初始化请求处理失败', { error: typedError.message });\n\n      if (!res.headersSent) {\n        const apiError = typedError.toApiError();\n        res.status(500).json(apiError);\n      } else {\n        this.sendSSEEvent(res, 'error', {\n          code: typedError.code,\n          message: typedError.message,\n          timestamp: typedError.timestamp,\n        } as JsonValue);\n        res.end();\n      }\n    }\n  }\n  /**\n   * 点赞/点踩反馈\n   * POST: /api/chat/feedback\n   */\n  updateUserFeedback = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const { error, value } = this.feedbackSchema.validate(req.body);\n      if (error) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { agentId, chatId, dataId, userGoodFeedback, userBadFeedback } = value as FeedbackRequest;\n\n      const feedbackData: {\n        chatId: string;\n        dataId: string;\n        userGoodFeedback?: string;\n        userBadFeedback?: string;\n      } = {\n        chatId,\n        dataId,\n      };\n      if (userGoodFeedback !== undefined) {\n        feedbackData.userGoodFeedback = userGoodFeedback.toString();\n      }\n      if (userBadFeedback !== undefined) {\n        feedbackData.userBadFeedback = userBadFeedback.toString();\n      }\n\n      await this.fastgptSessionService.updateUserFeedback(agentId, feedbackData);\n\n      ApiResponseHandler.sendSuccess(res, null, {\n        message: '反馈提交成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'updateUserFeedback',\n        url: req.originalUrl,\n        method: req.method,\n      });\n      logger.error('提交点赞/点踩反馈失败', { error: typedError.message });\n\n      const apiError = typedError.toApiError();\n      let status = this.getErrorStatusCode(typedError);\n\n      // 特殊处理某些错误代码\n      const originalErrorObj = SafeAccess.getObject(typedError.context, 'originalError');\n      const originalError = originalErrorObj as Error | undefined;\n      if (originalError) {\n        const errCode = ErrorExtractor.extractCode(originalError);\n        const axiosStatus = ErrorExtractor.extractStatus(originalError);\n        if (errCode === 'NOT_FOUND') {\n          status = 404;\n          apiError.code = 'AGENT_NOT_FOUND';\n        } else if (errCode === 'INVALID_PROVIDER' || errCode === 'INVALID_APP_ID') {\n          status = 400;\n          apiError.code = errCode;\n        } else if (axiosStatus === 404) {\n          status = 502;\n          apiError.code = 'UPSTREAM_NOT_FOUND';\n        } else if (axiosStatus === 401) {\n          status = 401;\n          apiError.code = 'UPSTREAM_UNAUTHORIZED';\n        } else if (axiosStatus === 408) {\n          status = 504;\n          apiError.code = 'UPSTREAM_TIMEOUT';\n        }\n      }\n\n      res.status(status).json(apiError);\n    }\n  };\n\n  /**\n   * 获取会话历史列表\n   * GET /api/chat/history?agentId=xxx\n   */\n  listChatHistories = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const { error, value } = this.historyListSchema.validate(req.query);\n      if (error) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { agentId, page, pageSize } = value as { agentId: string; page?: number; pageSize?: number };\n\n      const agent = await this.agentService.getAgent(agentId);\n      if (!agent) {\n        const apiError: ApiError = {\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(404).json(apiError);\n        return;\n      }\n\n      if (agent.provider !== 'fastgpt') {\n        const apiError: ApiError = {\n          code: 'INVALID_PROVIDER',\n          message: `智能体 ${agentId} 不支持远程会话历史查询`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const pagination: { page?: number; pageSize?: number } = {};\n      if (typeof page === 'number') {\n        pagination.page = page;\n      }\n      if (typeof pageSize === 'number') {\n        pagination.pageSize = pageSize;\n      }\n      const histories: FastGPTChatHistorySummary[] = await this.fastgptSessionService.listHistories(\n        agentId,\n        pagination,\n      );\n\n      const extraMetadata: Record<string, JsonValue> = {};\n      if (typeof pagination.page === 'number') {\n        extraMetadata.page = pagination.page;\n      }\n      if (typeof pagination.pageSize === 'number') {\n        extraMetadata.pageSize = pagination.pageSize;\n      }\n\n      ApiResponseHandler.sendSuccess(res, histories, {\n        message: '获取聊天历史成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n        ...(Object.keys(extraMetadata).length\n          ? { metadata: { extra: extraMetadata } }\n          : {}),\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'listChatHistories',\n        url: req.originalUrl,\n        method: req.method,\n      });\n      logger.error('获取聊天历史列表失败', { error: typedError.message });\n\n      const apiError = typedError.toApiError();\n      let status = this.getErrorStatusCode(typedError);\n\n      // 错误语义映射\n      const originalErrorObj = SafeAccess.getObject(typedError.context, 'originalError');\n      const originalError = originalErrorObj as Error | undefined;\n      if (originalError) {\n        const errCode = ErrorExtractor.extractCode(originalError);\n        const axiosStatus = ErrorExtractor.extractStatus(originalError);\n        if (errCode === 'NOT_FOUND') {\n          status = 404;\n          apiError.code = 'AGENT_NOT_FOUND';\n        } else if (errCode === 'INVALID_PROVIDER' || errCode === 'INVALID_APP_ID') {\n          status = 400;\n          apiError.code = errCode;\n        } else if (axiosStatus === 404) {\n          status = 502;\n          apiError.code = 'UPSTREAM_NOT_FOUND';\n        } else if (axiosStatus === 401) {\n          status = 401;\n          apiError.code = 'UPSTREAM_UNAUTHORIZED';\n        } else if (axiosStatus === 408) {\n          status = 504;\n          apiError.code = 'UPSTREAM_TIMEOUT';\n        }\n      }\n\n      res.status(status).json(apiError);\n    }\n  };\n\n  /**\n   * 获取指定会话历史详情\n   * GET /api/chat/history/:chatId?agentId=xxx\n   */\n  getChatHistory = async (req: Request, res: Response): Promise<void> => {\n    try {\n      // 添加认证检查\n      let authUser: AuthUser;\n      try {\n        authUser = await requireAuthenticatedUser(req);\n      } catch (authError) {\n        const message = authError instanceof Error && authError.message === 'TOKEN_EXPIRED'\n          ? '登录已过期，请重新登录'\n          : '未授权访问';\n\n        const apiError: ApiError = {\n          code: authError instanceof Error ? authError.message : 'UNAUTHORIZED',\n          message,\n          timestamp: new Date().toISOString(),\n        };\n\n        res.status(401).json(apiError);\n        return;\n      }\n\n      const { chatId: pathChatId, sessionId } = req.params as { chatId?: string; sessionId?: string };\n      const chatId = pathChatId || sessionId;\n\n      if (!chatId) {\n        const apiError: ApiError = {\n          code: 'CHAT_ID_REQUIRED',\n          message: 'chatId 不能为空',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { error, value } = this.historyDetailSchema.validate(req.query);\n      if (error) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { agentId } = value as { agentId: string };\n\n      const agent = await this.agentService.getAgent(agentId);\n      if (!agent) {\n        const apiError: ApiError = {\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(404).json(apiError);\n        return;\n      }\n\n      if (agent.provider !== 'fastgpt') {\n        const apiError: ApiError = {\n          code: 'INVALID_PROVIDER',\n          message: `智能体 ${agentId} 不支持远程会话历史查询`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const detail: FastGPTChatHistoryDetail = await this.fastgptSessionService.getHistoryDetail(agentId, chatId);\n\n      // 添加权限检查 - 确保用户只能访问自己的会话记录\n      if (\n        detail.sessionInfo?.userId &&\n        detail.sessionInfo.userId !== authUser.id &&\n        authUser.role !== 'admin'\n      ) {\n        const apiError: ApiError = {\n          code: 'FORBIDDEN',\n          message: '无权访问该会话记录',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(403).json(apiError);\n        return;\n      }\n\n      ApiResponseHandler.sendSuccess(res, detail, {\n        message: '获取聊天历史详情成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (err: unknown) {\n      logger.error('获取聊天历史失败', { error: err });\n      const apiError: ApiError = {\n        code: 'GET_HISTORY_FAILED',\n        message: err instanceof Error ? err.message : '获取聊天历史失败',\n        timestamp: new Date().toISOString(),\n      };\n      let status = 500;\n      const errCode = ErrorExtractor.extractCode(err);\n      const axiosStatus = ErrorExtractor.extractStatus(err);\n      if (errCode === 'NOT_FOUND') {\n        status = 404;\n        apiError.code = 'AGENT_NOT_FOUND';\n      } else if (errCode === 'INVALID_PROVIDER' || errCode === 'INVALID_APP_ID') {\n        status = 400;\n        apiError.code = errCode;\n      } else if (axiosStatus === 404) {\n        status = 502;\n        apiError.code = 'UPSTREAM_NOT_FOUND';\n      } else if (axiosStatus === 401) {\n        status = 401;\n        apiError.code = 'UPSTREAM_UNAUTHORIZED';\n      } else if (axiosStatus === 408) {\n        status = 504;\n        apiError.code = 'UPSTREAM_TIMEOUT';\n      }\n      res.status(status).json(apiError);\n    }\n  };\n\n  /**\n   * 删除指定会话历史\n   * DELETE /api/chat/history/:chatId?agentId=xxx\n   */\n  deleteChatHistory = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const chatIdParam = req.params.chatId;\n      if (!chatIdParam) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: '缺少 chatId 参数',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const chatId = chatIdParam;\n      const { error, value } = this.historyDeleteSchema.validate(req.query);\n      if (error) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { agentId } = value as { agentId: string };\n      await this.fastgptSessionService.deleteHistory(agentId, chatId);\n\n      ApiResponseHandler.sendSuccess(res, null, {\n        message: '聊天历史删除成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (err: unknown) {\n      logger.error('删除聊天历史失败', { error: err });\n      const apiError: ApiError = {\n        code: 'DELETE_HISTORY_FAILED',\n        message: err instanceof Error ? err.message : '删除聊天历史失败',\n        timestamp: new Date().toISOString(),\n      };\n      let status = 500;\n      const errCode = ErrorExtractor.extractCode(err);\n      const axiosStatus = ErrorExtractor.extractStatus(err);\n      if (errCode === 'NOT_FOUND') {\n        status = 404;\n        apiError.code = 'AGENT_NOT_FOUND';\n      } else if (errCode === 'INVALID_PROVIDER' || errCode === 'INVALID_APP_ID') {\n        status = 400;\n        apiError.code = errCode;\n      } else if (axiosStatus === 404) {\n        status = 502;\n        apiError.code = 'UPSTREAM_NOT_FOUND';\n      } else if (axiosStatus === 401) {\n        status = 401;\n        apiError.code = 'UPSTREAM_UNAUTHORIZED';\n      } else if (axiosStatus === 408) {\n        status = 504;\n        apiError.code = 'UPSTREAM_TIMEOUT';\n      }\n      res.status(status).json(apiError);\n    }\n  };\n\n  private async ensureUploadDirectory(): Promise<void> {\n    try {\n      await fs.mkdir(this.uploadDir, { recursive: true });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'ensureUploadDirectory',\n        context: { uploadDir: this.uploadDir },\n      });\n      logger.warn('[ChatController] 创建上传目录失败', { error: typedError.message });\n    }\n  }\n\n  private sanitizeFilename(filename: string): string {\n    return filename.replace(/[^a-zA-Z0-9._-]/g, '_');\n  }\n\n  uploadAttachment = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const { error, value } = this.attachmentUploadSchema.validate(req.body);\n      if (error) {\n        res.status(400).json({\n          code: 'VALIDATION_ERROR',\n          message: error?.details?.[0]?.message || '附件参数校验失败',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const buffer = Buffer.from(value.data, 'base64');\n      if (!buffer || buffer.length === 0) {\n        res.status(400).json({\n          code: 'INVALID_ATTACHMENT',\n          message: '附件内容不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (buffer.length > value.size * 1.2) {\n        res.status(400).json({\n          code: 'INVALID_ATTACHMENT',\n          message: '附件大小与声明不符',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      await this.ensureUploadDirectory();\n\n      const fileId = generateId();\n      const safeName = this.sanitizeFilename(value.filename);\n      const finalName = `${fileId}-${safeName}`;\n      const filePath = path.join(this.uploadDir, finalName);\n\n      await fs.writeFile(filePath, buffer);\n\n      const metadata: ChatAttachmentMetadata = {\n        id: fileId,\n        name: value.filename,\n        mimeType: value.mimeType,\n        size: buffer.length,\n        url: `/uploads/${finalName}`,\n        source: value.source || 'upload',\n      };\n\n      ApiResponseHandler.sendSuccess(res, metadata, {\n        message: '附件上传成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'uploadAttachment',\n        url: req.originalUrl,\n        method: req.method,\n      });\n      logger.error('[ChatController] 上传附件失败', { error: typedError.message });\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 获取会话消息列表\n   * GET /api/chat/sessions/:sessionId/messages\n   */\n  getSessionMessages = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const { sessionId } = req.params as { sessionId?: string };\n\n      if (!sessionId) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: 'sessionId 不能为空',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { error, value } = this.historyMessagesSchema.validate(req.query);\n      if (error) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { limit, offset, role: roleRaw } = value as {\n        limit?: number;\n        offset?: number;\n        role?: unknown;\n      };\n\n      const queryOptions: ChatHistoryQueryOptions = {};\n      if (typeof limit === 'number') {\n        queryOptions.limit = limit;\n      }\n      if (typeof offset === 'number') {\n        queryOptions.offset = offset;\n      }\n\n      const normalizedRoles = this.parseHistoryRoleFilter(roleRaw);\n      if (normalizedRoles.length > 0) {\n        queryOptions.roles = normalizedRoles;\n      }\n\n      const history = await this.historyService.getHistory(sessionId, queryOptions);\n\n      if (!history.session) {\n        const apiError: ApiError = {\n          code: 'SESSION_NOT_FOUND',\n          message: `未找到会话: ${sessionId}`,\n          timestamp: new Date().toISOString(),\n        };\n        res.status(404).json(apiError);\n        return;\n      }\n\n      ApiResponseHandler.sendSuccess(res, history, {\n        message: '获取会话消息成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'getSessionMessages',\n        url: req.originalUrl,\n        method: req.method,\n      });\n      logger.error('获取会话消息失败', { error: typedError.message });\n\n      const apiError = typedError.toApiError();\n      let status = this.getErrorStatusCode(typedError);\n\n      const originalErrorObj = SafeAccess.getObject(typedError.context, 'originalError');\n      const originalError = originalErrorObj as Error | undefined;\n      if (originalError) {\n        const errCode = ErrorExtractor.extractCode(originalError);\n        const axiosStatus = ErrorExtractor.extractStatus(originalError);\n        if (errCode === 'NOT_FOUND') {\n          status = 404;\n          apiError.code = 'SESSION_NOT_FOUND';\n        } else if (errCode === 'INVALID_PROVIDER' || errCode === 'INVALID_APP_ID') {\n          status = 400;\n          apiError.code = errCode;\n        } else if (axiosStatus === 404) {\n          status = 502;\n          apiError.code = 'UPSTREAM_NOT_FOUND';\n        } else if (axiosStatus === 401) {\n          status = 401;\n          apiError.code = 'UPSTREAM_UNAUTHORIZED';\n        } else if (axiosStatus === 408) {\n          status = 504;\n          apiError.code = 'UPSTREAM_TIMEOUT';\n        }\n      }\n\n      res.status(status).json(apiError);\n    }\n  };\n\n  /**\n   * 清空指定智能体的历史\n   * DELETE /api/chat/history?agentId=xxx\n   */\n  clearChatHistories = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const { error, value } = this.historyDeleteSchema.validate(req.query);\n      if (error) {\n        const apiError: ApiError = {\n          code: 'VALIDATION_ERROR',\n          message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(400).json(apiError);\n        return;\n      }\n\n      const { agentId } = value as { agentId: string };\n      await this.fastgptSessionService.clearHistories(agentId);\n\n      ApiResponseHandler.sendSuccess(res, null, {\n        message: '聊天历史已清空',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (err: unknown) {\n      logger.error('清空聊天历史失败', { error: err });\n      const apiError: ApiError = {\n        code: 'CLEAR_HISTORY_FAILED',\n        message: err instanceof Error ? err.message : '清空聊天历史失败',\n        timestamp: new Date().toISOString(),\n      };\n      let status = 500;\n      const errCode = ErrorExtractor.extractCode(err);\n      const axiosStatus = ErrorExtractor.extractStatus(err);\n      if (errCode === 'NOT_FOUND') {\n        status = 404;\n        apiError.code = 'AGENT_NOT_FOUND';\n      } else if (errCode === 'INVALID_PROVIDER' || errCode === 'INVALID_APP_ID') {\n        status = 400;\n        apiError.code = errCode;\n      } else if (axiosStatus === 404) {\n        status = 502;\n        apiError.code = 'UPSTREAM_NOT_FOUND';\n      } else if (axiosStatus === 401) {\n        status = 401;\n        apiError.code = 'UPSTREAM_UNAUTHORIZED';\n      } else if (axiosStatus === 408) {\n        status = 504;\n        apiError.code = 'UPSTREAM_TIMEOUT';\n      }\n      res.status(status).json(apiError);\n    }\n  };\n\n  /**\n   * 重新生成指定消息\n   * POST /api/chat/history/:chatId/retry\n   */\n  retryChatMessage = async (req: Request, res: Response): Promise<void> => {\n    const chatIdParam = req.params.chatId;\n    if (!chatIdParam) {\n      const apiError: ApiError = {\n        code: 'VALIDATION_ERROR',\n        message: '缺少 chatId 参数',\n        timestamp: new Date().toISOString(),\n      };\n      res.status(400).json(apiError);\n      return;\n    }\n\n    const chatId = chatIdParam;\n    const { error, value } = this.historyRetrySchema.validate(req.body);\n    if (error) {\n      const apiError: ApiError = {\n        code: 'VALIDATION_ERROR',\n        message: ErrorExtractor.extractMessage(error) || '请求参数校验失败',\n        timestamp: new Date().toISOString(),\n      };\n      res.status(400).json(apiError);\n      return;\n    }\n\n    const { agentId, dataId, stream, detail } = value as { agentId: string; dataId: string; stream?: boolean; detail?: boolean };\n\n    try {\n      const historyDetail = await this.fastgptSessionService.getHistoryDetail(agentId, chatId);\n      const prepared = this.fastgptSessionService.prepareRetryPayload(historyDetail, dataId);\n\n      if (!prepared?.messages || prepared.messages.length === 0) {\n        const apiError: ApiError = {\n          code: 'RETRY_TARGET_NOT_FOUND',\n          message: '未找到可重新生成的用户消息',\n          timestamp: new Date().toISOString(),\n        };\n        res.status(404).json(apiError);\n        return;\n      }\n\n      const options: ChatOptions = {\n        chatId,\n        ...(typeof detail === 'boolean' ? { detail } : {}),\n        ...(prepared.responseChatItemId ? { responseChatItemId: prepared.responseChatItemId } : {}),\n      };\n\n      if (stream) {\n        await this.handleStreamRequest(res, agentId, prepared.messages, options, chatId);\n        return;\n      }\n\n      await this.handleNormalRequest(res, agentId, prepared.messages, options, chatId);\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ChatController',\n        operation: 'retryChatMessage',\n        url: req.originalUrl,\n        method: req.method,\n        context: { stream, sessionId: chatId, agentId },\n      });\n      logger.error('重新生成聊天消息失败', { error: typedError.message });\n\n      if (stream && res.headersSent) {\n        this.sendSSEEvent(res, 'error', {\n          code: typedError.code,\n          message: typedError.message,\n          timestamp: typedError.timestamp,\n        } as JsonValue);\n        res.end();\n        return;\n      }\n\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 解析请求中的角色过滤参数，兼容多种格式避免运行时异常\n   */\n  private parseHistoryRoleFilter(roleValue: unknown): Array<(typeof ChatController.supportedHistoryRoles)[number]> {\n    type HistoryRole = (typeof ChatController.supportedHistoryRoles)[number];\n    if (roleValue === undefined || roleValue === null) {\n      return [];\n    }\n\n    const allowed = new Set<HistoryRole>(ChatController.supportedHistoryRoles);\n    const result = new Set<HistoryRole>();\n\n    const collect = (raw: unknown) => {\n      if (typeof raw !== 'string') {\n        return;\n      }\n      const normalized = raw.trim().toLowerCase();\n      if (allowed.has(normalized as HistoryRole)) {\n        result.add(normalized as HistoryRole);\n      }\n    };\n\n    if (Array.isArray(roleValue)) {\n      roleValue.forEach(collect);\n    } else if (typeof roleValue === 'string') {\n      const trimmed = roleValue.trim();\n      if (trimmed.startsWith('[') && trimmed.endsWith(']')) {\n        try {\n          const parsed = JSON.parse(trimmed);\n          if (Array.isArray(parsed)) {\n            parsed.forEach(collect);\n          } else {\n            collect(parsed);\n          }\n        } catch (parseError) {\n          logger.warn('角色过滤参数解析失败，回退到逗号分隔解析', {\n            raw: roleValue,\n            error: parseError instanceof Error ? parseError.message : String(parseError),\n          });\n          trimmed.split(',').forEach(collect);\n        }\n      } else {\n        trimmed.split(',').forEach(collect);\n      }\n    } else if (typeof roleValue === 'object') {\n      Object.values(roleValue as Record<string, unknown>).forEach(collect);\n    }\n\n    return Array.from(result);\n  }\n\n  /**\n   * 获取错误状态码\n   */\n  private getErrorStatusCode(error: Error): number {\n    const message = error.message.toLowerCase();\n\n    if (message.includes('熔断器')) {\n      return 503;\n    }\n    if (message.includes('限流')) {\n      return 429;\n    }\n    if (message.includes('超时')) {\n      return 408;\n    }\n    if (message.includes('网络')) {\n      return 502;\n    }\n    if (message.includes('不可用')) {\n      return 503;\n    }\n\n    return 500;\n  }\n\n  /**\n   * 获取错误代码\n   */\n  private getErrorCode(error: Error): string {\n    const message = error.message.toLowerCase();\n\n    if (message.includes('熔断器')) {\n      return 'CIRCUIT_BREAKER_OPEN';\n    }\n    if (message.includes('限流')) {\n      return 'RATE_LIMIT_EXCEEDED';\n    }\n    if (message.includes('超时')) {\n      return 'REQUEST_TIMEOUT';\n    }\n    if (message.includes('网络')) {\n      return 'NETWORK_ERROR';\n    }\n    if (message.includes('不可用')) {\n      return 'SERVICE_UNAVAILABLE';\n    }\n\n    return 'INTERNAL_ERROR';\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/DifySessionController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1348,1351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1348,1351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3442,3445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3442,3445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":340,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9400,9403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9400,9403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport { difySessionService } from '@/services/DifySessionService';\nimport { AgentConfigService } from '@/services/AgentConfigService';\nimport logger from '@/utils/logger';\nimport { ApiResponseHandler } from '@/utils/apiResponse';\n\nconst agentService = new AgentConfigService();\n\n/**\n * Dify 会话管理控制器\n */\nexport class DifySessionController {\n  /**\n   * 获取会话列表\n   * GET /api/dify/conversations\n   */\n  static async getConversations(req: Request, res: Response): Promise<void> {\n    try {\n      const { agentId, user, limit, last_id } = req.query;\n\n      if (!agentId || typeof agentId !== 'string') {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '缺少 agentId 参数',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const agent = await agentService.getAgent(agentId);\n      if (!agent) {\n        res.status(404).json({\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (agent.provider !== 'dify') {\n        res.status(400).json({\n          code: 'INVALID_PROVIDER',\n          message: '仅 Dify 智能体支持此接口',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const params: any = {};\n      if (user) {\n        params.user = user as string;\n      }\n      if (limit) {\n        params.limit = parseInt(limit as string, 10);\n      }\n      if (last_id) {\n        params.last_id = last_id as string;\n      }\n\n      const result = await difySessionService.getConversations(agent, params);\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '获取 Dify 会话列表成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('获取 Dify 会话列表失败', {\n        component: 'DifySessionController',\n        error: error instanceof Error ? error.message : String(error),\n      });\n      res.status(500).json({\n        code: 'INTERNAL_ERROR',\n        message: error instanceof Error ? error.message : '获取会话列表失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  /**\n   * 获取会话消息\n   * GET /api/dify/messages\n   */\n  static async getMessages(req: Request, res: Response): Promise<void> {\n    try {\n      const { agentId, conversation_id, user, limit, first_id } = req.query;\n\n      if (!agentId || typeof agentId !== 'string') {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '缺少 agentId 参数',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!conversation_id || typeof conversation_id !== 'string') {\n        res.status(400).json({\n          code: 'INVALID_CONVERSATION_ID',\n          message: '缺少 conversation_id 参数',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const agent = await agentService.getAgent(agentId);\n      if (!agent) {\n        res.status(404).json({\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (agent.provider !== 'dify') {\n        res.status(400).json({\n          code: 'INVALID_PROVIDER',\n          message: '仅 Dify 智能体支持此接口',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const params: any = { conversation_id };\n      if (user) {\n        params.user = user as string;\n      }\n      if (limit) {\n        params.limit = parseInt(limit as string, 10);\n      }\n      if (first_id) {\n        params.first_id = first_id as string;\n      }\n\n      const result = await difySessionService.getConversationMessages(agent, params);\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '获取 Dify 会话消息成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('获取 Dify 会话消息失败', {\n        component: 'DifySessionController',\n        error: error instanceof Error ? error.message : String(error),\n      });\n      res.status(500).json({\n        code: 'INTERNAL_ERROR',\n        message: error instanceof Error ? error.message : '获取会话消息失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  /**\n   * 获取消息详情\n   * GET /api/dify/messages/:messageId\n   */\n  static async getMessageDetail(req: Request, res: Response): Promise<void> {\n    try {\n      const { messageId } = req.params;\n      const { agentId, user } = req.query;\n\n      if (!agentId || typeof agentId !== 'string') {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '缺少 agentId 参数',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const agent = await agentService.getAgent(agentId);\n      if (!agent) {\n        res.status(404).json({\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (agent.provider !== 'dify') {\n        res.status(400).json({\n          code: 'INVALID_PROVIDER',\n          message: '仅 Dify 智能体支持此接口',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!messageId) {\n        res.status(400).json({\n          success: false,\n          code: 'INVALID_MESSAGE_ID',\n          message: '消息ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const result = await difySessionService.getMessageDetail(\n        agent,\n        messageId,\n        user ? (user as string) : undefined,\n      );\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '获取 Dify 消息详情成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('获取 Dify 消息详情失败', {\n        component: 'DifySessionController',\n        error: error instanceof Error ? error.message : String(error),\n      });\n      res.status(500).json({\n        code: 'INTERNAL_ERROR',\n        message: error instanceof Error ? error.message : '获取消息详情失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  /**\n   * 删除会话\n   * DELETE /api/dify/conversations/:conversationId\n   */\n  static async deleteConversation(req: Request, res: Response): Promise<void> {\n    try {\n      const { conversationId } = req.params;\n      const { agentId, user } = req.query;\n\n      if (!agentId || typeof agentId !== 'string') {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '缺少 agentId 参数',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const agent = await agentService.getAgent(agentId);\n      if (!agent) {\n        res.status(404).json({\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (agent.provider !== 'dify') {\n        res.status(400).json({\n          code: 'INVALID_PROVIDER',\n          message: '仅 Dify 智能体支持此接口',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!conversationId) {\n        res.status(400).json({\n          success: false,\n          code: 'INVALID_CONVERSATION_ID',\n          message: '对话ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      await difySessionService.deleteConversation(\n        agent,\n        conversationId,\n        user ? (user as string) : undefined,\n      );\n\n      ApiResponseHandler.sendSuccess(res, null, {\n        message: '会话删除成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('删除 Dify 会话失败', {\n        component: 'DifySessionController',\n        error: error instanceof Error ? error.message : String(error),\n      });\n      res.status(500).json({\n        code: 'INTERNAL_ERROR',\n        message: error instanceof Error ? error.message : '删除会话失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  /**\n   * 提交消息反馈\n   * POST /api/dify/messages/:messageId/feedback\n   */\n  static async submitFeedback(req: Request, res: Response): Promise<void> {\n    try {\n      const { messageId } = req.params;\n      const { agentId, rating, user } = req.body;\n\n      if (!agentId || typeof agentId !== 'string') {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '缺少 agentId 参数',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!rating || !['like', 'dislike'].includes(rating)) {\n        res.status(400).json({\n          code: 'INVALID_RATING',\n          message: 'rating 必须为 like 或 dislike',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const agent = await agentService.getAgent(agentId);\n      if (!agent) {\n        res.status(404).json({\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (agent.provider !== 'dify') {\n        res.status(400).json({\n          code: 'INVALID_PROVIDER',\n          message: '仅 Dify 智能体支持此接口',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const params: any = {\n        message_id: messageId,\n        rating,\n      };\n      if (user) {\n        params.user = user;\n      }\n\n      const result = await difySessionService.submitFeedback(agent, params);\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '反馈提交成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('提交 Dify 消息反馈失败', {\n        component: 'DifySessionController',\n        error: error instanceof Error ? error.message : String(error),\n      });\n      res.status(500).json({\n        code: 'INTERNAL_ERROR',\n        message: error instanceof Error ? error.message : '提交反馈失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  /**\n   * 获取建议问题\n   * GET /api/dify/messages/:messageId/suggested\n   */\n  static async getSuggestedQuestions(req: Request, res: Response): Promise<void> {\n    try {\n      const { messageId } = req.params;\n      const { agentId, user } = req.query;\n\n      if (!agentId || typeof agentId !== 'string') {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '缺少 agentId 参数',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const agent = await agentService.getAgent(agentId);\n      if (!agent) {\n        res.status(404).json({\n          code: 'AGENT_NOT_FOUND',\n          message: `智能体不存在: ${agentId}`,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (agent.provider !== 'dify') {\n        res.status(400).json({\n          code: 'INVALID_PROVIDER',\n          message: '仅 Dify 智能体支持此接口',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!messageId) {\n        res.status(400).json({\n          success: false,\n          code: 'INVALID_MESSAGE_ID',\n          message: '消息ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const result = await difySessionService.getSuggestedQuestions(\n        agent,\n        messageId,\n        user ? (user as string) : undefined,\n      );\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '获取建议问题成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (error) {\n      logger.error('获取 Dify 建议问题失败', {\n        component: 'DifySessionController',\n        error: error instanceof Error ? error.message : String(error),\n      });\n      res.status(500).json({\n        code: 'INTERNAL_ERROR',\n        message: error instanceof Error ? error.message : '获取建议问题失败',\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/ProductPreviewController.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1934,1937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1934,1937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\nimport Joi from 'joi';\nimport { ProductPreviewService } from '@/services/ProductPreviewService';\nimport { ApiError, ProductPreviewRequest } from '@/types';\nimport logger from '@/utils/logger';\nimport { ApiResponseHandler } from '@/utils/apiResponse';\n\nexport class ProductPreviewController {\n  private service: ProductPreviewService;\n\n  constructor() {\n    this.service = new ProductPreviewService();\n  }\n\n  private generateSchema = Joi.object<ProductPreviewRequest>({\n    sceneImage: Joi.string().min(10).required().messages({\n      'any.required': '现场照片不能为空',\n      'string.empty': '现场照片不能为空',\n    }),\n    productImage: Joi.string().min(10).optional().allow('', null),\n    productQuery: Joi.string().min(1).required().messages({\n      'any.required': '产品查询不能为空',\n      'string.empty': '产品查询不能为空',\n    }),\n    personalization: Joi.string().allow('', null).optional(),\n    boundingBox: Joi.object({\n      x: Joi.number().min(0).max(1).required(),\n      y: Joi.number().min(0).max(1).required(),\n      width: Joi.number().min(0).max(1).required(),\n      height: Joi.number().min(0).max(1).required(),\n    }).required().messages({\n      'any.required': '请标记现场红框区域',\n    }),\n  });\n\n  generatePreview = async (req: Request, res: Response): Promise<void> => {\n    const { error, value } = this.generateSchema.validate(req.body, { abortEarly: false, allowUnknown: false });\n\n    if (error) {\n      const apiError: ApiError = {\n        code: 'VALIDATION_ERROR',\n        message: error.details.map((detail) => detail.message).join('；'),\n        timestamp: new Date().toISOString(),\n      };\n      res.status(400).json(apiError);\n      return;\n    }\n\n    try {\n      const result = await this.service.generatePreview(value);\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '生成现场预览成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (err: any) {\n      logger.error('调用豆包图片生成接口失败', { error: err });\n      const apiError: ApiError = {\n        code: 'DOUBAO_IMAGE_GENERATE_FAILED',\n        message: err?.response?.data?.message || err?.message || '生成现场预览失败',\n        timestamp: new Date().toISOString(),\n        details: process.env.NODE_ENV === 'development' ? err?.response?.data || err : undefined,\n      };\n      res.status(500).json(apiError);\n    }\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/controllers/SessionController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getErrorMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":116,"column":62,"nodeType":"Identifier","messageId":"unusedVar","endLine":116,"endColumn":80},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":175,"column":56,"nodeType":"Identifier","messageId":"unusedVar","endLine":175,"endColumn":74},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":247,"column":56,"nodeType":"Identifier","messageId":"unusedVar","endLine":247,"endColumn":74},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":327,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":327,"endColumn":75},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":374,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":374,"endColumn":71},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":425,"column":58,"nodeType":"Identifier","messageId":"unusedVar","endLine":425,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":490,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":490,"endColumn":73}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\nimport Joi from 'joi';\nimport { FastGPTSessionService } from '@/services/FastGPTSessionService';\nimport { AgentConfigService } from '@/services/AgentConfigService';\nimport logger from '@/utils/logger';\nimport {\n  SessionListParams,\n  BatchOperationOptions,\n  ExportOptions,\n  EventQueryParams,\n  ApiError,\n} from '@/types';\nimport { ApiResponseHandler } from '@/utils/apiResponse';\nimport { getErrorMessage } from '@/utils/helpers';\nimport { createErrorFromUnknown, AuthenticationError } from '@/types/errors';\nimport { JsonValue } from '@/types/dynamic';\n\nasync function ensureAdminAuth(req: Request) {\n  const auth = req.headers['authorization'];\n  const token = (auth || '').replace(/^Bearer\\s+/i, '').trim();\n  if (!token) {\n    throw new AuthenticationError({\n      message: '未提供认证令牌',\n      code: 'UNAUTHORIZED',\n    });\n  }\n\n  // 这里应该调用认证服务验证token\n  // const user = await authService.profile(token);\n  // if (!user || user.role !== 'admin') {\n  //   throw new AuthorizationError({\n  //     message: '需要管理员权限',\n  //     code: 'FORBIDDEN'\n  //   });\n  // }\n\n  // 暂时跳过认证，实际生产环境需要实现\n  return { userId: 'admin' };\n}\n\nfunction handleAdminAuthError(error: unknown, res: Response): boolean {\n  if (error instanceof Error && error.message === 'UNAUTHORIZED') {\n    res.status(403).json({\n      code: 'UNAUTHORIZED',\n      message: '需要管理员权限',\n      timestamp: new Date().toISOString(),\n    });\n    return true;\n  }\n  return false;\n}\n\n/**\n * 会话管理控制器\n */\nexport class SessionController {\n  private sessionService: FastGPTSessionService;\n  private agentService: AgentConfigService;\n\n  // 验证schemas\n  private sessionListSchema = Joi.object({\n    page: Joi.number().min(1).default(1),\n    pageSize: Joi.number().min(1).max(100).default(20),\n    startDate: Joi.date().iso().optional(),\n    endDate: Joi.date().iso().optional(),\n    tags: Joi.array().items(Joi.string()).optional(),\n    minMessageCount: Joi.number().min(0).optional(),\n    maxMessageCount: Joi.number().min(0).optional(),\n    sortBy: Joi.string().valid('createdAt', 'updatedAt', 'messageCount', 'title').default('updatedAt'),\n    sortOrder: Joi.string().valid('asc', 'desc').default('desc'),\n    searchKeyword: Joi.string().max(500).optional(),\n  });\n\n  private batchOperationSchema = Joi.object({\n    sessionIds: Joi.array().items(Joi.string()).min(1).required(),\n    operation: Joi.string().valid('delete', 'archive', 'addTags', 'removeTags').required(),\n    tags: Joi.array().items(Joi.string()).when('operation', {\n      is: Joi.string().valid('addTags', 'removeTags'),\n      then: Joi.required(),\n      otherwise: Joi.optional(),\n    }),\n  });\n\n  private exportOptionsSchema = Joi.object({\n    format: Joi.string().valid('json', 'csv', 'excel').required(),\n    includeMessages: Joi.boolean().default(false),\n    includeMetadata: Joi.boolean().default(false),\n    filters: this.sessionListSchema.optional(),\n    dateRange: Joi.object({\n      start: Joi.date().iso().required(),\n      end: Joi.date().iso().required(),\n    }).optional(),\n  });\n\n  private eventQuerySchema = Joi.object({\n    sessionIds: Joi.array().items(Joi.string()).optional(),\n    eventTypes: Joi.array().items(Joi.string()).optional(),\n    startDate: Joi.date().iso().optional(),\n    endDate: Joi.date().iso().optional(),\n    userId: Joi.string().optional(),\n    page: Joi.number().min(1).default(1),\n    pageSize: Joi.number().min(1).max(100).default(20),\n    sortBy: Joi.string().valid('timestamp').default('timestamp'),\n    sortOrder: Joi.string().valid('asc', 'desc').default('desc'),\n  });\n\n  constructor() {\n    this.agentService = new AgentConfigService();\n    this.sessionService = new FastGPTSessionService(this.agentService);\n  }\n\n  /**\n   * 获取增强版会话列表\n   * GET /api/sessions/:agentId/enhanced\n   */\n  listSessionsEnhanced = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    const { agentId } = req.params;\n    try {\n      const { error, value } = this.sessionListSchema.validate(req.query, { abortEarly: false });\n\n      if (error) {\n        res.status(400).json({\n          code: 'VALIDATION_ERROR',\n          message: error.details.map((d) => d.message).join('; '),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!agentId) {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const result = await this.sessionService.listHistoriesEnhanced(agentId, value as SessionListParams);\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '获取会话列表成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'SessionController',\n        operation: 'listSessionsEnhanced',\n        url: req.originalUrl,\n        method: req.method,\n        context: { agentId },\n      });\n      logger.error('获取增强版会话列表失败', { error: typedError.message });\n      const apiError: ApiError = {\n        code: 'LIST_SESSIONS_FAILED',\n        message: '获取会话列表失败',\n        timestamp: new Date().toISOString(),\n      };\n\n      if (process.env.NODE_ENV === 'development') {\n        apiError.details = {\n          originalError: typedError.message,\n          stack: typedError.stack,\n        } as JsonValue;\n      }\n\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 批量操作会话\n   * POST /api/sessions/:agentId/batch\n   */\n  batchOperation = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n      const { agentId } = req.params;\n      const { error, value } = this.batchOperationSchema.validate(req.body, { abortEarly: false });\n\n      if (error) {\n        res.status(400).json({\n          code: 'VALIDATION_ERROR',\n          message: error.details.map((d) => d.message).join('; '),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!agentId) {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const user = await ensureAdminAuth(req);\n      const userAgent = req.headers['user-agent'];\n      const ipAddress = req.ip || req.connection.remoteAddress;\n      const context = {\n        userId: user.userId,\n        ...(userAgent && { userAgent }),\n        ...(ipAddress && { ipAddress }),\n      };\n\n      // 为每个会话记录操作开始事件\n      for (const sessionId of value.sessionIds) {\n        await this.sessionService.recordEvent(\n          agentId,\n          sessionId,\n          value.operation,\n          { operation: value.operation, tags: value.tags } as JsonValue,\n          context,\n        );\n      }\n\n      const result = await this.sessionService.batchOperation(agentId, value as BatchOperationOptions);\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '批量操作完成',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      if (handleAdminAuthError(unknownError, res)) {\n        return;\n      }\n      const { agentId } = req.params;\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'SessionController',\n        operation: 'batchOperation',\n        url: req.originalUrl,\n        method: req.method,\n        context: { agentId, operation: req.body.operation },\n      });\n      logger.error('批量操作失败', { error: typedError.message });\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 导出会话数据\n   * POST /api/sessions/:agentId/export\n   */\n  exportSessions = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n      const { agentId } = req.params;\n      const { error, value } = this.exportOptionsSchema.validate(req.body, { abortEarly: false });\n\n      if (error) {\n        res.status(400).json({\n          code: 'VALIDATION_ERROR',\n          message: error.details.map((d) => d.message).join('; '),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!agentId) {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const user = await ensureAdminAuth(req);\n      const userAgent = req.headers['user-agent'];\n      const ipAddress = req.ip || req.connection.remoteAddress;\n      const context = {\n        userId: user.userId,\n        ...(userAgent && { userAgent }),\n        ...(ipAddress && { ipAddress }),\n      };\n\n      const result = await this.sessionService.exportSessions(agentId, value as ExportOptions);\n\n      // 设置响应头\n      const contentType = value.format === 'json' ? 'application/json' :\n        value.format === 'csv' ? 'text/csv' :\n          'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n\n      res.setHeader('Content-Type', contentType);\n      res.setHeader('Content-Disposition', `attachment; filename=\"${result.filename}\"`);\n      res.send(result.data);\n\n      // 记录导出事件\n      await this.sessionService.recordEvent(\n        agentId,\n        'export_operation',\n        'exported',\n        {\n          format: value.format,\n          sessionCount: 'unknown', // 从result中获取\n          includeMessages: value.includeMessages,\n          includeMetadata: value.includeMetadata,\n          filters: value.filters,\n        } as JsonValue,\n        context,\n      );\n    } catch (unknownError) {\n      if (handleAdminAuthError(unknownError, res)) {\n        return;\n      }\n      const { agentId } = req.params;\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'SessionController',\n        operation: 'exportSessions',\n        url: req.originalUrl,\n        method: req.method,\n        context: { agentId, format: req.body.format },\n      });\n      logger.error('导出会话失败', { error: typedError.message });\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 获取会话统计信息\n   * GET /api/sessions/:agentId/stats\n   */\n  getSessionStats = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const { agentId } = req.params;\n      const { startDate, endDate } = req.query;\n\n      if (!agentId) {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      let dateRange;\n      if (startDate && endDate) {\n        dateRange = {\n          start: startDate as string,\n          end: endDate as string,\n        };\n      }\n\n      const stats = await this.sessionService.getSessionStats(agentId, dateRange);\n\n      ApiResponseHandler.sendSuccess(res, stats, {\n        message: '获取会话统计成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      const { agentId } = req.params;\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'SessionController',\n        operation: 'getSessionStats',\n        url: req.originalUrl,\n        method: req.method,\n        context: { agentId, dateRange: req.query },\n      });\n      logger.error('获取会话统计失败', { error: typedError.message });\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 查询会话事件\n   * GET /api/sessions/:agentId/events\n   */\n  queryEvents = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const { agentId } = req.params;\n      const { error, value } = this.eventQuerySchema.validate(req.query, { abortEarly: false });\n\n      if (error) {\n        res.status(400).json({\n          code: 'VALIDATION_ERROR',\n          message: error.details.map((d) => d.message).join('; '),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      if (!agentId) {\n        res.status(400).json({\n          code: 'INVALID_AGENT_ID',\n          message: '智能体ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const result = await this.sessionService.queryEvents(agentId, {\n        ...value,\n        agentId,\n      } as EventQueryParams);\n\n      ApiResponseHandler.sendSuccess(res, result, {\n        message: '查询会话事件成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      const { agentId } = req.params;\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'SessionController',\n        operation: 'queryEvents',\n        url: req.originalUrl,\n        method: req.method,\n        context: { agentId, queryParams: req.query },\n      });\n      logger.error('查询会话事件失败', { error: typedError.message });\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 获取会话详情（原有功能的增强版）\n   * GET /api/sessions/:agentId/:sessionId\n   */\n  getSessionDetail = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const { agentId, sessionId } = req.params;\n\n      if (!agentId || !sessionId) {\n        res.status(400).json({\n          code: 'INVALID_PARAMS',\n          message: '智能体ID和会话ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const detail = await this.sessionService.getHistoryDetail(agentId, sessionId);\n\n      // 记录访问事件\n      const user = await ensureAdminAuth(req).catch(() => ({ userId: undefined }));\n      const eventData = {\n        action: 'view_detail',\n      } as JsonValue;\n      const requestContext = {} as Record<string, unknown>;\n\n      if (user.userId) {\n        requestContext.userId = user.userId;\n      }\n      if (req.headers['user-agent']) {\n        requestContext.userAgent = req.headers['user-agent'];\n      }\n      if (req.ip) {\n        requestContext.ipAddress = req.ip;\n      } else if (req.connection?.remoteAddress) {\n        requestContext.ipAddress = req.connection.remoteAddress;\n      }\n\n      await this.sessionService.recordEvent(\n        agentId,\n        sessionId,\n        'updated',\n        eventData,\n        requestContext,\n      );\n\n      ApiResponseHandler.sendSuccess(res, detail, {\n        message: '获取会话详情成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      const { agentId, sessionId } = req.params;\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'SessionController',\n        operation: 'getSessionDetail',\n        url: req.originalUrl,\n        method: req.method,\n        context: { agentId, sessionId },\n      });\n      logger.error('获取会话详情失败', { error: typedError.message });\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  };\n\n  /**\n   * 删除单个会话\n   * DELETE /api/sessions/:agentId/:sessionId\n   */\n  deleteSession = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      await ensureAdminAuth(req);\n      const { agentId, sessionId } = req.params;\n\n      if (!agentId || !sessionId) {\n        res.status(400).json({\n          code: 'INVALID_PARAMS',\n          message: '智能体ID和会话ID不能为空',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const user = await ensureAdminAuth(req);\n      const userAgent = req.headers['user-agent'];\n      const ipAddress = req.ip || req.connection.remoteAddress;\n      const context = {\n        userId: user.userId,\n        ...(userAgent && { userAgent }),\n        ...(ipAddress && { ipAddress }),\n      };\n\n      // 记录删除前的事件\n      await this.sessionService.recordEvent(\n        agentId,\n        sessionId,\n        'deleted',\n        { reason: 'manual_delete' } as JsonValue,\n        context,\n      );\n\n      await this.sessionService.deleteHistory(agentId, sessionId);\n\n      ApiResponseHandler.sendSuccess(res, null, {\n        message: '会话删除成功',\n        ...(req.requestId ? { requestId: req.requestId } : {}),\n      });\n    } catch (unknownError) {\n      if (handleAdminAuthError(unknownError, res)) {\n        return;\n      }\n      const { agentId, sessionId } = req.params;\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'SessionController',\n        operation: 'deleteSession',\n        url: req.originalUrl,\n        method: req.method,\n        context: { agentId, sessionId },\n      });\n      logger.error('删除会话失败', { error: typedError.message });\n      const apiError = typedError.toApiError();\n      res.status(500).json(apiError);\n    }\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/docs/swagger.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/src/docs/swagger.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable @typescript-eslint/no-unused-vars */\n/**\n * Swagger API Documentation Configuration\n * This file contains Swagger/OpenAPI configuration for API documentation.\n */\n\nimport swaggerJsdoc from 'swagger-jsdoc';\nimport swaggerUi from 'swagger-ui-express';\nimport { Application } from 'express';\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'LLM Chat API',\n      version: '1.0.0',\n      description: 'AI Agent Chat Platform API Documentation',\n    },\n    servers: [\n      {\n        url: process.env.API_URL || 'http://localhost:3001',\n        description: 'Development server',\n      },\n    ],\n  },\n  apis: ['./src/routes/*.ts'],\n};\n\nconst specs = swaggerJsdoc(options);\n\nexport const setupSwagger = (app: Application): void => {\n  app.use('/api-docs', swaggerUi.serve);\n  app.get('/api-docs', swaggerUi.setup(specs));\n};\n\nexport default specs;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/dotenv-loader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/PerformanceMonitor.ts","messages":[{"ruleId":"@typescript-eslint/no-this-alias","severity":2,"message":"Unexpected aliasing of 'this' to local variable.","line":57,"column":11,"nodeType":"Identifier","messageId":"thisAssignment","endLine":57,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1655,1658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1655,1658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2231,2234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2231,2234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\nimport logger from '@/utils/logger';\nimport { performance } from 'perf_hooks';\n\n/**\n * 性能监控数据接口\n */\ninterface PerformanceData {\n  requestId: string;\n  method: string;\n  url: string;\n  statusCode: number;\n  duration: number;\n  timestamp: string;\n  userAgent: string | undefined;\n  ip: string | undefined;\n  userId: string | undefined;\n  memoryUsage: {\n    rss: number;\n    heapTotal: number;\n    heapUsed: number;\n    external: number;\n  } | undefined;\n  errors: string[] | undefined;\n}\n\n/**\n * 性能统计摘要\n */\ninterface PerformanceSummary {\n  totalRequests: number;\n  averageResponseTime: number;\n  slowestRequest: number;\n  fastestRequest: number;\n  errorRate: number;\n  requestsPerMinute: number;\n  memoryUsage: {\n    averageRss: number;\n    averageHeapUsed: number;\n  };\n}\n\n/**\n * 性能监控中间件\n */\nexport class PerformanceMonitor {\n  private performanceData: PerformanceData[] = [];\n  private maxDataPoints = 10000; // 保留最近10000个请求的数据\n  private slowRequestThreshold = 5000; // 超过5秒的请求被视为慢请求\n  private summaryInterval = 60000; // 1分钟生成一次摘要\n  private lastSummaryTime = Date.now();\n\n  /**\n   * 性能监控中间件\n   */\n  public middleware() {\n    const monitor = this;\n    return (req: Request, res: Response, next: NextFunction): void => {\n      const startTime = performance.now();\n      const requestId = monitor.generateRequestId();\n\n      // 将requestId添加到请求对象中，以便后续使用\n      req.requestId = requestId;\n\n      // 记录初始内存使用情况\n      const initialMemory = process.memoryUsage();\n\n      // 捕获响应数据\n      const originalSend = res.send;\n      const errors: string[] = [];\n\n      res.send = function (this: Response, data: any) {\n        // 记录响应结束时间\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n\n        // 获取最终内存使用情况\n        const finalMemory = process.memoryUsage();\n\n        // 创建性能数据\n        const perfData: PerformanceData = {\n          requestId,\n          method: req.method,\n          url: req.originalUrl || req.url,\n          statusCode: res.statusCode,\n          duration,\n          timestamp: new Date().toISOString(),\n          userAgent: req.get('User-Agent'),\n          ip: req.ip || req.connection.remoteAddress,\n          userId: (req as any).user?.id, // 假设用户信息在req.user中\n          memoryUsage: {\n            rss: finalMemory.rss - initialMemory.rss,\n            heapTotal: finalMemory.heapTotal - initialMemory.heapTotal,\n            heapUsed: finalMemory.heapUsed - initialMemory.heapUsed,\n            external: finalMemory.external - initialMemory.external,\n          },\n          errors: errors.length > 0 ? errors : undefined,\n        };\n\n        // 存储性能数据\n        monitor.storePerformanceData(perfData);\n\n        // 记录慢请求\n        if (duration > monitor.slowRequestThreshold) {\n          logger.warn('Slow request detected', {\n            requestId,\n            method: req.method,\n            url: req.originalUrl,\n            duration,\n            statusCode: res.statusCode,\n          });\n        }\n\n        // 记录错误响应\n        if (res.statusCode >= 400) {\n          logger.warn('HTTP error response', {\n            requestId,\n            method: req.method,\n            url: req.originalUrl,\n            statusCode: res.statusCode,\n            duration,\n          });\n        }\n\n        // 添加性能头部\n        res.setHeader('X-Response-Time', `${duration.toFixed(2)}ms`);\n        res.setHeader('X-Request-ID', requestId);\n\n        // 记录性能指标到日志\n        logger.info('Request completed', {\n          requestId,\n          method: req.method,\n          url: req.originalUrl,\n          statusCode: res.statusCode,\n          duration,\n          memoryDelta: perfData.memoryUsage,\n        });\n\n        // 调用原始send方法\n        return originalSend.call(this, data);\n      }.bind(res);\n\n      // 监听错误事件\n      res.on('error', (error) => {\n        errors.push(error.message);\n        logger.error('Response error', { requestId, error: error.message });\n      });\n\n      next();\n    };\n  }\n\n  /**\n   * 生成唯一的请求ID\n   */\n  private generateRequestId(): string {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * 存储性能数据\n   */\n  private storePerformanceData(data: PerformanceData): void {\n    this.performanceData.push(data);\n\n    // 限制数据点数量，避免内存泄漏\n    if (this.performanceData.length > this.maxDataPoints) {\n      this.performanceData = this.performanceData.slice(-this.maxDataPoints);\n    }\n\n    // 定期生成摘要\n    const now = Date.now();\n    if (now - this.lastSummaryTime >= this.summaryInterval) {\n      this.generatePerformanceSummary();\n      this.lastSummaryTime = now;\n    }\n  }\n\n  /**\n   * 生成性能摘要\n   */\n  private generatePerformanceSummary(): void {\n    if (this.performanceData.length === 0) {\n      return;\n    }\n\n    const summary = this.calculatePerformanceSummary();\n\n    logger.info('Performance summary', {\n      totalRequests: summary.totalRequests,\n      averageResponseTime: summary.averageResponseTime,\n      slowestRequest: summary.slowestRequest,\n      fastestRequest: summary.fastestRequest,\n      errorRate: summary.errorRate,\n      requestsPerMinute: summary.requestsPerMinute,\n      memoryUsage: summary.memoryUsage,\n    });\n\n    // 如果错误率过高，记录警告\n    if (summary.errorRate > 0.1) { // 错误率超过10%\n      logger.warn('High error rate detected', { errorRate: summary.errorRate });\n    }\n\n    // 如果平均响应时间过长，记录警告\n    if (summary.averageResponseTime > 2000) { // 平均响应时间超过2秒\n      logger.warn('High average response time', {\n        averageResponseTime: summary.averageResponseTime,\n      });\n    }\n  }\n\n  /**\n   * 计算性能摘要\n   */\n  public calculatePerformanceSummary(): PerformanceSummary {\n    if (this.performanceData.length === 0) {\n      return {\n        totalRequests: 0,\n        averageResponseTime: 0,\n        slowestRequest: 0,\n        fastestRequest: 0,\n        errorRate: 0,\n        requestsPerMinute: 0,\n        memoryUsage: {\n          averageRss: 0,\n          averageHeapUsed: 0,\n        },\n      };\n    }\n\n    const recentData = this.performanceData.slice(-1000); // 最近1000个请求\n    const durations = recentData.map(d => d.duration);\n    const errorCount = recentData.filter(d => d.statusCode >= 400).length;\n\n    // 计算时间范围（分钟）\n    const timeRange = recentData[0] ? (Date.now() - new Date(recentData[0].timestamp).getTime()) / 60000 : 0;\n    const requestsPerMinute = timeRange > 0 ? recentData.length / timeRange : 0;\n\n    // 计算内存使用平均值\n    const memoryUsages = recentData\n      .filter(d => d.memoryUsage)\n      .map(d => d.memoryUsage!);\n\n    const averageMemoryUsage = memoryUsages.length > 0\n      ? memoryUsages.reduce((acc, mem) => ({\n        rss: acc.rss + mem.rss,\n        heapUsed: acc.heapUsed + mem.heapUsed,\n      }), { rss: 0, heapUsed: 0 })\n      : { rss: 0, heapUsed: 0 };\n\n    const count = memoryUsages.length || 1;\n\n    return {\n      totalRequests: recentData.length,\n      averageResponseTime: durations.reduce((a, b) => a + b, 0) / durations.length,\n      slowestRequest: Math.max(...durations),\n      fastestRequest: Math.min(...durations),\n      errorRate: errorCount / recentData.length,\n      requestsPerMinute,\n      memoryUsage: {\n        averageRss: averageMemoryUsage.rss / count,\n        averageHeapUsed: averageMemoryUsage.heapUsed / count,\n      },\n    };\n  }\n\n  /**\n   * 获取详细性能数据\n   */\n  public getPerformanceData(limit: number = 100): PerformanceData[] {\n    return this.performanceData.slice(-limit);\n  }\n\n  /**\n   * 获取慢请求列表\n   */\n  public getSlowRequests(threshold?: number): PerformanceData[] {\n    const slowThreshold = threshold || this.slowRequestThreshold;\n    return this.performanceData\n      .filter(d => d.duration > slowThreshold)\n      .sort((a, b) => b.duration - a.duration);\n  }\n\n  /**\n   * 获取错误请求列表\n   */\n  public getErrorRequests(): PerformanceData[] {\n    return this.performanceData\n      .filter(d => d.statusCode >= 400)\n      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n  }\n\n  /**\n   * 清除旧数据\n   */\n  public clearOldData(olderThanHours: number = 24): void {\n    const cutoffTime = Date.now() - (olderThanHours * 60 * 60 * 1000);\n    this.performanceData = this.performanceData.filter(\n      d => new Date(d.timestamp).getTime() > cutoffTime,\n    );\n  }\n}\n\n// 导出单例实例\nexport const performanceMonitor = new PerformanceMonitor();\n\n// 导出中间件函数\nexport const performanceMiddleware = performanceMonitor.middleware.bind(performanceMonitor);","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/ResponseOptimizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/SecurityMiddleware.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\'.","line":51,"column":7,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":51,"endColumn":8,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1206,1207],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1206,1206],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\'.","line":51,"column":10,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":51,"endColumn":11,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1209,1210],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1209,1209],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\'.","line":51,"column":12,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":51,"endColumn":13,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1211,1212],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1211,1211],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\#.","line":51,"column":20,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":51,"endColumn":21,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1219,1220],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1219,1219],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":68,"column":11,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":68,"endColumn":12,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1648,1649],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1648,1648],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":69,"column":7,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":69,"endColumn":8,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1662,1663],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1662,1662],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":69,"column":17,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":69,"endColumn":18,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1672,1673],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1672,1672],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":70,"column":7,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":70,"endColumn":8,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1686,1687],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1686,1686],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":71,"column":15,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":71,"endColumn":16,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1713,1714],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1713,1713],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":72,"column":7,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":72,"endColumn":8,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1728,1729],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1728,1728],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5410,5413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5410,5413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":258,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6001,6004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6001,6004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":258,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6007,6010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6007,6010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":273,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6393,6396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6393,6396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":407,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":407,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10055,10058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10055,10058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\nimport { securityLogger, LogContext } from '@/utils/StructuredLogger';\nimport rateLimit from 'express-rate-limit';\nimport helmet from 'helmet';\nimport cors from 'cors';\n\n/**\n * 安全威胁检测结果\n */\ninterface SecurityThreat {\n  type: 'sql_injection' | 'xss' | 'path_traversal' | 'command_injection' |\n        'rate_limit' | 'suspicious_user_agent' | 'blocked_ip' | 'invalid_token';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n  evidence: string | undefined;\n}\n\n/**\n * IP地址和用户代理信息\n */\ninterface ClientInfo {\n  ip: string;\n  userAgent?: string;\n  country?: string;\n  isSuspicious: boolean;\n  threatLevel: number;\n}\n\n/**\n * 安全中间件配置\n */\ninterface SecurityConfig {\n  rateLimitWindowMs: number;\n  rateLimitMax: number;\n  strictRateLimitWindowMs: number;\n  rateLimitMaxStrict: number;\n  blockedIPs: string[];\n  allowedOrigins: string[];\n  enableCSP: boolean;\n  enableHSTS: boolean;\n  maxRequestSize: string;\n  enableRequestValidation: boolean;\n}\n\n/**\n * 安全工具类\n */\nexport class SecurityUtils {\n  private static readonly SQL_INJECTION_PATTERNS = [\n    /(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\\b)/i,\n    /(\\'|\\'\\'|;|--|\\#|\\/\\*|\\*\\/)/,\n    /(\\bOR\\b.*=.*\\bOR\\b)/i,\n    /(\\bAND\\b.*=.*\\bAND\\b)/i,\n    /(1=1|1 = 1|true)/i,\n  ];\n\n  private static readonly XSS_PATTERNS = [\n    /<script[^>]*>.*?<\\/script>/gi,\n    /<iframe[^>]*>.*?<\\/iframe>/gi,\n    /<object[^>]*>.*?<\\/object>/gi,\n    /<embed[^>]*>.*?<\\/embed>/gi,\n    /javascript:/gi,\n    /on\\w+\\s*=/gi,\n    /<[^>]*on\\w+\\s*=.*?>/gi,\n  ];\n\n  private static readonly PATH_TRAVERSAL_PATTERNS = [\n    /\\.\\.[\\/\\\\]/,\n    /[\\/\\\\]\\.\\.[\\/\\\\]/,\n    /[\\/\\\\]\\.\\.$/,\n    /\\.%2e%2e[\\/\\\\]/i,\n    /[\\/\\\\]\\.%2e%2e/i,\n    /%2e%2e%2f/i,\n  ];\n\n  private static readonly COMMAND_INJECTION_PATTERNS = [\n    /[;&|`$()]/,\n    /\\$\\([^)]*\\)/,\n    /`[^`]*`/,\n    /\\b(curl|wget|nc|netcat|telnet|ssh|ftp)\\b/i,\n    /\\b(rm|mv|cp|cat|ls|ps|kill|chmod|chown)\\b/i,\n  ];\n\n  private static readonly SUSPICIOUS_USER_AGENTS = [\n    /sqlmap/i,\n    /nikto/i,\n    /nmap/i,\n    /masscan/i,\n    /dirb/i,\n    /gobuster/i,\n    /hydra/i,\n    /burp/i,\n    /zap/i,\n    /sqlninja/i,\n    /havij/i,\n    /pangolin/i,\n    /python-requests/i,\n    /curl/i,\n    /wget/i,\n  ];\n\n  /**\n   * 检测SQL注入攻击\n   */\n  static detectSQLInjection(input: string): SecurityThreat | null {\n    for (const pattern of this.SQL_INJECTION_PATTERNS) {\n      if (pattern.test(input)) {\n        return {\n          type: 'sql_injection',\n          severity: 'high',\n          description: 'Potential SQL injection detected',\n          evidence: input.match(pattern)?.[0],\n        };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 检测XSS攻击\n   */\n  static detectXSS(input: string): SecurityThreat | null {\n    for (const pattern of this.XSS_PATTERNS) {\n      if (pattern.test(input)) {\n        return {\n          type: 'xss',\n          severity: 'medium',\n          description: 'Potential XSS attack detected',\n          evidence: input.match(pattern)?.[0],\n        };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 检测路径遍历攻击\n   */\n  static detectPathTraversal(input: string): SecurityThreat | null {\n    for (const pattern of this.PATH_TRAVERSAL_PATTERNS) {\n      if (pattern.test(input)) {\n        return {\n          type: 'path_traversal',\n          severity: 'high',\n          description: 'Potential path traversal attack detected',\n          evidence: input.match(pattern)?.[0],\n        };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 检测命令注入攻击\n   */\n  static detectCommandInjection(input: string): SecurityThreat | null {\n    for (const pattern of this.COMMAND_INJECTION_PATTERNS) {\n      if (pattern.test(input)) {\n        return {\n          type: 'command_injection',\n          severity: 'critical',\n          description: 'Potential command injection attack detected',\n          evidence: input.match(pattern)?.[0],\n        };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 检测可疑用户代理\n   */\n  static detectSuspiciousUserAgent(userAgent: string): SecurityThreat | null {\n    for (const pattern of this.SUSPICIOUS_USER_AGENTS) {\n      if (pattern.test(userAgent)) {\n        return {\n          type: 'suspicious_user_agent',\n          severity: 'medium',\n          description: 'Suspicious user agent detected',\n          evidence: userAgent.match(pattern)?.[0],\n        };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 综合安全检测\n   */\n  static detectThreats(input: string, userAgent?: string): SecurityThreat[] {\n    const threats: SecurityThreat[] = [];\n\n    // 检测各种攻击模式\n    const sqlThreat = this.detectSQLInjection(input);\n    if (sqlThreat) {\n      threats.push(sqlThreat);\n    }\n\n    const xssThreat = this.detectXSS(input);\n    if (xssThreat) {\n      threats.push(xssThreat);\n    }\n\n    const pathThreat = this.detectPathTraversal(input);\n    if (pathThreat) {\n      threats.push(pathThreat);\n    }\n\n    const cmdThreat = this.detectCommandInjection(input);\n    if (cmdThreat) {\n      threats.push(cmdThreat);\n    }\n\n    // 检测可疑用户代理\n    if (userAgent) {\n      const uaThreat = this.detectSuspiciousUserAgent(userAgent);\n      if (uaThreat) {\n        threats.push(uaThreat);\n      }\n    }\n\n    return threats;\n  }\n\n  /**\n   * 获取客户端信息\n   */\n  static getClientInfo(req: Request): ClientInfo {\n    const ip = req.ip ||\n               req.connection.remoteAddress ||\n               req.socket.remoteAddress ||\n               (req.connection as any)?.socket?.remoteAddress ||\n               'unknown';\n\n    const userAgent = req.get('User-Agent') || 'unknown';\n\n    // 检测可疑性\n    const threats = this.detectThreats('', userAgent);\n    const isSuspicious = threats.length > 0;\n\n    // 计算威胁级别\n    const threatLevel = threats.reduce((level, threat) => {\n      const severityScores = { low: 1, medium: 2, high: 3, critical: 4 };\n      return level + severityScores[threat.severity];\n    }, 0);\n\n    return {\n      ip,\n      userAgent,\n      isSuspicious,\n      threatLevel,\n    };\n  }\n\n  /**\n   * 清理和验证输入\n   */\n  static sanitizeInput(input: any): any {\n    if (typeof input === 'string') {\n      // 移除潜在的危险字符\n      return input\n        .replace(/[<>'\"]/g, '')\n        .replace(/javascript:/gi, '')\n        .replace(/on\\w+\\s*=/gi, '')\n        .trim();\n    }\n\n    if (Array.isArray(input)) {\n      return input.map(item => this.sanitizeInput(item));\n    }\n\n    if (typeof input === 'object' && input !== null) {\n      const sanitized: any = {};\n      for (const [key, value] of Object.entries(input)) {\n        sanitized[key] = this.sanitizeInput(value);\n      }\n      return sanitized;\n    }\n\n    return input;\n  }\n\n  /**\n   * 验证JSON格式\n   */\n  static isValidJSON(str: string): boolean {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * 请求验证中间件\n */\nexport const requestValidationMiddleware = (req: Request, res: Response, next: NextFunction): void => {\n  try {\n    // 检查请求大小\n    const contentLength = req.get('Content-Length');\n    if (contentLength && parseInt(contentLength) > 10 * 1024 * 1024) { // 10MB\n      securityLogger.logSecurityEvent('Request size limit exceeded', {\n        ...(req.ip && { ip: req.ip }),\n        url: req.url,\n        contentLength: parseInt(contentLength),\n      });\n      res.status(413).json({\n        error: 'Request Entity Too Large',\n        message: 'Request size exceeds maximum allowed limit',\n      });\n      return;\n    }\n\n    // 检查Content-Type\n    const contentType = req.get('Content-Type');\n    if (req.method !== 'GET' && !contentType && req.body) {\n      securityLogger.logSecurityEvent('Missing Content-Type header', {\n        ...(req.ip && { ip: req.ip }),\n        method: req.method,\n        url: req.url,\n      });\n      res.status(400).json({\n        error: 'Bad Request',\n        message: 'Content-Type header is required for requests with body',\n      });\n      return;\n    }\n\n    // 验证JSON请求体\n    if (contentType?.includes('application/json') && req.body) {\n      if (typeof req.body === 'string' && !SecurityUtils.isValidJSON(req.body)) {\n        securityLogger.logSecurityEvent('Invalid JSON in request body', {\n          ...(req.ip && { ip: req.ip }),\n          method: req.method,\n          url: req.url,\n        });\n        res.status(400).json({\n          error: 'Bad Request',\n          message: 'Invalid JSON format in request body',\n        });\n        return;\n      }\n    }\n\n    next();\n  } catch (error) {\n    securityLogger.logSecurityEvent('Request validation error', {\n      ...(req.ip && { ip: req.ip }),\n      error: {\n        name: 'ValidationError',\n        message: error instanceof Error ? error.message : String(error),\n      },\n      url: req.url,\n    });\n    res.status(500).json({\n      error: 'Internal Server Error',\n      message: 'Request validation failed',\n    });\n    return;\n  }\n};\n\n/**\n * 安全威胁检测中间件\n */\nexport const securityDetectionMiddleware = (req: Request, res: Response, next: NextFunction): void => {\n  const clientInfo = SecurityUtils.getClientInfo(req);\n\n  // 检查IP是否被阻止\n  const config: SecurityConfig = {\n    blockedIPs: process.env.BLOCKED_IPS?.split(',') || [],\n    // ... 其他配置\n  } as SecurityConfig;\n\n  if (config.blockedIPs.includes(clientInfo.ip)) {\n    securityLogger.logSecurityEvent('Blocked IP attempted access', {\n      ip: clientInfo.ip,\n      ...(clientInfo.userAgent && { userAgent: clientInfo.userAgent }),\n      url: req.url,\n    });\n    res.status(403).json({\n      error: 'Forbidden',\n      message: 'Access denied',\n    });\n    return;\n  }\n\n  // 检测请求URL和参数中的威胁\n  const url = req.originalUrl || req.url || '';\n  const queryString = req.url?.split('?')[1] || '';\n  const fullInput = url + ' ' + queryString;\n\n  const threats = SecurityUtils.detectThreats(fullInput, clientInfo.userAgent);\n\n  if (threats.length > 0) {\n    // 记录安全威胁\n    const logContext: LogContext = {\n      security: {\n        ip: clientInfo.ip,\n        ...(clientInfo.userAgent && { userAgent: clientInfo.userAgent }),\n        suspicious: true,\n        threat: threats.map(t => t.type).join(', '),\n      },\n      business: {\n        detectedThreats: threats as any,\n      },\n    };\n\n    securityLogger.logSecurityEvent('Security threats detected', logContext);\n\n    // 根据威胁严重程度决定处理方式\n    const hasCriticalThreat = threats.some(t => t.severity === 'critical');\n    const hasHighThreat = threats.some(t => t.severity === 'high');\n\n    if (hasCriticalThreat || hasHighThreat) {\n      res.status(403).json({\n        error: 'Forbidden',\n        message: 'Request blocked due to security concerns',\n      });\n      return;\n    }\n  }\n\n  // 检测可疑用户代理\n  if (clientInfo.isSuspicious && clientInfo.threatLevel > 2) {\n    securityLogger.logSecurityEvent('Suspicious user agent detected', {\n      ip: clientInfo.ip,\n      ...(clientInfo.userAgent && { userAgent: clientInfo.userAgent }),\n      custom: {\n        threatLevel: clientInfo.threatLevel,\n      },\n      url: req.url,\n    });\n  }\n\n  next();\n};\n\n/**\n * 安全头部中间件\n */\nexport const securityHeadersMiddleware = helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n    },\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true,\n  },\n  noSniff: true,\n  frameguard: { action: 'deny' },\n  xssFilter: true,\n});\n\n/**\n * CORS配置中间件\n */\nexport const corsMiddleware = cors({\n  origin: (origin, callback) => {\n    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];\n\n    // 在开发环境中允许所有源\n    if (process.env.NODE_ENV === 'development') {\n      return callback(null, true);\n    }\n\n    if (!origin) {\n      return callback(null, false);\n    }\n\n    if (allowedOrigins.includes(origin)) {\n      return callback(null, true);\n    } else {\n      securityLogger.logSecurityEvent('CORS violation', {\n        origin,\n        allowedOrigins,\n      });\n      return callback(null, false);\n    }\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID'],\n});\n\n/**\n * 速率限制中间件\n */\nexport const rateLimitMiddleware = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15分钟\n  max: 100, // 每个IP最多100个请求\n  message: {\n    error: 'Too Many Requests',\n    message: 'Rate limit exceeded. Please try again later.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  handler: (req, res) => {\n    const userAgent = req.get('User-Agent');\n    securityLogger.logSecurityEvent('Rate limit exceeded', {\n      ...(req.ip && { ip: req.ip }),\n      url: req.url,\n      ...(userAgent && { userAgent }),\n    });\n    res.status(429).json({\n      error: 'Too Many Requests',\n      message: 'Rate limit exceeded. Please try again later.',\n    });\n  },\n});\n\n/**\n * 严格速率限制中间件（用于敏感操作）\n */\nexport const strictRateLimitMiddleware = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15分钟\n  max: 10, // 每个IP最多10个请求\n  message: {\n    error: 'Too Many Requests',\n    message: 'Rate limit exceeded for sensitive operations.',\n  },\n  handler: (req, res) => {\n    const userAgent = req.get('User-Agent');\n    securityLogger.logSecurityEvent('Strict rate limit exceeded', {\n      ...(req.ip && { ip: req.ip }),\n      url: req.url,\n      ...(userAgent && { userAgent }),\n    });\n    res.status(429).json({\n      error: 'Too Many Requests',\n      message: 'Rate limit exceeded for sensitive operations.',\n    });\n  },\n});\n\n/**\n * 综合安全中间件\n */\nexport const securityMiddleware = [\n  securityHeadersMiddleware,\n  corsMiddleware,\n  requestValidationMiddleware,\n  securityDetectionMiddleware,\n  rateLimitMiddleware,\n];\n\nexport default securityMiddleware;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/adminGuard.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AuthenticationError' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 管理员权限守卫中间件\n * 确保只有管理员用户才能访问特定路由\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { AuthenticationError } from '@/types/errors';\nimport logger from '@/utils/logger';\n\nexport interface AuthenticatedRequest extends Request {\n  user?: {\n    id: string;\n    username: string;\n    role: 'admin' | 'user';\n  };\n}\n\n/**\n * 管理员权限检查中间件\n */\nexport function adminGuard() {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const authReq = req as AuthenticatedRequest;\n\n    // 检查用户是否已认证\n    if (!authReq.user) {\n      logger.warn('未认证用户尝试访问管理员路由', {\n        component: 'adminGuard',\n        path: req.path,\n        ip: req.ip,\n      });\n\n      return res.status(401).json({\n        success: false,\n        code: 'AUTHENTICATION_REQUIRED',\n        message: '请先登录',\n      });\n    }\n\n    // 检查用户是否为管理员\n    if (authReq.user.role !== 'admin') {\n      logger.warn('非管理员用户尝试访问管理员路由', {\n        component: 'adminGuard',\n        user: authReq.user.username,\n        path: req.path,\n        ip: req.ip,\n      });\n\n      return res.status(403).json({\n        success: false,\n        code: 'ADMIN_REQUIRED',\n        message: '需要管理员权限',\n      });\n    }\n\n    // 权限检查通过\n    return next();\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/csrfProtection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/errorHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1287,1290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1287,1290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1342,1345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1342,1345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":167,"column":62,"nodeType":"Identifier","messageId":"unusedVar","endLine":167,"endColumn":80}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\nimport { ApiError } from '@/types';\nimport logger from '@/utils/logger';\nimport { createErrorFromUnknown, BaseError } from '@/types/errors';\nimport { JsonValue, SafeAccess } from '@/types/dynamic';\n\n/**\n * 统一的类型安全错误处理中间件\n *\n * 特性：\n * - 使用类型安全的错误处理基础设施\n * - 统一的错误响应格式\n * - 开发环境详细信息\n * - 结构化日志记录\n * - 错误分类和状态码映射\n */\nexport const errorHandler = (\n  unknownError: unknown,\n  req: Request,\n  res: Response,\n  next: NextFunction,\n): void => {\n  // 使用类型安全基础设施创建结构化错误\n  const typedError = createErrorFromUnknown(unknownError, {\n    component: 'ErrorHandler',\n    operation: 'globalErrorHandling',\n    url: req.originalUrl,\n    method: req.method,\n    context: {\n      headers: req.headers,\n      userAgent: req.get('User-Agent'),\n      ip: req.ip,\n    },\n  });\n\n  // 结构化日志记录（包含requestId）\n  logger.error('统一错误处理', {\n    errorId: typedError.id,\n    code: typedError.code,\n    message: typedError.message,\n    component: SafeAccess.getString(typedError.context, 'component'),\n    operation: SafeAccess.getString(typedError.context, 'operation'),\n    url: req.originalUrl,\n    method: req.method,\n    timestamp: typedError.timestamp,\n    stack: typedError.stack,\n    userAgent: req.get('User-Agent'),\n    ip: req.ip,\n    requestId: (req as any).requestId, // 添加requestId用于追踪\n    userId: (req as any).user?.id, // 添加userId（如果已认证）\n  });\n\n  // 如果响应已经发送，传递给默认错误处理器\n  if (res.headersSent) {\n    return next(typedError);\n  }\n\n  // 生成统一的API错误响应\n  const errorResponse = typedError.toApiError();\n\n  // 根据错误类型确定HTTP状态码\n  const statusCode = getErrorStatusCode(typedError);\n\n  // 开发环境下添加额外调试信息\n  if (process.env.NODE_ENV === 'development') {\n    errorResponse.details = {\n      originalError: typedError.message,\n      ...(typedError.stack && { stack: typedError.stack }),\n      ...(typedError.context && { context: typedError.context }),\n      errorId: typedError.id,\n      component: SafeAccess.getString(typedError.context, 'component'),\n      operation: SafeAccess.getString(typedError.context, 'operation'),\n    } as JsonValue;\n  }\n\n  // 生产环境下添加错误ID用于追踪\n  if (process.env.NODE_ENV === 'production') {\n    res.setHeader('X-Error-ID', typedError.id);\n  }\n\n  res.status(statusCode).json(errorResponse);\n};\n\n/**\n * 根据错误类型确定HTTP状态码\n */\nfunction getErrorStatusCode(error: BaseError): number {\n  const code = error.code;\n  const message = error.message.toLowerCase();\n\n  // 客户端错误 (4xx)\n  if (code === 'VALIDATION_ERROR' || code === 'INVALID_PARAMS') {\n    return 400;\n  }\n  if (code === 'UNAUTHORIZED' || code === 'AUTHENTICATION_FAILED') {\n    return 401;\n  }\n  if (code === 'FORBIDDEN' || code === 'PERMISSION_DENIED') {\n    return 403;\n  }\n  if (code === 'NOT_FOUND' || code === 'RESOURCE_NOT_FOUND') {\n    return 404;\n  }\n  if (code === 'METHOD_NOT_ALLOWED') {\n    return 405;\n  }\n  if (code === 'CONFLICT') {\n    return 409;\n  }\n  if (code === 'VALIDATION_FAILED') {\n    return 422;\n  }\n  if (code === 'RATE_LIMIT_EXCEEDED') {\n    return 429;\n  }\n\n  // 服务器错误 (5xx)\n  if (code === 'INTERNAL_SERVER_ERROR') {\n    return 500;\n  }\n  if (code === 'SERVICE_UNAVAILABLE') {\n    return 503;\n  }\n  if (code === 'CIRCUIT_BREAKER_OPEN') {\n    return 503;\n  }\n  if (code === 'TIMEOUT_ERROR' || code === 'REQUEST_TIMEOUT') {\n    return 408;\n  }\n\n  // 基于消息内容的判断\n  if (message.includes('timeout')) {\n    return 408;\n  }\n  if (message.includes('not found')) {\n    return 404;\n  }\n  if (message.includes('unauthorized')) {\n    return 401;\n  }\n  if (message.includes('forbidden')) {\n    return 403;\n  }\n  if (message.includes('validation')) {\n    return 400;\n  }\n\n  // 默认服务器错误\n  return 500;\n}\n\n/**\n * 异步错误包装器\n * 用于包装异步路由处理器，自动捕获和处理错误\n */\nexport const asyncErrorHandler = (\n  fn: (req: Request, res: Response, next: NextFunction) => Promise<void>,\n) => {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n/**\n * 404错误处理中间件\n */\nexport const notFoundHandler = (req: Request, res: Response, next: NextFunction): void => {\n  const error = createErrorFromUnknown(\n    new Error(`Route ${req.method} ${req.originalUrl} not found`),\n    {\n      component: 'ErrorHandler',\n      operation: 'notFoundHandling',\n      url: req.originalUrl,\n      method: req.method,\n    },\n  );\n\n  const errorResponse = error.toApiError();\n  res.status(404).json(errorResponse);\n};\n\n/**\n * 错误响应生成工具\n */\nexport const createErrorResponse = (\n  error: BaseError,\n  includeDetails: boolean = false,\n): ApiError => {\n  const response = error.toApiError();\n\n  if (includeDetails) {\n    response.details = {\n      errorId: error.id,\n      ...(error.context && { context: error.context }),\n      component: SafeAccess.getString(error.context, 'component'),\n      operation: SafeAccess.getString(error.context, 'operation'),\n    } as JsonValue;\n  }\n\n  return response;\n};\n\n/**\n * 安全的JSON响应工具\n */\nexport const safeJsonResponse = (\n  res: Response,\n  data: JsonValue,\n  statusCode: number = 200,\n): void => {\n  try {\n    res.status(statusCode).json(data);\n  } catch (error) {\n    const typedError = createErrorFromUnknown(error, {\n      component: 'ErrorHandler',\n      operation: 'safeJsonResponse',\n      context: { statusCode, dataType: typeof data },\n    });\n\n    const errorResponse = typedError.toApiError();\n    res.status(500).json(errorResponse);\n  }\n};\n\n/**\n * 错误事件记录工具\n */\nexport const logErrorEvent = (\n  error: BaseError,\n  additionalContext?: Record<string, unknown>,\n): void => {\n  const logData = {\n    errorId: error.id,\n    code: error.code,\n    message: error.message,\n    component: SafeAccess.getString(error.context, 'component'),\n    operation: SafeAccess.getString(error.context, 'operation'),\n    timestamp: error.timestamp,\n    severity: error.severity,\n    ...additionalContext,\n  };\n\n  if (error.severity === 'critical' || error.severity === 'high') {\n    logger.error('🚨 高优先级错误', logData);\n  } else if (error.severity === 'medium') {\n    logger.warn('⚠️ 中等优先级错误', logData);\n  } else {\n    logger.info('ℹ️ 低优先级错误', logData);\n  }\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/jwtAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/protectionMiddleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2414,2417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2414,2417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5972,5975],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5972,5975],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'types' is defined but never used. Allowed unused args must match /^_/u.","line":281,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":281,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'charsets' is defined but never used. Allowed unused args must match /^_/u.","line":282,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":282,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'encodings' is defined but never used. Allowed unused args must match /^_/u.","line":283,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":283,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'languages' is defined but never used. Allowed unused args must match /^_/u.","line":284,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":284,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'type' is defined but never used. Allowed unused args must match /^_/u.","line":285,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":285,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 保护中间件\n * 集成熔断器、限流器、重试机制和监控\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { getProtectionService, ProtectedRequestContext } from '@/services/ProtectionService';\nimport { createErrorFromUnknown } from '@/types/errors';\nimport logger from '@/utils/logger';\nimport { JsonValue } from '@/types/dynamic';\nimport { createDefaultFirewall } from '@/services/EthicsFirewallService';\n\n/**\n * 保护中间件\n */\nexport function protectionMiddleware() {\n  const protectionService = getProtectionService();\n\n  return (req: Request, res: Response, next: NextFunction): void => {\n    try {\n      // 添加保护服务到请求对象\n      (req as Request & { protectionService?: typeof protectionService }).protectionService = protectionService;\n\n      // 生成请求上下文\n      const userAgent = req.get('User-Agent');\n      const userId = (req as Request & { user?: { id: string } }).user?.id;\n      const context: ProtectedRequestContext = {\n        requestId: generateRequestId(),\n        agentId: req.body?.agentId || req.params?.agentId || req.query?.agentId as string || 'unknown',\n        ip: req.ip || req.connection.remoteAddress || 'unknown',\n        timestamp: new Date(),\n        ...(userId && { userId }),\n        ...(userAgent && { userAgent }),\n      };\n\n      // 添加上下文到请求对象\n      (req as Request & { protectionContext?: ProtectedRequestContext }).protectionContext = context;\n\n      // 添加请求ID到响应头\n      res.setHeader('X-Request-ID', context.requestId);\n\n      next();\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ProtectionMiddleware',\n        operation: 'protectionMiddleware',\n        url: req.originalUrl,\n        method: req.method,\n      });\n      logger.error('保护中间件错误', { error: typedError.message });\n      // 出错时继续处理请求，避免影响正常服务\n      next();\n    }\n  };\n}\n\n/**\n * 受保护的API中间件\n */\nexport function protectedApiMiddleware() {\n  const protectionService = getProtectionService();\n\n  const ethicsFirewall = createDefaultFirewall();\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    const context = req.protectionContext;\n\n    if (!context) {\n      res.status(500).json({\n        code: 'PROTECTION_CONTEXT_MISSING',\n        message: '保护上下文缺失',\n        timestamp: new Date().toISOString(),\n      });\n      return;\n    }\n\n    try {\n      // 伦理防火墙检查（API）\n      try {\n        const payload: { action: string; content: any; sensitive: boolean } & Partial<{ resourceId: string }> = {\n          action: `${req.method} ${req.path}`,\n          content: req.body,\n          sensitive: req.path.includes('/admin') || req.path.includes('/export') || req.method === 'DELETE',\n        };\n        const paramId = (req as Request & { params?: Record<string, unknown> }).params?.['id'];\n        if (typeof paramId === 'string' && paramId.length > 0) {\n          (payload as { resourceId: string }).resourceId = paramId;\n        }\n        const verdict = ethicsFirewall.evaluateCommand(context, payload);\n        ethicsFirewall.assertOrThrow(verdict);\n      } catch (ethicsError) {\n        const typedError = createErrorFromUnknown(ethicsError, {\n          component: 'ProtectionMiddleware',\n          operation: 'ethicsApiCheck',\n          url: req.originalUrl,\n          method: req.method,\n        });\n        logger.warn('伦理防火墙阻断(API)', { error: typedError.message });\n        res.status(403).json({\n          code: 'POLICY_VIOLATION',\n          message: typedError.message,\n          requestId: context.requestId,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      // 检查限流\n      const rateLimitResult = await checkRateLimit(req, protectionService);\n      if (!rateLimitResult.allowed) {\n        res.set({\n          'Retry-After': rateLimitResult.retryAfter?.toString() || '60',\n          'X-RateLimit-Limit': rateLimitResult.limit?.toString() || '100',\n          'X-RateLimit-Remaining': rateLimitResult.remaining?.toString() || '0',\n          'X-RateLimit-Reset': rateLimitResult.resetTime?.toISOString() || new Date().toISOString(),\n        });\n\n        res.status(429).json({\n          code: 'RATE_LIMIT_EXCEEDED',\n          message: '请求过于频繁，请稍后再试',\n          retryAfter: rateLimitResult.retryAfter || 60,\n          requestId: context.requestId,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      // 检查熔断器状态（如果有agentId）\n      if (context.agentId !== 'unknown') {\n        const circuitBreakerHealth = checkCircuitBreakerHealth(context.agentId, protectionService);\n        if (!circuitBreakerHealth.healthy) {\n          res.status(503).json({\n            code: 'CIRCUIT_BREAKER_OPEN',\n            message: `服务暂时不可用: ${circuitBreakerHealth.message}`,\n            requestId: context.requestId,\n            timestamp: new Date().toISOString(),\n          });\n          return;\n        }\n      }\n\n      next();\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ProtectionMiddleware',\n        operation: 'protectedApiMiddleware',\n        url: req.originalUrl,\n        method: req.method,\n        context: { context: context?.requestId },\n      });\n      logger.error('受保护API中间件错误', { error: typedError.message });\n      // 出错时继续处理请求\n      next();\n    }\n  };\n}\n\n/**\n * 受保护的聊天中间件\n */\nexport function protectedChatMiddleware() {\n  const protectionService = getProtectionService();\n\n  const ethicsFirewall = createDefaultFirewall();\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    const context = req.protectionContext;\n\n    if (!context) {\n      res.status(500).json({\n        code: 'PROTECTION_CONTEXT_MISSING',\n        message: '保护上下文缺失',\n        timestamp: new Date().toISOString(),\n      });\n      return;\n    }\n\n    // 更新agentId从请求体\n    if (req.body?.agentId) {\n      context.agentId = req.body.agentId;\n    }\n\n    try {\n      // 伦理防火墙检查（Chat）\n      try {\n        const payload: { action: string; content: any; sensitive: boolean } & Partial<{ resourceId: string }> = {\n          action: 'chat.handle',\n          content: req.body,\n          sensitive: false,\n        };\n        if (typeof context.agentId === 'string' && context.agentId !== 'unknown' && context.agentId.length > 0) {\n          (payload as { resourceId: string }).resourceId = context.agentId;\n        }\n        const verdict = ethicsFirewall.evaluateCommand(context, payload);\n        ethicsFirewall.assertOrThrow(verdict);\n      } catch (ethicsError) {\n        const typedError = createErrorFromUnknown(ethicsError, {\n          component: 'ProtectionMiddleware',\n          operation: 'ethicsChatCheck',\n          url: req.originalUrl,\n          method: req.method,\n          context: { requestId: context.requestId, agentId: context.agentId },\n        });\n        logger.warn('伦理防火墙阻断(Chat)', {\n          requestId: context.requestId,\n          agentId: context.agentId,\n          error: typedError.message,\n        });\n        res.status(403).json({\n          code: 'POLICY_VIOLATION',\n          message: typedError.message,\n          requestId: context.requestId,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      // 执行受保护的聊天请求\n      await protectionService.executeProtectedRequest(context, async () => {\n        // 这里不直接执行聊天逻辑，而是继续到下一个中间件\n        // 实际的聊天逻辑将在聊天控制器中使用保护服务\n        return new Promise<void>((resolve) => {\n          // 标记请求为受保护\n          (req as Request & { isProtected?: boolean }).isProtected = true;\n          next();\n          resolve();\n        });\n      });\n    } catch (unknownError) {\n      const typedError = createErrorFromUnknown(unknownError, {\n        component: 'ProtectionMiddleware',\n        operation: 'protectedChatMiddleware',\n        url: req.originalUrl,\n        method: req.method,\n        context: { requestId: context.requestId, agentId: context.agentId },\n      });\n      logger.error('受保护聊天中间件错误', {\n        requestId: context.requestId,\n        agentId: context.agentId,\n        error: typedError.message,\n      });\n\n      // 如果是降级响应，返回成功状态\n      const fallbackError = typedError as { fallbackUsed?: boolean; data?: JsonValue };\n      if (fallbackError.fallbackUsed) {\n        res.json(fallbackError.data);\n        return;\n      }\n\n      // 返回错误响应\n      const statusCode = getErrorStatusCode(typedError);\n      res.status(statusCode).json({\n        code: getErrorCode(typedError),\n        message: typedError.message,\n        requestId: context.requestId,\n        timestamp: new Date().toISOString(),\n      });\n    }\n  };\n}\n\n/**\n * 检查限流\n */\nasync function checkRateLimit(req: Request, protectionService: { multiDimensionRateLimiter: { isAllowed: (req: Request) => { allowed: boolean; results?: Array<{ allowed?: boolean; remaining?: number; retryAfter?: number; resetTime?: Date }> } } }): Promise<{\n  allowed: boolean;\n  reason?: string;\n  retryAfter?: number;\n  limit?: number;\n  remaining?: number;\n  resetTime?: Date;\n}> {\n  try {\n    // 模拟请求对象用于限流检查\n    const mockReq = {\n      ip: req.ip || req.connection.remoteAddress || 'unknown',\n      method: req.method,\n      path: req.path,\n      user: (req as Request & { user?: unknown }).user,\n      route: req.route,\n      get: (header: string) => req.headers[header.toLowerCase()],\n      header: (header: string) => req.headers[header.toLowerCase()],\n      accepts: (types: string[]) => false, // 简化实现\n      acceptsCharsets: (charsets: string[]) => false, // 简化实现\n      acceptsEncodings: (encodings: string[]) => false, // 简化实现\n      acceptsLanguages: (languages: string[]) => false, // 简化实现\n      is: (type: string) => false, // 简化实现\n      param: (name: string) => (req as Request & { params?: Record<string, unknown> }).params?.[name],\n      query: (name: string) => (req as Request & { query?: Record<string, unknown> }).query?.[name],\n      cookies: (req as Request & { cookies?: Record<string, unknown> }).cookies || {},\n      signedCookies: (req as Request & { signedCookies?: Record<string, unknown> }).signedCookies || {},\n      body: (req as Request & { body?: unknown }).body || {},\n      files: (req as Request & { files?: unknown }).files || {},\n      protocol: req.protocol || 'http',\n      secure: req.secure || false,\n      xhr: req.xhr || false,\n      subdomains: [],\n      originalUrl: req.originalUrl || req.url,\n      baseUrl: req.baseUrl || '',\n      url: req.url || '',\n      app: (req as Request & { app?: unknown }).app,\n      // 添加必要的Express Request属性\n      headers: req.headers,\n      connection: req.connection,\n      socket: req.socket,\n      complete: true,\n      httpVersion: '1.1',\n      httpVersionMajor: 1,\n      httpVersionMinor: 1,\n      trailers: {},\n      rawTrailers: [],\n      upgrade: false,\n      // 方法\n      res: undefined as unknown,\n      next: undefined as unknown,\n    } as unknown as Request;\n\n    const checkResult = protectionService.multiDimensionRateLimiter.isAllowed(mockReq);\n\n    if (!checkResult.allowed) {\n      const failedResult = checkResult.results?.find((r: { allowed?: boolean; remaining?: number; retryAfter?: number; resetTime?: Date }) => !r.allowed);\n      const result: {\n        allowed: boolean;\n        reason?: string;\n        retryAfter?: number;\n        limit?: number;\n        remaining?: number;\n        resetTime?: Date;\n      } = {\n        allowed: false,\n        reason: `维度限制触发: ${failedResult?.remaining || 0}`,\n        ...(failedResult?.retryAfter !== undefined && { retryAfter: failedResult.retryAfter }),\n        ...(failedResult?.remaining !== undefined && { remaining: failedResult.remaining }),\n        ...(failedResult?.resetTime !== undefined && { resetTime: failedResult.resetTime }),\n      };\n\n      if (failedResult?.remaining !== undefined) {\n        result.limit = failedResult.remaining + (failedResult?.allowed ? 0 : 1);\n      }\n\n      return result;\n    }\n\n    return { allowed: true };\n  } catch (unknownError) {\n    const typedError = createErrorFromUnknown(unknownError, {\n      component: 'ProtectionMiddleware',\n      operation: 'checkRateLimit',\n      context: { ip: req.ip, method: req.method, path: req.path },\n    });\n    logger.error('限流检查失败', { error: typedError.message });\n    // 出错时允许请求通过\n    return { allowed: true };\n  }\n}\n\n/**\n * 检查熔断器健康状态\n */\nfunction checkCircuitBreakerHealth(agentId: string, protectionService: { circuitBreakerManager: { getHealthStatus: () => Array<{ name: string; healthy: boolean; message?: string }> } }): {\n  healthy: boolean;\n  message: string;\n} {\n  try {\n    const circuitBreakerManager = protectionService.circuitBreakerManager;\n    const healthStatus = circuitBreakerManager.getHealthStatus();\n\n    const agentCircuitBreaker = healthStatus.find((cb: { name: string; healthy: boolean; message?: string }) => cb.name === `agent_${agentId}`);\n\n    if (agentCircuitBreaker && !agentCircuitBreaker.healthy) {\n      return {\n        healthy: false,\n        message: agentCircuitBreaker.message || '熔断器状态未知',\n      };\n    }\n\n    return { healthy: true, message: '服务正常' };\n  } catch (unknownError) {\n    const typedError = createErrorFromUnknown(unknownError, {\n      component: 'ProtectionMiddleware',\n      operation: 'checkCircuitBreakerHealth',\n      context: { agentId },\n    });\n    logger.error('熔断器健康检查失败', { error: typedError.message });\n    // 出错时假设健康\n    return { healthy: true, message: '健康检查异常' };\n  }\n}\n\n/**\n * 获取错误状态码\n */\nfunction getErrorStatusCode(error: Error): number {\n  const message = error.message.toLowerCase();\n\n  if (message.includes('熔断器')) {\n    return 503;\n  }\n  if (message.includes('限流')) {\n    return 429;\n  }\n  if (message.includes('超时')) {\n    return 408;\n  }\n  if (message.includes('网络')) {\n    return 502;\n  }\n  if (message.includes('不可用')) {\n    return 503;\n  }\n\n  return 500;\n}\n\n/**\n * 获取错误代码\n */\nfunction getErrorCode(error: Error): string {\n  const message = error.message.toLowerCase();\n\n  if (message.includes('熔断器')) {\n    return 'CIRCUIT_BREAKER_OPEN';\n  }\n  if (message.includes('限流')) {\n    return 'RATE_LIMIT_EXCEEDED';\n  }\n  if (message.includes('超时')) {\n    return 'REQUEST_TIMEOUT';\n  }\n  if (message.includes('网络')) {\n    return 'NETWORK_ERROR';\n  }\n  if (message.includes('不可用')) {\n    return 'SERVICE_UNAVAILABLE';\n  }\n\n  return 'INTERNAL_ERROR';\n}\n\n/**\n * 生成请求ID\n */\nfunction generateRequestId(): string {\n  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * 监控指标中间件\n */\nexport function monitoringMetricsMiddleware() {\n  const protectionService = getProtectionService();\n\n  return (req: Request, res: Response, next: NextFunction): void => {\n    const startTime = Date.now();\n\n    // 监听响应完成事件\n    res.on('finish', () => {\n      const responseTime = Date.now() - startTime;\n      const success = res.statusCode < 400;\n\n      // 记录监控指标\n      protectionService.getMonitoringService().recordRequest(\n        responseTime,\n        success,\n        success ? undefined : `HTTP_${res.statusCode}`,\n      );\n    });\n\n    next();\n  };\n}\n\n/**\n * 健康检查增强中间件\n */\nexport function enhancedHealthCheckMiddleware() {\n  const protectionService = getProtectionService();\n\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (req.path === '/health') {\n      const systemHealth = protectionService.getSystemHealth();\n      const performanceMetrics = protectionService.getPerformanceMetrics();\n      const activeAlerts = protectionService.getActiveAlerts();\n\n      const healthData = {\n        status: 'ok',\n        timestamp: new Date().toISOString(),\n        uptime: process.uptime(),\n        memory: process.memoryUsage(),\n        protection: {\n          systemHealth,\n          performanceMetrics,\n          activeAlerts: activeAlerts.length,\n          circuitBreakers: protectionService.getAllCircuitBreakers().length,\n          rateLimiters: protectionService.getAllRateLimitMetrics().length,\n        },\n      };\n\n      // 根据系统健康状态设置HTTP状态码\n      const statusCode = systemHealth.status === 'healthy' ? 200 :\n        systemHealth.status === 'warning' ? 200 : 503;\n\n      res.status(statusCode).json(healthData);\n      return;\n    }\n\n    next();\n  };\n}\n\n// 默认导出\nexport default protectionMiddleware;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/rateLimiter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[516,519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[516,519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\nimport { RateLimiterMemory } from 'rate-limiter-flexible';\n\n// 创建速率限制器\nconst rateLimiter = new RateLimiterMemory({\n  points: 100, // 请求数量\n  duration: 60, // 时间窗口（秒）\n  blockDuration: 60, // 阻止时间（秒）\n});\n\n/**\n * 速率限制中间件\n */\nexport const rateLimiterMiddleware = async (\n  req: Request,\n  res: Response,\n  next: NextFunction,\n): Promise<void> => {\n  try {\n    const key = req.ip || 'anonymous';\n    await rateLimiter.consume(key);\n    next();\n  } catch (rejRes: any) {\n    const remainingPoints = rejRes?.remainingPoints || 0;\n    const msBeforeNext = rejRes?.msBeforeNext || 60000;\n\n    res.set({\n      'Retry-After': Math.round(msBeforeNext / 1000),\n      'X-RateLimit-Limit': '100',\n      'X-RateLimit-Remaining': remainingPoints.toString(),\n      'X-RateLimit-Reset': new Date(Date.now() + msBeforeNext).toISOString(),\n    });\n\n    res.status(429).json({\n      code: 'RATE_LIMIT_EXCEEDED',\n      message: '请求过于频繁，请稍后再试',\n      retryAfter: Math.round(msBeforeNext / 1000),\n      timestamp: new Date().toISOString(),\n    });\n  }\n};\n\nexport { rateLimiterMiddleware as rateLimiter };","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/rateLimiterV2.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3122,3125],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3122,3125],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3668,3671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3668,3671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":170,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4149,4152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4149,4152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":261,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6216,6219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6216,6219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":289,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6861,6864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6861,6864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":337,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7803,7806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7803,7806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 增强版速率限制中间件 V2\n *\n * 特性:\n * - Redis集中化存储（支持多实例部署）\n * - 内存降级模式（Redis不可用时）\n * - 灵活的限流策略（按IP/用户/端点）\n * - 详细的限流指标\n * - 白名单支持\n *\n * 向后兼容:\n * - 保留原rateLimiter接口\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { RateLimiterRedis, RateLimiterMemory, RateLimiterRes } from 'rate-limiter-flexible';\nimport { Redis } from 'ioredis';\nimport { EnvManager } from '@/config/EnvManager';\nimport logger from '@/utils/logger';\n\n// ==================== 类型定义 ====================\n\nexport interface RateLimitConfig {\n  points: number;           // 请求数量\n  duration: number;         // 时间窗口（秒）\n  blockDuration?: number;   // 阻止时间（秒）\n  keyPrefix?: string;       // Redis键前缀\n  whitelist?: Array<string>; // IP白名单\n}\n\nexport interface RateLimitOptions {\n  config?: RateLimitConfig;\n  keyGenerator?: (req: Request) => string;\n  skipSuccessfulRequests?: boolean;\n  skipFailedRequests?: boolean;\n}\n\n// ==================== 预设配置 ====================\n\nexport const RATE_LIMIT_PRESETS = {\n  // 通用API限流\n  api: {\n    points: 100,\n    duration: 60,\n    blockDuration: 60,\n    keyPrefix: 'rl:api:',\n  },\n\n  // 聊天接口限流\n  chat: {\n    points: 30,\n    duration: 60,\n    blockDuration: 120,\n    keyPrefix: 'rl:chat:',\n  },\n\n  // 管理接口限流\n  admin: {\n    points: 200,\n    duration: 60,\n    blockDuration: 30,\n    keyPrefix: 'rl:admin:',\n  },\n\n  // 登录接口限流（防止暴力破解）\n  login: {\n    points: 5,\n    duration: 60,\n    blockDuration: 900, // 15分钟\n    keyPrefix: 'rl:login:',\n  },\n\n  // 注册接口限流\n  register: {\n    points: 3,\n    duration: 3600, // 1小时\n    blockDuration: 3600,\n    keyPrefix: 'rl:register:',\n  },\n} as const;\n\n// ==================== Rate Limiter管理器 ====================\n\nclass RateLimiterManager {\n  private redis: Redis | null = null;\n  private limiters = new Map<string, RateLimiterRedis | RateLimiterMemory>();\n  private isRedisAvailable = false;\n\n  constructor() {\n    this.initRedis();\n  }\n\n  /**\n   * 初始化Redis连接\n   */\n  private initRedis(): void {\n    const envManager = EnvManager.getInstance();\n    const redisHost = envManager.get('REDIS_HOST', '');\n\n    if (!redisHost) {\n      logger.info('RateLimiter: Redis未配置，使用内存模式');\n      return;\n    }\n\n    try {\n      this.redis = new Redis({\n        host: envManager.get('REDIS_HOST'),\n        port: envManager.getInt('REDIS_PORT', 6379),\n        password: envManager.get('REDIS_PASSWORD', ''),\n        db: envManager.getInt('REDIS_DB', 1), // 使用独立DB\n        retryStrategy: (times) => {\n          if (times > 3) {\n            logger.error('RateLimiter: Redis连接失败，切换到内存模式');\n            this.isRedisAvailable = false;\n            return null;\n          }\n          return Math.min(times * 200, 2000);\n        },\n      });\n\n      this.redis.on('connect', () => {\n        this.isRedisAvailable = true;\n        logger.info('✅ RateLimiter: Redis连接成功');\n      });\n\n      this.redis.on('error', (err) => {\n        this.isRedisAvailable = false;\n        logger.error('RateLimiter: Redis错误', { error: err.message });\n      });\n\n      this.redis.on('close', () => {\n        this.isRedisAvailable = false;\n        logger.warn('RateLimiter: Redis连接关闭，降级到内存模式');\n      });\n\n    } catch (error: any) {\n      logger.error('RateLimiter: Redis初始化失败', { error: error.message });\n      this.redis = null;\n      this.isRedisAvailable = false;\n    }\n  }\n\n  /**\n   * 获取或创建Limiter实例\n   */\n  getLimiter(config: RateLimitConfig): RateLimiterRedis | RateLimiterMemory {\n    const key = `${config.keyPrefix}${config.points}:${config.duration}`;\n\n    if (this.limiters.has(key)) {\n      return this.limiters.get(key)!;\n    }\n\n    let limiter: RateLimiterRedis | RateLimiterMemory;\n\n    if (this.isRedisAvailable && this.redis) {\n      const redisOptions: any = {\n        storeClient: this.redis,\n        points: config.points,\n        duration: config.duration,\n      };\n      if (config.blockDuration !== undefined) {\n        redisOptions.blockDuration = config.blockDuration;\n      }\n      if (config.keyPrefix !== undefined) {\n        redisOptions.keyPrefix = config.keyPrefix;\n      }\n      limiter = new RateLimiterRedis(redisOptions);\n      logger.debug('创建Redis RateLimiter', { config });\n    } else {\n      const memoryOptions: any = {\n        points: config.points,\n        duration: config.duration,\n      };\n      if (config.blockDuration !== undefined) {\n        memoryOptions.blockDuration = config.blockDuration;\n      }\n      limiter = new RateLimiterMemory(memoryOptions);\n      logger.debug('创建Memory RateLimiter (降级模式)', { config });\n    }\n\n    this.limiters.set(key, limiter);\n    return limiter;\n  }\n\n  /**\n   * 清理资源\n   */\n  async close(): Promise<void> {\n    if (this.redis) {\n      await this.redis.quit();\n      logger.info('RateLimiter: Redis连接已关闭');\n    }\n    this.limiters.clear();\n  }\n\n  /**\n   * 获取状态\n   */\n  getStatus(): { mode: string; limiters: number } {\n    return {\n      mode: this.isRedisAvailable ? 'redis' : 'memory',\n      limiters: this.limiters.size,\n    };\n  }\n}\n\n// 单例\nconst rateLimiterManager = new RateLimiterManager();\n\n// ==================== 中间件工厂函数 ====================\n\n/**\n * 创建速率限制中间件\n */\nexport function createRateLimiter(options: RateLimitOptions = {}) {\n  const {\n    config = RATE_LIMIT_PRESETS.api,\n    keyGenerator = defaultKeyGenerator,\n    skipSuccessfulRequests = false,\n    skipFailedRequests = false,\n  } = options;\n\n  const limiter = rateLimiterManager.getLimiter(config);\n\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      // 检查白名单\n      if ('whitelist' in config && config.whitelist && isWhitelisted(req, config.whitelist)) {\n        return next();\n      }\n\n      // 生成限流键\n      const key = keyGenerator(req);\n\n      // 消费点数\n      const rateLimiterRes = await limiter.consume(key);\n\n      // 设置响应头\n      setRateLimitHeaders(res, rateLimiterRes, config);\n\n      // 跳过成功请求的计数（可选）\n      if (skipSuccessfulRequests) {\n        res.on('finish', () => {\n          if (res.statusCode < 400) {\n            limiter.reward(key, 1);\n          }\n        });\n      }\n\n      // 跳过失败请求的计数（可选）\n      if (skipFailedRequests) {\n        res.on('finish', () => {\n          if (res.statusCode >= 400) {\n            limiter.reward(key, 1);\n          }\n        });\n      }\n\n      next();\n\n    } catch (rejRes: any) {\n      // 限流触发\n      handleRateLimitExceeded(req, res, rejRes, config);\n    }\n  };\n}\n\n// ==================== 辅助函数 ====================\n\n/**\n * 默认键生成器（使用IP地址）\n */\nfunction defaultKeyGenerator(req: Request): string {\n  // 优先使用真实IP（信任代理）\n  const ip = req.ip ||\n             req.headers['x-forwarded-for'] ||\n             req.headers['x-real-ip'] ||\n             req.socket.remoteAddress ||\n             'anonymous';\n  const finalIp = Array.isArray(ip) ? ip[0] : ip;\n  return finalIp || 'anonymous';\n}\n\n/**\n * 基于用户的键生成器\n */\nexport function userKeyGenerator(req: Request): string {\n  // 从req.user获取（需要auth middleware）\n  const userId = (req as any).user?.id;\n  if (userId) {\n    return `user:${userId}`;\n  }\n  // 降级到IP\n  return defaultKeyGenerator(req);\n}\n\n/**\n * 基于端点的键生成器\n */\nexport function endpointKeyGenerator(req: Request): string {\n  const ip = defaultKeyGenerator(req);\n  const path = req.path;\n  return `${ip}:${path}`;\n}\n\n/**\n * 检查是否在白名单中\n */\nfunction isWhitelisted(req: Request, whitelist: Array<string>): boolean {\n  const ip = defaultKeyGenerator(req);\n  return whitelist.includes(ip);\n}\n\n/**\n * 设置速率限制响应头\n */\nfunction setRateLimitHeaders(\n  res: Response,\n  rateLimiterRes: RateLimiterRes,\n  config: RateLimitConfig,\n): void {\n  res.set({\n    'X-RateLimit-Limit': config.points.toString(),\n    'X-RateLimit-Remaining': rateLimiterRes.remainingPoints.toString(),\n    'X-RateLimit-Reset': new Date(\n      Date.now() + rateLimiterRes.msBeforeNext,\n    ).toISOString(),\n  });\n}\n\n/**\n * 处理速率限制超出\n */\nfunction handleRateLimitExceeded(\n  req: Request,\n  res: Response,\n  rejRes: any,\n  config: RateLimitConfig,\n): void {\n  const msBeforeNext = rejRes?.msBeforeNext || 60000;\n  const retryAfter = Math.round(msBeforeNext / 1000);\n\n  // 设置响应头\n  res.set({\n    'Retry-After': retryAfter.toString(),\n    'X-RateLimit-Limit': config.points.toString(),\n    'X-RateLimit-Remaining': '0',\n    'X-RateLimit-Reset': new Date(Date.now() + msBeforeNext).toISOString(),\n  });\n\n  // 记录日志\n  logger.warn('速率限制触发', {\n    ip: defaultKeyGenerator(req),\n    path: req.path,\n    method: req.method,\n    retryAfter,\n  });\n\n  // 返回响应\n  res.status(429).json({\n    code: 'RATE_LIMIT_EXCEEDED',\n    message: '请求过于频繁，请稍后再试',\n    retryAfter,\n    timestamp: new Date().toISOString(),\n  });\n}\n\n// ==================== 预设中间件 ====================\n\n/**\n * 通用API限流\n */\nexport const apiRateLimiter = createRateLimiter({\n  config: RATE_LIMIT_PRESETS.api,\n});\n\n/**\n * 聊天接口限流\n */\nexport const chatRateLimiter = createRateLimiter({\n  config: RATE_LIMIT_PRESETS.chat,\n  keyGenerator: userKeyGenerator,\n});\n\n/**\n * 管理接口限流\n */\nexport const adminRateLimiter = createRateLimiter({\n  config: RATE_LIMIT_PRESETS.admin,\n  keyGenerator: userKeyGenerator,\n});\n\n/**\n * 登录接口限流（防暴力破解）\n */\nexport const loginRateLimiter = createRateLimiter({\n  config: RATE_LIMIT_PRESETS.login,\n  keyGenerator: endpointKeyGenerator,\n  skipSuccessfulRequests: true, // 成功登录不计数\n});\n\n/**\n * 注册接口限流\n */\nexport const registerRateLimiter = createRateLimiter({\n  config: RATE_LIMIT_PRESETS.register,\n});\n\n// ==================== 导出 ====================\n\nexport default rateLimiterManager;\nexport { rateLimiterManager };\n\n// 向后兼容旧接口\nexport { apiRateLimiter as rateLimiter, apiRateLimiter as rateLimiterMiddleware };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/middleware/requestLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/admin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/agents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/audit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/cad.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/chat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/difySession.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/productPreview.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/routes/sessionRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/scripts/enterprise-code-fixer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'issues' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":273,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":273,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceFile' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":438,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":438,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":634,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":634,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":659,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":659,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalCode' is defined but never used. Allowed unused args must match /^_/u.","line":664,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":664,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fixedCode' is defined but never used. Allowed unused args must match /^_/u.","line":664,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":664,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":664,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":664,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":675,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":675,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceFile' is defined but never used. Allowed unused args must match /^_/u.","line":675,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":675,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":687,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":687,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalCode' is defined but never used. Allowed unused args must match /^_/u.","line":691,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":691,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fixedCode' is defined but never used. Allowed unused args must match /^_/u.","line":691,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":691,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":691,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":691,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":702,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":702,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceFile' is defined but never used. Allowed unused args must match /^_/u.","line":702,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":702,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":713,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":713,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalCode' is defined but never used. Allowed unused args must match /^_/u.","line":717,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":717,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fixedCode' is defined but never used. Allowed unused args must match /^_/u.","line":717,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":717,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":717,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":717,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":728,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":728,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceFile' is defined but never used. Allowed unused args must match /^_/u.","line":728,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":728,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":739,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":739,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalCode' is defined but never used. Allowed unused args must match /^_/u.","line":743,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":743,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fixedCode' is defined but never used. Allowed unused args must match /^_/u.","line":743,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":743,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":743,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":743,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":754,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":754,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceFile' is defined but never used. Allowed unused args must match /^_/u.","line":754,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":754,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":765,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":765,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalCode' is defined but never used. Allowed unused args must match /^_/u.","line":769,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":769,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fixedCode' is defined but never used. Allowed unused args must match /^_/u.","line":769,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":769,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":769,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":769,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":780,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":780,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceFile' is defined but never used. Allowed unused args must match /^_/u.","line":780,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":780,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":791,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":791,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalCode' is defined but never used. Allowed unused args must match /^_/u.","line":795,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":795,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fixedCode' is defined but never used. Allowed unused args must match /^_/u.","line":795,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":795,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":795,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":795,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'node' is defined but never used. Allowed unused args must match /^_/u.","line":806,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":806,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceFile' is defined but never used. Allowed unused args must match /^_/u.","line":806,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":806,"endColumn":52},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":872,"column":26,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":872,"endColumn":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":40,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env ts-node\n/**\n * 🏢 企业级安全TypeScript代码修复工具\n *\n * 核心安全原则：\n * 🔒 安全第一 - 宁可少修复，不可错误修复\n * 🎯 AST解析优先 - 禁止使用字符串替换\n * ⚡ 精准定位 - 仅修改目标节点，不改变其他代码\n * 🔄 可逆操作 - 重要修改前创建备份，支持100%回滚\n * 📈 渐进修复 - 分步骤验证，避免一次性大规模修改\n * ✅ 语法验证 - 修复前后都要进行语法和类型检查\n * 📊 影响分析 - 每个修复必须评估语义变化和潜在风险\n * 👤 用户控制 - 所有关键修复必须经过人工确认\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport * as ts from 'typescript';\nimport crypto from 'crypto';\n\n// ========================================\n// 核心类型定义\n// ========================================\n\ninterface FixImpact {\n  semanticChange: 'none' | 'minor' | 'major';\n  performanceImpact: 'none' | 'low' | 'medium' | 'high';\n  readabilityChange: 'none' | 'positive' | 'negative';\n  breakingRisk: 'none' | 'low' | 'medium' | 'high';\n  changeDescription: string;\n  confidenceLevel: number; // 0-100\n}\n\ninterface CodeIssue {\n  id: string;\n  file: string;\n  line: number;\n  column: number;\n  endLine: number;\n  endColumn: number;\n  message: string;\n  ruleId: string;\n  severity: 'error' | 'warning' | 'info';\n  node?: ts.Node;\n  sourceFile?: ts.SourceFile;\n}\n\ninterface FixResult {\n  issue: CodeIssue;\n  fixed: boolean;\n  impact: FixImpact;\n  preview: {\n    original: string;\n    fixed: string;\n  };\n}\n\ninterface EnterpriseConfig {\n  mode: 'dry-run' | 'fix' | 'auto-fix';\n  backup: boolean;\n  maxFileSize: number;\n  memoryLimit: number;\n  maxConcurrentFiles: number;\n  rules: Record<string, {\n    level: 'error' | 'warning' | 'info';\n    autoFix: boolean;\n    maxRiskLevel: 'low' | 'medium' | 'high';\n  }>;\n  filePatterns: string[];\n  excludePatterns: string[];\n  validation: {\n    preFix: boolean;\n    postFix: boolean;\n    syntaxCheck: boolean;\n    typeCheck: boolean;\n    impactAnalysis: boolean;\n  };\n}\n\n// ========================================\n// 修复器接口定义\n// ========================================\n\ninterface CodeFixer {\n  name: string;\n  description: string;\n  fix: (node: ts.Node, sourceFile: ts.SourceFile, context: FixContext) => string;\n  impactAnalysis: (originalCode: string, fixedCode: string, node: ts.Node) => FixImpact;\n  validate: (node: ts.Node, sourceFile: ts.SourceFile) => boolean;\n  canAutoFix: boolean;\n  maxRiskLevel: 'low' | 'medium' | 'high';\n}\n\ninterface FixContext {\n  config: EnterpriseConfig;\n  sourceFile: ts.SourceFile;\n  program: ts.Program;\n  typeChecker: ts.TypeChecker;\n}\n\n// ========================================\n// 企业级代码修复器核心类\n// ========================================\n\nclass EnterpriseCodeFixer {\n  private config: EnterpriseConfig;\n  private fixers: Map<string, CodeFixer> = new Map();\n  private program: ts.Program | null = null;\n  private backupManager: BackupManager;\n\n  constructor(config: EnterpriseConfig) {\n    this.config = config;\n    this.backupManager = new BackupManager();\n    this.initializeFixers();\n  }\n\n  /**\n   * 初始化修复器\n   */\n  private initializeFixers(): void {\n    this.registerFixer(new RefCurrentFixer());\n    this.registerFixer(new ObjectLiteralFixer());\n    this.registerFixer(new UnusedVariableFixer());\n    this.registerFixer(new MissingTypeFixer());\n    this.registerFixer(new CommonJSRequireFixer());\n    this.registerFixer(new UnstableHookFixer());\n  }\n\n  /**\n   * 注册修复器\n   */\n  private registerFixer(fixer: CodeFixer): void {\n    this.fixers.set(fixer.name, fixer);\n  }\n\n  /**\n   * 安全修复处理入口\n   */\n  async safeFixFiles(files: string[]): Promise<FixResult[]> {\n    console.log('🔒 启动企业级安全代码修复...');\n    console.log(`📁 处理文件数: ${files.length}`);\n    console.log(`⚙️  修复模式: ${this.config.mode}`);\n\n    const allResults: FixResult[] = [];\n\n    // 预检查\n    await this.preFlightCheck(files);\n\n    // 处理每个文件\n    for (const file of files) {\n      try {\n        const results = await this.safeFixFile(file);\n        allResults.push(...results);\n      } catch (error) {\n        console.error(`❌ 文件处理失败: ${file} - ${error instanceof Error ? error.message : String(error)}`);\n        continue;\n      }\n    }\n\n    // 生成报告\n    this.generateReport(allResults);\n\n    return allResults;\n  }\n\n  /**\n   * 预检查 - 验证处理条件\n   */\n  private async preFlightCheck(files: string[]): Promise<void> {\n    console.log('🔍 执行预检查...');\n\n    for (const file of files) {\n      // 检查文件存在性\n      if (!fs.existsSync(file)) {\n        throw new Error(`文件不存在: ${file}`);\n      }\n\n      // 检查文件大小\n      const stats = fs.statSync(file);\n      if (stats.size > this.config.maxFileSize) {\n        console.log(`⚠️ 跳过文件: ${file} (大小 ${this.formatSize(stats.size)} > ${this.formatSize(this.config.maxFileSize)})`);\n        continue;\n      }\n\n      // 检查内存使用\n      const memoryUsage = process.memoryUsage();\n      if (memoryUsage.rss > this.config.memoryLimit) {\n        throw new Error(`内存使用过高 (${this.formatSize(memoryUsage.rss)} > ${this.formatSize(this.config.memoryLimit)})`);\n      }\n\n      // 检查文件类型\n      if (!this.isValidTypeScriptFile(file)) {\n        console.log(`⚠️ 跳过非TypeScript文件: ${file}`);\n        continue;\n      }\n    }\n\n    console.log('✅ 预检查通过');\n  }\n\n  /**\n   * 安全修复单个文件\n   */\n  private async safeFixFile(filePath: string): Promise<FixResult[]> {\n    console.log(`🔧 处理文件: ${filePath}`);\n\n    // 创建TypeScript程序\n    const program = ts.createProgram([filePath], ts.getDefaultCompilerOptions());\n    this.program = program;\n\n    const sourceFile = program.getSourceFile(filePath);\n    if (!sourceFile) {\n      throw new Error(`无法读取源文件: ${filePath}`);\n    }\n\n    // 分析问题\n    const issues = this.analyzeIssues(sourceFile);\n    console.log(`📊 发现问题: ${issues.length} 个`);\n\n    const results: FixResult[] = [];\n\n    for (const issue of issues) {\n      const ruleConfig = this.config.rules[issue.ruleId];\n      if (!ruleConfig) {\n        continue;\n      }\n\n      // 检查是否应该自动修复\n      if (this.config.mode === 'auto-fix' && !ruleConfig.autoFix) {\n        console.log(`⚠️ 跳过问题: ${issue.message} (规则 ${issue.ruleId} 不支持自动修复)`);\n        continue;\n      }\n\n      // 执行修复\n      const result = await this.safeFixIssue(issue, sourceFile);\n      if (result) {\n        results.push(result);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * 分析代码问题\n   */\n  private analyzeIssues(sourceFile: ts.SourceFile): CodeIssue[] {\n    const issues: CodeIssue[] = [];\n    const ruleConfigs = Object.entries(this.config.rules);\n\n    for (const [ruleId, config] of ruleConfigs) {\n      const fixer = this.fixers.get(ruleId);\n      if (!fixer) {\n        continue;\n      }\n\n      // 使用TypeScript编译器API查找问题\n      const foundIssues = this.findIssuesForRule(fixer, sourceFile, config.level);\n      issues.push(...foundIssues);\n    }\n\n    return issues;\n  }\n\n  /**\n   * 为特定规则查找问题\n   */\n  private findIssuesForRule(\n    fixer: CodeFixer,\n    sourceFile: ts.SourceFile,\n    severity: 'error' | 'warning' | 'info',\n  ): CodeIssue[] {\n    const issues: CodeIssue[] = [];\n    const visitor = new RuleVisitor(fixer, severity);\n\n    ts.forEachChild(sourceFile, (node) => {\n      if (node) {\n        visitor.visit(node, sourceFile);\n      }\n    });\n\n    return visitor.getIssues();\n  }\n\n  /**\n   * 安全修复单个问题\n   */\n  private async safeFixIssue(issue: CodeIssue, sourceFile: ts.SourceFile): Promise<FixResult | null> {\n    const fixer = this.fixers.get(issue.ruleId);\n    if (!fixer || !issue.node) {\n      return null;\n    }\n\n    // 验证修复条件\n    if (!fixer.validate(issue.node, sourceFile)) {\n      console.log(`⚠️ 修复验证失败: ${issue.message}`);\n      return null;\n    }\n\n    // 生成修复预览\n    const originalCode = issue.node.getText(sourceFile);\n    const fixedCode = fixer.fix(issue.node, sourceFile, {\n      config: this.config,\n      sourceFile,\n      program: this.program!,\n      typeChecker: this.program!.getTypeChecker(),\n    });\n\n    // 影响分析\n    const impact = fixer.impactAnalysis(originalCode, fixedCode, issue.node);\n\n    // 风险检查\n    if (impact.breakingRisk === 'high') {\n      console.log(`🚨 高风险修复: ${issue.message} - 需要人工确认`);\n      return null;\n    }\n\n    // 创建修复结果\n    const result: FixResult = {\n      issue,\n      fixed: false,\n      impact,\n      preview: {\n        original: originalCode,\n        fixed: fixedCode,\n      },\n    };\n\n    // 在非dry-run模式下执行修复\n    if (this.config.mode !== 'dry-run') {\n      const success = await this.applyFixAtomically(sourceFile.fileName, issue, fixedCode);\n      result.fixed = success;\n    }\n\n    return result;\n  }\n\n  /**\n   * 原子应用修复\n   */\n  private async applyFixAtomically(\n    filePath: string,\n    issue: CodeIssue,\n    fixedCode: string,\n  ): Promise<boolean> {\n    if (!this.config.backup) {\n      throw new Error('备份未启用，无法执行修复');\n    }\n\n    const tempFile = `${filePath}.tmp.${Date.now()}`;\n    const backupFile = `${filePath}.backup.${Date.now()}`;\n\n    try {\n      // 1. 创建备份\n      await this.backupManager.createBackup(filePath, backupFile);\n\n      // 2. 读取原始内容\n      const originalContent = fs.readFileSync(filePath, 'utf-8');\n\n      // 3. 创建临时文件\n      fs.writeFileSync(tempFile, originalContent);\n\n      // 4. 应用修复（使用精确的AST操作）\n      const fixedContent = this.applyFixToContent(originalContent, issue, fixedCode);\n\n      // 5. 修复前验证\n      if (this.config.validation.preFix && !this.validateSyntax(originalContent, filePath)) {\n        throw new Error('原始文件语法验证失败');\n      }\n\n      // 6. 修复后验证\n      if (this.config.validation.postFix && !this.validateSyntax(fixedContent, filePath)) {\n        throw new Error('修复后语法验证失败');\n      }\n\n      // 7. 类型检查\n      if (this.config.validation.typeCheck) {\n        const typeCheckResult = await this.performTypeCheck(tempFile);\n        if (!typeCheckResult.success) {\n          throw new Error(`类型检查失败: ${typeCheckResult.errors.join(', ')}`);\n        }\n      }\n\n      // 8. 原子替换\n      fs.writeFileSync(filePath, fixedContent);\n      fs.unlinkSync(tempFile);\n\n      console.log(`✅ 修复成功: ${filePath} - ${issue.message}`);\n      return true;\n\n    } catch (error) {\n      // 清理临时文件\n      if (fs.existsSync(tempFile)) {\n        fs.unlinkSync(tempFile);\n      }\n\n      // 回滚到备份\n      if (fs.existsSync(backupFile)) {\n        fs.copyFileSync(backupFile, filePath);\n        fs.unlinkSync(backupFile);\n        console.log(`🔄 已回滚: ${filePath}`);\n      }\n\n      console.error(`修复失败: ${error instanceof Error ? error.message : String(error)}`);\n      return false;\n    }\n  }\n\n  /**\n   * 应用修复到内容\n   */\n  private applyFixToContent(\n    originalContent: string,\n    issue: CodeIssue,\n    fixedCode: string,\n  ): string {\n    const lines = originalContent.split('\\n');\n\n    // 精确替换目标行\n    const startLine = issue.line - 1;\n    const endLine = issue.endLine - 1;\n\n    if (startLine >= 0 && endLine < lines.length) {\n      const before = lines.slice(0, startLine).join('\\n');\n      const after = lines.slice(endLine + 1).join('\\n');\n\n      return before + '\\n' + fixedCode + '\\n' + after;\n    }\n\n    throw new Error('无法定位修复位置');\n  }\n\n  /**\n   * 语法验证\n   */\n  private validateSyntax(content: string, filePath: string): boolean {\n    try {\n      const sourceFile = ts.createSourceFile(\n        filePath,\n        content,\n        ts.ScriptTarget.Latest,\n      );\n\n      // 使用TypeScript编译器进行语法检查\n      const diagnostics = ts.getPreEmitDiagnostics(ts.createProgram([filePath], {}));\n      return diagnostics.length === 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * 类型检查\n   */\n  private async performTypeCheck(filePath: string): Promise<{\n    success: boolean;\n    errors: string[];\n  }> {\n    try {\n      const program = ts.createProgram([filePath], {\n        target: ts.ScriptTarget.Latest,\n        module: ts.ModuleKind.CommonJS,\n        strict: true,\n      });\n\n      const diagnostics = ts.getPreEmitDiagnostics(program);\n\n      const errors = diagnostics\n        .filter(d => d.category === ts.DiagnosticCategory.Error)\n        .map(d => typeof d.messageText === 'string' ? d.messageText : d.messageText?.toString() || '');\n\n      return {\n        success: errors.length === 0,\n        errors,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        errors: [error instanceof Error ? error.message : '未知错误'],\n      };\n    }\n  }\n\n  /**\n   * 生成报告\n   */\n  private generateReport(results: FixResult[]): void {\n    console.log('\\n' + '='.repeat(60));\n    console.log('📊 企业级代码修复报告');\n    console.log('='.repeat(60));\n\n    const stats = {\n      total: results.length,\n      fixed: results.filter(r => r.fixed).length,\n      failed: results.filter(r => !r.fixed).length,\n      highRisk: results.filter(r => r.impact.breakingRisk === 'high').length,\n      mediumRisk: results.filter(r => r.impact.breakingRisk === 'medium').length,\n      lowRisk: results.filter(r => r.impact.breakingRisk === 'low').length,\n    };\n\n    console.log('📈 修复统计:');\n    console.log(`   总问题数: ${stats.total}`);\n    console.log(`   修复成功: ${stats.fixed}`);\n    console.log(`   修复失败: ${stats.failed}`);\n    console.log(`   高风险: ${stats.highRisk}`);\n    console.log(`   中风险: ${stats.mediumRisk}`);\n    console.log(`   低风险: ${stats.lowRisk}`);\n\n    if (results.length > 0) {\n      console.log('\\n📋 详细修复记录:');\n\n      results.forEach((result, index) => {\n        console.log(`\\n${index + 1}. ${result.issue.message}`);\n        console.log(`   文件: ${result.issue.file}:${result.issue.line}`);\n        console.log(`   严重性: ${result.issue.severity}`);\n        console.log(`   状态: ${result.fixed ? '✅ 已修复' : '❌ 未修复'}`);\n\n        console.log('   影响分析:');\n        console.log(`     语义变化: ${result.impact.semanticChange}`);\n        console.log(`     性能影响: ${result.impact.performanceImpact}`);\n        console.log(`     可读性变化: ${result.impact.readabilityChange}`);\n        console.log(`     破坏风险: ${result.impact.breakingRisk}`);\n        console.log(`     置信度: ${result.impact.confidenceLevel}%`);\n        console.log(`     描述: ${result.impact.changeDescription}`);\n\n        if (this.config.mode === 'dry-run') {\n          console.log('   修复预览:');\n          console.log(`     原始: ${result.preview.original}`);\n          console.log(`     修复: ${result.preview.fixed}`);\n        }\n      });\n    }\n\n    console.log('\\n' + '='.repeat(60));\n    console.log('🔒 安全修复完成');\n    console.log('='.repeat(60));\n  }\n\n  /**\n   * 工具方法\n   */\n  private isValidTypeScriptFile(filePath: string): boolean {\n    return /\\.(ts|tsx)$/i.test(filePath);\n  }\n\n  private formatSize(bytes: number): string {\n    const units = ['B', 'KB', 'MB', 'GB'];\n    let size = bytes;\n    let unitIndex = 0;\n\n    while (size >= 1024 && unitIndex < units.length - 1) {\n      size /= 1024;\n      unitIndex++;\n    }\n\n    return `${size.toFixed(1)} ${units[unitIndex]}`;\n  }\n}\n\n// ========================================\n// 备份管理器\n// ========================================\n\nclass BackupManager {\n  private backupDir: string = 'backups/code-fixer';\n\n  async createBackup(filePath: string, backupPath: string): Promise<void> {\n    await this.ensureBackupDir();\n\n    const backupContent = fs.readFileSync(filePath);\n    const checksum = this.calculateChecksum(backupContent.toString());\n\n    // 创建备份信息文件\n    const backupInfo = {\n      originalPath: filePath,\n      backupPath: backupPath,\n      checksum,\n      timestamp: new Date().toISOString(),\n    };\n\n    // 写入备份文件和信息\n    fs.writeFileSync(backupPath, backupContent);\n    fs.writeFileSync(`${backupPath}.info`, JSON.stringify(backupInfo, null, 2));\n\n    console.log(`📦 备份创建: ${backupPath}`);\n  }\n\n  private calculateChecksum(content: string): string {\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  private async ensureBackupDir(): Promise<void> {\n    if (!fs.existsSync(this.backupDir)) {\n      fs.mkdirSync(this.backupDir, { recursive: true });\n    }\n  }\n}\n\n// ========================================\n// 规则访问器\n// ========================================\n\nclass RuleVisitor {\n  private issues: CodeIssue[] = [];\n  private fixer: CodeFixer;\n  private severity: 'error' | 'warning' | 'info';\n\n  constructor(fixer: CodeFixer, severity: 'error' | 'warning' | 'info') {\n    this.fixer = fixer;\n    this.severity = severity;\n  }\n\n  visit(node: ts.Node, sourceFile: ts.SourceFile): void {\n    // 具体的规则检测逻辑\n    if (this.detectIssue(node)) {\n      const issue: CodeIssue = {\n        id: this.generateId(),\n        file: sourceFile.fileName,\n        line: ts.getLineAndCharacterOfPosition(sourceFile, node.getStart()).line + 1,\n        column: ts.getLineAndCharacterOfPosition(sourceFile, node.getStart()).character + 1,\n        endLine: ts.getLineAndCharacterOfPosition(sourceFile, node.getEnd()).line + 1,\n        endColumn: ts.getLineAndCharacterOfPosition(sourceFile, node.getEnd()).character + 1,\n        message: this.fixer.description,\n        ruleId: this.fixer.name,\n        severity: this.severity,\n        node,\n        sourceFile,\n      };\n\n      this.issues.push(issue);\n    }\n  }\n\n  private detectIssue(node: ts.Node): boolean {\n    // 这里应该实现具体的检测逻辑\n    // 例如检测ref.current在依赖数组中的使用\n    return false;\n  }\n\n  private generateId(): string {\n    return `fix_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getIssues(): CodeIssue[] {\n    return this.issues;\n  }\n}\n\n// ========================================\n// 具体修复器实现（示例）\n// ========================================\n\nclass RefCurrentFixer implements CodeFixer {\n  readonly name = 'ref-current';\n  readonly description = '移除依赖数组中的ref.current引用';\n  readonly canAutoFix = true;\n  readonly maxRiskLevel = 'medium';\n\n  fix(node: ts.Node, sourceFile: ts.SourceFile, context: FixContext): string {\n    // 实现具体的修复逻辑\n    return node.getText(sourceFile).replace(/ref\\.current/g, 'ref');\n  }\n\n  impactAnalysis(originalCode: string, fixedCode: string, node: ts.Node): FixImpact {\n    return {\n      semanticChange: 'none',\n      performanceImpact: 'low',\n      readabilityChange: 'positive',\n      breakingRisk: 'low',\n      changeDescription: '移除ref.current，避免不必要的重新渲染',\n      confidenceLevel: 95,\n    };\n  }\n\n  validate(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n    // 验证是否可以安全修复\n    return true;\n  }\n}\n\nclass ObjectLiteralFixer implements CodeFixer {\n  readonly name = 'object-literals';\n  readonly description = '修复对象字面量类型问题';\n  readonly canAutoFix = false;\n  readonly maxRiskLevel = 'high';\n\n  fix(node: ts.Node, sourceFile: ts.SourceFile, context: FixContext): string {\n    return node.getText(sourceFile);\n  }\n\n  impactAnalysis(originalCode: string, fixedCode: string, node: ts.Node): FixImpact {\n    return {\n      semanticChange: 'minor',\n      performanceImpact: 'none',\n      readabilityChange: 'positive',\n      breakingRisk: 'medium',\n      changeDescription: '添加对象字面量类型注解',\n      confidenceLevel: 85,\n    };\n  }\n\n  validate(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n    return false; // 不自动修复\n  }\n}\n\nclass UnusedVariableFixer implements CodeFixer {\n  readonly name = 'unused-variables';\n  readonly description = '移除未使用的变量';\n  readonly canAutoFix = false;\n  readonly maxRiskLevel = 'low';\n\n  fix(node: ts.Node, sourceFile: ts.SourceFile, context: FixContext): string {\n    return node.getText(sourceFile);\n  }\n\n  impactAnalysis(originalCode: string, fixedCode: string, node: ts.Node): FixImpact {\n    return {\n      semanticChange: 'none',\n      performanceImpact: 'low',\n      readabilityChange: 'positive',\n      breakingRisk: 'low',\n      changeDescription: '移除未使用的变量声明',\n      confidenceLevel: 90,\n    };\n  }\n\n  validate(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n    return false;\n  }\n}\n\nclass MissingTypeFixer implements CodeFixer {\n  readonly name = 'missing-types';\n  readonly description = '添加缺失的类型注解';\n  readonly canAutoFix = false;\n  readonly maxRiskLevel = 'medium';\n\n  fix(node: ts.Node, sourceFile: ts.SourceFile, context: FixContext): string {\n    return node.getText(sourceFile);\n  }\n\n  impactAnalysis(originalCode: string, fixedCode: string, node: ts.Node): FixImpact {\n    return {\n      semanticChange: 'minor',\n      performanceImpact: 'none',\n      readabilityChange: 'positive',\n      breakingRisk: 'low',\n      changeDescription: '添加类型注解提高代码安全性',\n      confidenceLevel: 80,\n    };\n  }\n\n  validate(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n    return false;\n  }\n}\n\nclass CommonJSRequireFixer implements CodeFixer {\n  readonly name = 'commonjs-require';\n  readonly description = '转换CommonJS require为ES模块导入';\n  readonly canAutoFix = false;\n  readonly maxRiskLevel = 'high';\n\n  fix(node: ts.Node, sourceFile: ts.SourceFile, context: FixContext): string {\n    return node.getText(sourceFile);\n  }\n\n  impactAnalysis(originalCode: string, fixedCode: string, node: ts.Node): FixImpact {\n    return {\n      semanticChange: 'major',\n      performanceImpact: 'none',\n      readabilityChange: 'positive',\n      breakingRisk: 'high',\n      changeDescription: '转换为ES模块导入语法',\n      confidenceLevel: 75,\n    };\n  }\n\n  validate(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n    return false;\n  }\n}\n\nclass UnstableHookFixer implements CodeFixer {\n  readonly name = 'unstable-hooks';\n  readonly description = '修复不稳定的React Hook使用';\n  readonly canAutoFix = false;\n  readonly maxRiskLevel = 'high';\n\n  fix(node: ts.Node, sourceFile: ts.SourceFile, context: FixContext): string {\n    return node.getText(sourceFile);\n  }\n\n  impactAnalysis(originalCode: string, fixedCode: string, node: ts.Node): FixImpact {\n    return {\n      semanticChange: 'major',\n      performanceImpact: 'medium',\n      readabilityChange: 'positive',\n      breakingRisk: 'high',\n      changeDescription: '重构不稳定的Hook使用模式',\n      confidenceLevel: 70,\n    };\n  }\n\n  validate(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n    return false;\n  }\n}\n\n// ========================================\n// 主执行函数\n// ========================================\n\nasync function main() {\n  // 企业级默认配置\n  const config: EnterpriseConfig = {\n    mode: 'dry-run', // 首次运行必须使用dry-run\n    backup: true,\n    maxFileSize: 100 * 1024, // 100KB\n    memoryLimit: 500 * 1024 * 1024, // 500MB\n    maxConcurrentFiles: 5,\n    rules: {\n      'ref-current': { level: 'error', autoFix: false, maxRiskLevel: 'medium' },\n      'object-literals': { level: 'warning', autoFix: false, maxRiskLevel: 'high' },\n      'unused-variables': { level: 'warning', autoFix: false, maxRiskLevel: 'low' },\n      'missing-types': { level: 'info', autoFix: false, maxRiskLevel: 'medium' },\n      'commonjs-require': { level: 'warning', autoFix: false, maxRiskLevel: 'high' },\n      'unstable-hooks': { level: 'error', autoFix: false, maxRiskLevel: 'high' },\n    },\n    filePatterns: ['src/**/*.{ts,tsx}'],\n    excludePatterns: ['**/*.test.{ts,tsx}', '**/*.stories.{ts,tsx}', '**/node_modules/**'],\n    validation: {\n      preFix: true,\n      postFix: true,\n      syntaxCheck: true,\n      typeCheck: true,\n      impactAnalysis: true,\n    },\n  };\n\n  console.log('🏢 企业级安全TypeScript代码修复工具');\n  console.log('=====================================');\n\n  const fixer = new EnterpriseCodeFixer(config);\n\n  // 查找目标文件\n  const files = findTargetFiles(config.filePatterns, config.excludePatterns);\n\n  if (files.length === 0) {\n    console.log('ℹ️ 未找到目标文件');\n    return;\n  }\n\n  // 执行安全修复\n  const results = await fixer.safeFixFiles(files);\n\n  // 输出结果统计\n  const fixedCount = results.filter(r => r.fixed).length;\n  console.log(`\\n🎯 修复完成: ${fixedCount}/${results.length}`);\n\n  if (config.mode === 'dry-run' && results.length > 0) {\n    console.log('\\n💡 提示: 使用 --mode fix 应用修复');\n    console.log('⚠️  警告: 首次使用请仔细审查每个修复');\n  }\n}\n\nfunction findTargetFiles(patterns: string[], excludePatterns: string[]): string[] {\n  const files: string[] = [];\n\n  for (const pattern of patterns) {\n    const matchedFiles = require('glob').sync(pattern, {\n      ignore: excludePatterns,\n      absolute: true,\n    });\n    files.push(...matchedFiles);\n  }\n\n  return [...new Set(files)]; // 去重\n}\n\n// 执行\nif (require.main === module) {\n  main().catch(error => {\n    console.error('❌ 企业级代码修复失败:', error);\n    process.exit(1);\n  });\n}\n\nexport { EnterpriseCodeFixer, CodeFixer, FixImpact, EnterpriseConfig };","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/scripts/migrate-passwords.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1469,1472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1469,1472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2328,2331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2328,2331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3904,3907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3904,3907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env ts-node\n/**\n * 密码迁移脚本\n *\n * 用途:\n * - 将现有password_plain字段转换为bcrypt哈希\n * - 更新password_hash字段\n * - 验证迁移结果\n *\n * 使用:\n * npm run migrate:passwords\n * 或\n * ts-node -r tsconfig-paths/register backend/src/scripts/migrate-passwords.ts\n *\n * ⚠️  警告:\n * - 执行前会备份数据\n * - 不可逆操作，请谨慎执行\n * - 确保已运行迁移007和008\n */\n\nimport '../dotenv-loader'; // 加载环境变量\nimport bcrypt from 'bcrypt';\nimport { withClient } from '../utils/db';\nimport logger from '../utils/logger';\n\nconst SALT_ROUNDS = 12;\n\ninterface UserRow {\n  id: string;\n  username: string;\n  password_plain: string | null;\n  password_hash: string | null;\n}\n\nclass PasswordMigrator {\n  private migratedCount = 0;\n  private skippedCount = 0;\n  private errorCount = 0;\n\n  /**\n   * 执行迁移\n   */\n  async migrate(): Promise<void> {\n    console.log('🔐 开始密码迁移...\\n');\n\n    try {\n      // 1. 检查数据库连接\n      await this.checkConnection();\n\n      // 2. 检查必需字段\n      await this.checkRequiredFields();\n\n      // 3. 获取需要迁移的用户\n      const users = await this.getUsersToMigrate();\n\n      if (users.length === 0) {\n        console.log('✅ 没有需要迁移的用户\\n');\n        return;\n      }\n\n      console.log(`📊 找到 ${users.length} 个需要迁移的用户\\n`);\n\n      // 4. 用户确认\n      if (!await this.confirmMigration(users.length)) {\n        console.log('❌ 迁移已取消\\n');\n        return;\n      }\n\n      // 5. 执行迁移\n      await this.migrateUsers(users);\n\n      // 6. 验证结果\n      await this.verifyMigration();\n\n      // 7. 生成报告\n      this.generateReport();\n\n    } catch (error: any) {\n      console.error('\\n❌ 迁移失败:', error.message);\n      if (error.stack) {\n        console.error('\\n堆栈跟踪:');\n        console.error(error.stack);\n      }\n      process.exit(1);\n    }\n  }\n\n  private async checkConnection(): Promise<void> {\n    console.log('🔍 检查数据库连接...');\n\n    await withClient(async (client) => {\n      const { rows } = await client.query('SELECT NOW()');\n      console.log(`✅ 数据库连接正常 (${rows[0].now})\\n`);\n    });\n  }\n\n  private async checkRequiredFields(): Promise<void> {\n    console.log('🔍 检查必需字段...');\n\n    await withClient(async (client) => {\n      // 检查password_hash字段\n      const { rows } = await client.query(`\n        SELECT column_name \n        FROM information_schema.columns \n        WHERE table_name = 'users' \n          AND column_name IN ('password_hash', 'password_plain')\n      `);\n\n      const fields = rows.map((r: any) => r.column_name);\n\n      if (!fields.includes('password_hash')) {\n        throw new Error('users表缺少password_hash字段，请先运行数据库迁移');\n      }\n\n      console.log('✅ 必需字段检查通过\\n');\n    });\n  }\n\n  private async getUsersToMigrate(): Promise<Array<UserRow>> {\n    console.log('🔍 查询需要迁移的用户...');\n\n    const users = await withClient(async (client) => {\n      const { rows } = await client.query<UserRow>(`\n        SELECT id, username, password_plain, password_hash\n        FROM users\n        WHERE password_plain IS NOT NULL \n          AND password_plain != ''\n          AND (password_hash IS NULL OR password_hash = '')\n        ORDER BY created_at\n      `);\n      return rows;\n    });\n\n    return users;\n  }\n\n  private async confirmMigration(count: number): Promise<boolean> {\n    console.log('⚠️  警告:');\n    console.log(`   - 即将迁移 ${count} 个用户的密码`);\n    console.log('   - 明文密码将被bcrypt哈希替换');\n    console.log('   - 此操作不可逆\\n');\n\n    // 自动模式（CI/CD环境）\n    if (process.env.AUTO_CONFIRM === 'true') {\n      console.log('✅ 自动确认模式：继续迁移\\n');\n      return true;\n    }\n\n    // 交互模式\n    console.log('💡 如需继续，请设置环境变量 AUTO_CONFIRM=true\\n');\n    return false;\n  }\n\n  private async migrateUsers(users: Array<UserRow>): Promise<void> {\n    console.log('🔄 开始迁移用户密码...\\n');\n\n    for (const user of users) {\n      try {\n        await this.migrateUser(user);\n        this.migratedCount++;\n\n        // 显示进度\n        const progress = Math.round((this.migratedCount / users.length) * 100);\n        process.stdout.write(`\\r进度: ${progress}% (${this.migratedCount}/${users.length})`);\n\n      } catch (error: any) {\n        this.errorCount++;\n        logger.error('用户密码迁移失败', {\n          userId: user.id,\n          username: user.username,\n          error: error.message,\n        });\n      }\n    }\n\n    console.log('\\n'); // 换行\n  }\n\n  private async migrateUser(user: UserRow): Promise<void> {\n    if (!user.password_plain) {\n      this.skippedCount++;\n      return;\n    }\n\n    // 生成bcrypt哈希\n    const passwordHash = await bcrypt.hash(user.password_plain, SALT_ROUNDS);\n\n    // 更新数据库\n    await withClient(async (client) => {\n      await client.query(\n        `UPDATE users \n         SET password_hash = $1, \n             password_updated_at = CURRENT_TIMESTAMP,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE id = $2`,\n        [passwordHash, user.id],\n      );\n    });\n\n    logger.info('用户密码已迁移', {\n      userId: user.id,\n      username: user.username,\n    });\n  }\n\n  private async verifyMigration(): Promise<void> {\n    console.log('🔍 验证迁移结果...');\n\n    await withClient(async (client) => {\n      // 检查是否还有未迁移的用户\n      const { rows } = await client.query(`\n        SELECT COUNT(*) as count\n        FROM users\n        WHERE password_plain IS NOT NULL \n          AND password_plain != ''\n          AND (password_hash IS NULL OR password_hash = '' OR length(password_hash) < 60)\n      `);\n\n      const unmigrated = parseInt(rows[0].count, 10);\n\n      if (unmigrated > 0) {\n        console.log(`⚠️  仍有 ${unmigrated} 个用户未迁移\\n`);\n      } else {\n        console.log('✅ 所有用户密码已成功迁移\\n');\n      }\n    });\n  }\n\n  private generateReport(): void {\n    console.log('='.repeat(60));\n    console.log('📊 密码迁移报告');\n    console.log('='.repeat(60));\n    console.log();\n\n    console.log(`✅ 成功迁移: ${this.migratedCount} 个用户`);\n    console.log(`⏭️  跳过: ${this.skippedCount} 个用户`);\n    console.log(`❌ 失败: ${this.errorCount} 个用户`);\n    console.log();\n\n    if (this.migratedCount > 0) {\n      console.log('🔧 后续步骤:');\n      console.log('   1. 验证用户可以正常登录');\n      console.log('   2. 运行迁移007删除password_plain列');\n      console.log('   3. 更新AuthController使用AuthServiceV2');\n      console.log('   4. 部署到生产环境');\n      console.log();\n    }\n\n    if (this.errorCount > 0) {\n      console.log('⚠️  注意:');\n      console.log('   - 部分用户迁移失败，请检查日志');\n      console.log('   - 失败的用户可能无法登录');\n      console.log('   - 建议联系管理员重置密码');\n      console.log();\n    }\n\n    console.log('='.repeat(60));\n    console.log();\n  }\n}\n\n// 执行迁移\nasync function main() {\n  const migrator = new PasswordMigrator();\n  await migrator.migrate();\n}\n\n// 仅当直接运行时执行\nif (require.main === module) {\n  main().catch(error => {\n    console.error('❌ 脚本执行失败:', error);\n    process.exit(1);\n  });\n}\n\nexport { PasswordMigrator };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/scripts/migrate.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readJsonc' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * 数据库迁移CLI工具\n * Usage:\n *   npm run migrate up          - 执行所有待执行的迁移\n *   npm run migrate down [n]    - 回滚最后n次迁移 (默认 1)\n *   npm run migrate status      - 查看迁移状态\n *   npm run migrate mark <version> <name> - 标记迁移为已执行\n */\n\nimport { Pool } from 'pg';\nimport { readJsonc } from '../utils/config';\nimport { createMigrationManager } from '../utils/migrate';\nimport { PgConfig, normalizePostgresConfig } from '../utils/db';\nimport { resolveEnvInJsonc } from '../utils/envResolver';\nimport fs from 'fs';\nimport path from 'path';\n\nasync function main() {\n  const args = process.argv.slice(2);\n  const command = args[0] || 'status';\n\n  // 加载配置\n  const configPath = path.resolve(__dirname, '../../../config/config.jsonc');\n  const configContent = fs.readFileSync(configPath, 'utf-8');\n  const resolvedConfig = resolveEnvInJsonc(configContent);\n  const cfg = JSON.parse(resolvedConfig) as PgConfig;\n\n  const rawPg = cfg.database?.postgres;\n  if (!rawPg) {\n    console.error('❌ 错误: 数据库配置缺失 (config.jsonc -> database.postgres)');\n    process.exit(1);\n  }\n\n  const pg = normalizePostgresConfig(rawPg);\n\n  // 创建连接池\n  const pool = new Pool({\n    host: pg.host,\n    port: pg.port ?? 5432,\n    user: pg.user,\n    password: pg.password,\n    database: pg.database,\n    ssl: pg.ssl ? { rejectUnauthorized: false } : undefined,\n  });\n\n  const manager = createMigrationManager(pool);\n\n  try {\n    switch (command) {\n      case 'up': {\n        console.log('🚀 执行数据库迁移...\\n');\n        const result = await manager.migrateUp();\n\n        if (result.executed.length === 0) {\n          console.log('✅ 数据库已是最新状态 (跳过 %d 个迁移)\\n', result.skipped);\n        } else {\n          console.log('\\n✅ 成功执行 %d 个迁移:\\n', result.executed.length);\n          result.executed.forEach(m => {\n            console.log('  - %s: %s', m.version, m.name);\n          });\n          console.log('');\n        }\n        break;\n      }\n\n      case 'down': {\n        const steps = parseInt(args[1] || '1', 10);\n        if (isNaN(steps) || steps < 1) {\n          console.error('❌ 错误: 无效的回滚步数 \"%s\"', args[1]);\n          process.exit(1);\n        }\n\n        console.log('🔄 回滚最后 %d 个迁移...\\n', steps);\n        const rolledBack = await manager.migrateDown(steps);\n\n        if (rolledBack.length === 0) {\n          console.log('✅ 没有可回滚的迁移\\n');\n        } else {\n          console.log('\\n✅ 成功回滚 %d 个迁移:\\n', rolledBack.length);\n          rolledBack.forEach(m => {\n            console.log('  - %s: %s', m.version, m.name);\n          });\n          console.log('');\n        }\n        break;\n      }\n\n      case 'status': {\n        const status = await manager.getStatus();\n\n        console.log('📊 数据库迁移状态\\n');\n        console.log('总迁移数: %d', status.total);\n        console.log('已执行: %d', status.executed.length);\n        console.log('待执行: %d\\n', status.pending.length);\n\n        if (status.executed.length > 0) {\n          console.log('✅ 已执行的迁移:\\n');\n          status.executed.forEach(m => {\n            const date = new Date(m.executed_at).toLocaleString('zh-CN');\n            console.log('  %s: %s (执行时间: %s)', m.version, m.name, date);\n          });\n          console.log('');\n        }\n\n        if (status.pending.length > 0) {\n          console.log('⏳ 待执行的迁移:\\n');\n          status.pending.forEach(m => {\n            console.log('  %s: %s', m.version, m.name);\n          });\n          console.log('');\n        }\n        break;\n      }\n\n      case 'mark': {\n        const version = args[1];\n        const name = args[2];\n\n        if (!version || !name) {\n          console.error('❌ 错误: 缺少参数\\n');\n          console.log('用法: npm run migrate mark <version> <name>');\n          console.log('示例: npm run migrate mark 001 \"create users table\"');\n          process.exit(1);\n        }\n\n        await manager.markAsExecuted(version, name);\n        console.log('✅ 迁移 %s (%s) 已标记为已执行\\n', version, name);\n        break;\n      }\n\n      default: {\n        console.error('❌ 未知命令: %s\\n', command);\n        console.log('可用命令:');\n        console.log('  up          - 执行所有待执行的迁移');\n        console.log('  down [n]    - 回滚最后n次迁移 (默认 1)');\n        console.log('  status      - 查看迁移状态');\n        console.log('  mark <version> <name> - 标记迁移为已执行');\n        process.exit(1);\n      }\n    }\n  } catch (error) {\n    console.error('\\n❌ 迁移失败:', error instanceof Error ? error.message : String(error));\n    console.error('');\n    process.exit(1);\n  } finally {\n    await pool.end();\n  }\n}\n\nmain();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/scripts/secure-config-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'backupInfo' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":69,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3392,3395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3392,3395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3706,3709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3706,3709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3734,3737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3734,3737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":224,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5528,5531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5528,5531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6465,6468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6465,6468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":286,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6951,6954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6951,6954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":316,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":316,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7789,7792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7789,7792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env ts-node\n/**\n * 安全配置管理器\n *\n * 安全原则:\n * 1. 禁止使用正则表达式进行结构化数据处理\n * 2. 使用专门的JSON解析器和类型验证\n * 3. 实现原子操作和完整性检查\n * 4. 提供安全的回滚机制\n *\n * 用途:\n * - 安全地管理配置文件\n * - 提取敏感信息到环境变量\n * - 保持配置文件的完整性\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport crypto from 'crypto';\n\ninterface SecureConfigOptions {\n  backupDir: string;\n  createChecksum: boolean;\n  validateAfterModification: boolean;\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\ninterface BackupInfo {\n  filePath: string;\n  backupPath: string;\n  checksum: string;\n  timestamp: Date;\n}\n\nclass SecureConfigManager {\n  private options: SecureConfigOptions;\n  private backups: Map<string, BackupInfo> = new Map();\n\n  constructor(options: Partial<SecureConfigOptions> = {}) {\n    this.options = {\n      backupDir: 'config/backups',\n      createChecksum: true,\n      validateAfterModification: true,\n      ...options,\n    };\n  }\n\n  /**\n   * 安全地处理agents.json配置\n   */\n  async processAgentsConfig(): Promise<ValidationResult> {\n    const filePath = path.resolve(process.cwd(), 'config/agents.json');\n\n    if (!fs.existsSync(filePath)) {\n      return {\n        valid: false,\n        errors: ['config/agents.json does not exist'],\n        warnings: [],\n      };\n    }\n\n    try {\n      // 1. 创建备份\n      const backupInfo = await this.createSecureBackup(filePath);\n\n      // 2. 使用JSON解析器读取配置\n      const config = this.parseJSONFile(filePath);\n      if (!config) {\n        return {\n          valid: false,\n          errors: ['Failed to parse agents.json'],\n          warnings: [],\n        };\n      }\n\n      // 3. 类型安全的配置处理\n      const result = await this.processAgentsConfigSecurely(config);\n\n      if (result.modified) {\n        // 4. 验证修改后的配置\n        const validationResult = this.validateAgentsConfig(result.config);\n        if (!validationResult.valid) {\n          await this.restoreFromBackup(filePath);\n          return validationResult;\n        }\n\n        // 5. 安全写入\n        await this.writeJSONFile(filePath, result.config);\n        console.log('✅ config/agents.json processed successfully');\n      }\n\n      return {\n        valid: true,\n        errors: [],\n        warnings: result.warnings,\n      };\n\n    } catch (error) {\n      return {\n        valid: false,\n        errors: [`Processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`],\n        warnings: [],\n      };\n    }\n  }\n\n  /**\n   * 创建安全备份\n   */\n  private async createSecureBackup(filePath: string): Promise<BackupInfo> {\n    await this.ensureBackupDirectory();\n\n    const timestamp = new Date();\n    const fileName = path.basename(filePath);\n    const backupPath = path.join(\n      this.options.backupDir,\n      `${fileName}.${timestamp.toISOString().replace(/[:.]/g, '-')}.backup`,\n    );\n\n    // 读取原文件并计算校验和\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const checksum = this.calculateChecksum(content);\n\n    // 创建备份信息\n    const backupInfo: BackupInfo = {\n      filePath,\n      backupPath,\n      checksum,\n      timestamp,\n    };\n\n    // 写入备份文件\n    const fullBackupPath = path.resolve(process.cwd(), backupPath);\n    fs.writeFileSync(fullBackupPath, content, 'utf-8');\n\n    // 保存备份信息\n    this.backups.set(filePath, backupInfo);\n\n    console.log(`📦 Secure backup created: ${backupPath}`);\n    return backupInfo;\n  }\n\n  /**\n   * 使用JSON解析器安全读取文件\n   */\n  private parseJSONFile(filePath: string): any {\n    try {\n      const content = fs.readFileSync(filePath, 'utf-8');\n      return JSON.parse(content);\n    } catch (error) {\n      console.error(`❌ Failed to parse JSON file ${filePath}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * 安全处理agents配置\n   */\n  private async processAgentsConfigSecurely(config: any): Promise<{\n    config: any;\n    modified: boolean;\n    warnings: string[];\n  }> {\n    const result = {\n      config: JSON.parse(JSON.stringify(config)), // 深拷贝\n      modified: false,\n      warnings: [] as string[],\n    };\n\n    if (!config.agents || !Array.isArray(config.agents)) {\n      result.warnings.push('Invalid agents configuration structure');\n      return result;\n    }\n\n    for (let i = 0; i < config.agents.length; i++) {\n      const agent = config.agents[i];\n\n      // 验证agent结构\n      if (!this.validateAgentStructure(agent)) {\n        result.warnings.push(`Invalid agent structure at index ${i}`);\n        continue;\n      }\n\n      // 安全处理API Key\n      if (agent.apiKey && typeof agent.apiKey === 'string' && !agent.apiKey.startsWith('${')) {\n        if (!this.isValidApiKey(agent.apiKey)) {\n          result.warnings.push(`Invalid API key format for agent at index ${i}`);\n          continue;\n        }\n\n        result.config.agents[i].apiKey = `\\${FASTGPT_API_KEY_${i + 1}}`;\n        result.modified = true;\n      }\n\n      // 安全处理App ID\n      if (agent.appId && typeof agent.appId === 'string' && !agent.appId.startsWith('${')) {\n        result.config.agents[i].appId = `\\${FASTGPT_APP_ID_${i + 1}}`;\n        result.modified = true;\n      }\n\n      // 安全处理Endpoint\n      if (agent.endpoint && typeof agent.endpoint === 'string' && !agent.endpoint.startsWith('${')) {\n        const normalizedEndpoint = this.normalizeEndpoint(agent.endpoint);\n        if (normalizedEndpoint) {\n          result.config.agents[i].endpoint = '${FASTGPT_ENDPOINT}/chat/completions';\n          result.modified = true;\n        } else {\n          result.warnings.push(`Invalid endpoint for agent at index ${i}`);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * 验证agent结构\n   */\n  private validateAgentStructure(agent: any): boolean {\n    return (\n      agent &&\n      typeof agent === 'object' &&\n      typeof agent.id === 'string' &&\n      typeof agent.name === 'string' &&\n      typeof agent.provider === 'string'\n    );\n  }\n\n  /**\n   * 验证API Key格式\n   */\n  private isValidApiKey(apiKey: string): boolean {\n    // 基本的API Key格式验证\n    return (\n      typeof apiKey === 'string' &&\n      apiKey.length >= 10 &&\n      apiKey.length <= 200 &&\n      /^[a-zA-Z0-9\\-_]+$/.test(apiKey)\n    );\n  }\n\n  /**\n   * 标准化Endpoint\n   */\n  private normalizeEndpoint(endpoint: string): string | null {\n    try {\n      const url = new URL(endpoint);\n\n      // 只允许特定域名\n      const allowedHosts = ['api.fastgpt.in', 'localhost', '127.0.0.1'];\n      if (!allowedHosts.includes(url.hostname)) {\n        return null;\n      }\n\n      return `${url.protocol}//${url.host}`;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * 验证agents配置\n   */\n  private validateAgentsConfig(config: any): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    try {\n      // 基本结构验证\n      if (!config || typeof config !== 'object') {\n        errors.push('Invalid config structure');\n        return { valid: false, errors, warnings };\n      }\n\n      if (!Array.isArray(config.agents)) {\n        errors.push('Agents must be an array');\n        return { valid: false, errors, warnings };\n      }\n\n      // 逐个验证agent\n      config.agents.forEach((agent: any, index: number) => {\n        if (!this.validateAgentStructure(agent)) {\n          errors.push(`Invalid agent structure at index ${index}`);\n        }\n\n        // 验证必需字段\n        if (!agent.id || typeof agent.id !== 'string') {\n          errors.push(`Missing or invalid id for agent at index ${index}`);\n        }\n\n        if (!agent.name || typeof agent.name !== 'string') {\n          errors.push(`Missing or invalid name for agent at index ${index}`);\n        }\n      });\n\n      return {\n        valid: errors.length === 0,\n        errors,\n        warnings,\n      };\n\n    } catch (error) {\n      errors.push(`Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return { valid: false, errors, warnings };\n    }\n  }\n\n  /**\n   * 安全写入JSON文件\n   */\n  private async writeJSONFile(filePath: string, config: any): Promise<void> {\n    const content = JSON.stringify(config, null, 2);\n    fs.writeFileSync(filePath, content, 'utf-8');\n  }\n\n  /**\n   * 从备份恢复\n   */\n  private async restoreFromBackup(filePath: string): Promise<void> {\n    const backupInfo = this.backups.get(filePath);\n    if (!backupInfo) {\n      throw new Error('No backup found for restoration');\n    }\n\n    const fullBackupPath = path.resolve(process.cwd(), backupInfo.backupPath);\n    if (!fs.existsSync(fullBackupPath)) {\n      throw new Error(`Backup file not found: ${backupInfo.backupPath}`);\n    }\n\n    const backupContent = fs.readFileSync(fullBackupPath, 'utf-8');\n    const currentChecksum = this.calculateChecksum(backupContent);\n\n    if (currentChecksum !== backupInfo.checksum) {\n      throw new Error('Backup file integrity check failed');\n    }\n\n    fs.writeFileSync(filePath, backupContent, 'utf-8');\n    console.log(`🔄 Restored from backup: ${backupInfo.backupPath}`);\n  }\n\n  /**\n   * 计算文件校验和\n   */\n  private calculateChecksum(content: string): string {\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  /**\n   * 确保备份目录存在\n   */\n  private async ensureBackupDirectory(): Promise<void> {\n    const dir = path.resolve(process.cwd(), this.options.backupDir);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n  }\n\n  /**\n   * 生成安全报告\n   */\n  generateReport(): void {\n    console.log('\\n' + '='.repeat(60));\n    console.log('🛡️ 安全配置管理报告');\n    console.log('='.repeat(60) + '\\n');\n\n    console.log('✅ 配置处理完成，遵循安全原则:\\n');\n\n    console.log('🔒 安全措施:');\n    console.log('   - 禁止使用正则表达式进行结构化数据处理');\n    console.log('   - 使用类型安全的JSON解析器');\n    console.log('   - 实现完整性校验和原子操作');\n    console.log('   - 提供安全的备份和回滚机制\\n');\n\n    console.log('📁 备份文件:');\n    for (const [filePath, backupInfo] of this.backups) {\n      console.log(`   ${filePath} -> ${backupInfo.backupPath}`);\n      console.log(`   校验和: ${backupInfo.checksum.substring(0, 16)}...`);\n    }\n    console.log();\n\n    console.log('⚠️ 重要提醒:');\n    console.log('   - 备份文件包含敏感信息，请妥善保管');\n    console.log('   - 建议在生产环境中使用环境变量管理');\n    console.log('   - 定期轮换API密钥和敏感配置\\n');\n\n    console.log('='.repeat(60) + '\\n');\n  }\n}\n\n// 主执行函数\nasync function main() {\n  const manager = new SecureConfigManager();\n\n  try {\n    console.log('🛡️ 开始安全配置处理...\\n');\n\n    const result = await manager.processAgentsConfig();\n\n    if (result.valid) {\n      console.log('✅ 配置处理成功完成');\n      if (result.warnings.length > 0) {\n        console.log('\\n⚠️ 警告:');\n        result.warnings.forEach(warning => console.log(`   - ${warning}`));\n      }\n    } else {\n      console.log('❌ 配置处理失败');\n      result.errors.forEach(error => console.log(`   - ${error}`));\n      process.exit(1);\n    }\n\n    manager.generateReport();\n\n  } catch (error) {\n    console.error('❌ 安全配置处理失败:', error);\n    process.exit(1);\n  }\n}\n\n// 仅当直接运行时执行\nif (require.main === module) {\n  main();\n}\n\nexport { SecureConfigManager };","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/scripts/typeSafetyEnhancer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceFile' is defined but never used. Allowed unused args must match /^_/u.","line":184,"column":63,"nodeType":"Identifier","messageId":"unusedVar","endLine":184,"endColumn":88}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env ts-node\n\n/**\n * Type Safety Enhancement Script\n *\n * This script automatically enhances type safety by:\n * 1. Replacing common 'any' usages with proper types\n * 2. Adding missing type annotations\n * 3. Suggesting improvements for complex type patterns\n *\n * Usage: ts-node src/scripts/typeSafetyEnhancer.ts [--dry-run] [--fix]\n */\n\nimport * as ts from 'typescript';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface TypeSafetyIssue {\n  file: string;\n  line: number;\n  column: number;\n  type: 'any_usage' | 'missing_type' | 'unsafe_assertion' | 'complex_type';\n  description: string;\n  suggestion: string;\n  severity: 'error' | 'warning' | 'info';\n  code: string;\n}\n\ninterface EnhancementResult {\n  issues: TypeSafetyIssue[];\n  fixed: number;\n  errors: string[];\n}\n\nclass TypeSafetyEnhancer {\n  private program: ts.Program;\n  private checker: ts.TypeChecker;\n  private issues: TypeSafetyIssue[] = [];\n  private dryRun: boolean = true;\n\n  constructor(configPath: string) {\n    const config = ts.readConfigFile(configPath, ts.sys.readFile);\n    const parsedConfig = ts.parseJsonConfigFileContent(config.config, ts.sys, path.dirname(configPath));\n\n    this.program = ts.createProgram(\n      parsedConfig.fileNames,\n      parsedConfig.options,\n    );\n    this.checker = this.program.getTypeChecker();\n  }\n\n  /**\n   * Analyze all source files for type safety issues\n   */\n  public analyze(options: { dryRun?: boolean } = {}): EnhancementResult {\n    this.dryRun = options.dryRun !== false;\n    this.issues = [];\n\n    const sourceFiles = this.program.getSourceFiles()\n      .filter(file => !file.isDeclarationFile && file.fileName.endsWith('.ts'));\n\n    for (const sourceFile of sourceFiles) {\n      this.analyzeSourceFile(sourceFile);\n    }\n\n    // Sort issues by severity and file\n    this.issues.sort((a, b) => {\n      const severityOrder = { error: 0, warning: 1, info: 2 };\n      if (severityOrder[a.severity] !== severityOrder[b.severity]) {\n        return severityOrder[a.severity] - severityOrder[b.severity];\n      }\n      return a.file.localeCompare(b.file);\n    });\n\n    return {\n      issues: this.issues,\n      fixed: 0,\n      errors: [],\n    };\n  }\n\n  /**\n   * Analyze a single source file\n   */\n  private analyzeSourceFile(sourceFile: ts.SourceFile): void {\n    ts.forEachChild(sourceFile, (node) => {\n      this.analyzeNode(node, sourceFile);\n    });\n  }\n\n  /**\n   * Analyze a TypeScript node for type safety issues\n   */\n  private analyzeNode(node: ts.Node, sourceFile: ts.SourceFile): void {\n    // Check for 'any' type usage\n    if (node.kind === ts.SyntaxKind.AnyKeyword) {\n      this.addIssue({\n        file: sourceFile.fileName,\n        line: sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1,\n        column: sourceFile.getLineAndCharacterOfPosition(node.getStart()).character,\n        type: 'any_usage',\n        description: 'Using \"any\" type reduces type safety',\n        suggestion: this.suggestAnyReplacement(node, sourceFile),\n        severity: 'warning',\n        code: node.getText(),\n      });\n    }\n\n    // Check for missing return type annotations\n    if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) || ts.isArrowFunction(node)) {\n      if (!node.type) {\n        this.addIssue({\n          file: sourceFile.fileName,\n          line: sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1,\n          column: sourceFile.getLineAndCharacterOfPosition(node.getStart()).character,\n          type: 'missing_type',\n          description: 'Function missing return type annotation',\n          suggestion: this.suggestReturnType(node, sourceFile),\n          severity: 'info',\n          code: node.getText(),\n        });\n      }\n    }\n\n    // Check for unsafe type assertions\n    if (node.kind === ts.SyntaxKind.AsExpression) {\n      const asExpression = node as ts.AsExpression;\n      if (asExpression.type.kind === ts.SyntaxKind.AnyKeyword) {\n        this.addIssue({\n          file: sourceFile.fileName,\n          line: sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1,\n          column: sourceFile.getLineAndCharacterOfPosition(node.getStart()).character,\n          type: 'unsafe_assertion',\n          description: 'Unsafe type assertion to \"any\"',\n          suggestion: 'Replace with proper type or type guard',\n          severity: 'error',\n          code: node.getText(),\n        });\n      }\n    }\n\n    // Recursively analyze child nodes\n    ts.forEachChild(node, (child) => this.analyzeNode(child, sourceFile));\n  }\n\n  /**\n   * Suggest replacement for 'any' type usage\n   */\n  private suggestAnyReplacement(node: ts.Node, sourceFile: ts.SourceFile): string {\n    const parent = node.parent;\n\n    if (!parent) {\n      return 'Replace with specific type like string, number, or interface';\n    }\n\n    // Check if it's a function parameter\n    if (ts.isParameter(parent) && parent.name.kind === ts.SyntaxKind.Identifier) {\n      const paramName = parent.name.text;\n      return `Replace 'any' with specific type for parameter '${paramName}'`;\n    }\n\n    // Check if it's a variable declaration\n    if (ts.isVariableDeclaration(parent)) {\n      const varName = parent.name.getText(sourceFile);\n      return `Replace 'any' with specific type for variable '${varName}'`;\n    }\n\n    // Check if it's a function return type\n    if (ts.isFunctionDeclaration(parent) || ts.isMethodDeclaration(parent) || ts.isArrowFunction(parent)) {\n      return 'Replace with specific return type like Promise<T> or specific interface';\n    }\n\n    // Check if it's in array/object context\n    if (ts.isArrayTypeNode(parent?.parent) || ts.isTypeReferenceNode(parent?.parent)) {\n      return 'Replace with specific type like Array<T> or interface';\n    }\n\n    return 'Replace with specific type based on usage context';\n  }\n\n  /**\n   * Suggest return type for functions\n   */\n  private suggestReturnType(node: ts.FunctionLikeDeclaration, sourceFile: ts.SourceFile): string {\n    // Try to infer the return type from the function body\n    if (node.body) {\n      // Simple heuristic: look for return statements\n      const returnStatements = this.findReturnStatements(node.body);\n      if (returnStatements.length > 0) {\n        const returnTypes = returnStatements.map(stmt => {\n          if (stmt.expression) {\n            return this.inferExpressionType(stmt.expression);\n          }\n          return 'void';\n        });\n\n        const uniqueTypes = [...new Set(returnTypes)];\n        if (uniqueTypes.length === 1) {\n          return `Add explicit return type: ${uniqueTypes[0]}`;\n        } else if (uniqueTypes.length > 1) {\n          return `Add explicit return type (multiple possibilities detected): ${uniqueTypes.join(' | ')}`;\n        }\n      }\n    }\n\n    return 'Add explicit return type annotation (e.g., : void, : string, : Promise<T>)';\n  }\n\n  /**\n   * Find all return statements in a function body\n   */\n  private findReturnStatements(node: ts.Node): ts.ReturnStatement[] {\n    const returns: ts.ReturnStatement[] = [];\n\n    function visit(n: ts.Node) {\n      if (ts.isReturnStatement(n)) {\n        returns.push(n);\n      }\n      ts.forEachChild(n, visit);\n    }\n\n    visit(node);\n    return returns;\n  }\n\n  /**\n   * Infer type of an expression\n   */\n  private inferExpressionType(expr: ts.Expression): string {\n    const type = this.checker.getTypeAtLocation(expr);\n    const typeString = this.checker.typeToString(type);\n\n    if (typeString === 'any') {\n      // Try to provide a better suggestion\n      if (ts.isStringLiteral(expr)) {\n        return 'string';\n      } else if (ts.isNumericLiteral(expr)) {\n        return 'number';\n      } else if (expr.kind === ts.SyntaxKind.TrueKeyword || expr.kind === ts.SyntaxKind.FalseKeyword) {\n        return 'boolean';\n      } else if (ts.isArrayLiteralExpression(expr)) {\n        return `Array<${this.inferArrayType(expr)}>`;\n      } else if (ts.isObjectLiteralExpression(expr)) {\n        return '{ [key: string]: unknown }';\n      }\n    }\n\n    return typeString;\n  }\n\n  /**\n   * Infer array element type\n   */\n  private inferArrayType(arrayLiteral: ts.ArrayLiteralExpression): string {\n    if (arrayLiteral.elements.length > 0) {\n      const firstElement = arrayLiteral.elements[0];\n      if (firstElement && ts.isExpression(firstElement)) {\n        return this.inferExpressionType(firstElement);\n      }\n    }\n    return 'unknown';\n  }\n\n  /**\n   * Add an issue to the list\n   */\n  private addIssue(issue: TypeSafetyIssue): void {\n    this.issues.push(issue);\n  }\n\n  /**\n   * Generate a comprehensive report\n   */\n  public generateReport(): string {\n    const report: string[] = [];\n\n    report.push('# Type Safety Analysis Report');\n    report.push(`Generated: ${new Date().toISOString()}`);\n    report.push('');\n\n    // Summary\n    const summary = this.generateSummary();\n    report.push('## Summary');\n    report.push(`- Total Issues: ${summary.total}`);\n    report.push(`- Errors: ${summary.errors}`);\n    report.push(`- Warnings: ${summary.warnings}`);\n    report.push(`- Info: ${summary.info}`);\n    report.push('');\n\n    // Issues by type\n    const byType = this.groupIssuesByType();\n    for (const [type, issues] of Object.entries(byType)) {\n      if (issues.length > 0) {\n        report.push(`## ${this.formatIssueType(type)} (${issues.length})`);\n\n        for (const issue of issues) {\n          report.push(`### ${issue.severity.toUpperCase()}: ${path.basename(issue.file)}:${issue.line}:${issue.column}`);\n          report.push(`**Description:** ${issue.description}`);\n          report.push(`**Suggestion:** ${issue.suggestion}`);\n          report.push(`**Code:** \\`${issue.code}\\``);\n          report.push('');\n        }\n      }\n    }\n\n    // Recommendations\n    report.push('## Recommendations');\n    report.push(this.generateRecommendations());\n    report.push('');\n\n    return report.join('\\n');\n  }\n\n  /**\n   * Generate summary statistics\n   */\n  public generateSummary() {\n    return {\n      total: this.issues.length,\n      errors: this.issues.filter(i => i.severity === 'error').length,\n      warnings: this.issues.filter(i => i.severity === 'warning').length,\n      info: this.issues.filter(i => i.severity === 'info').length,\n    };\n  }\n\n  /**\n   * Group issues by type\n   */\n  private groupIssuesByType(): Record<string, TypeSafetyIssue[]> {\n    const grouped: Record<string, TypeSafetyIssue[]> = {};\n\n    for (const issue of this.issues) {\n      if (!grouped[issue.type]) {\n        grouped[issue.type] = [];\n      }\n      grouped[issue.type]!.push(issue);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Format issue type for display\n   */\n  private formatIssueType(type: string): string {\n    return type.split('_').map(word =>\n      word.charAt(0).toUpperCase() + word.slice(1),\n    ).join(' ');\n  }\n\n  /**\n   * Generate improvement recommendations\n   */\n  private generateRecommendations(): string {\n    const recommendations: string[] = [];\n\n    const anyCount = this.issues.filter(i => i.type === 'any_usage').length;\n    const missingTypeCount = this.issues.filter(i => i.type === 'missing_type').length;\n    const unsafeAssertionCount = this.issues.filter(i => i.type === 'unsafe_assertion').length;\n\n    if (anyCount > 0) {\n      recommendations.push(`1. **Eliminate 'any' types** (${anyCount} issues found): Replace with specific types or use unknown with type guards`);\n    }\n\n    if (missingTypeCount > 0) {\n      recommendations.push(`2. **Add explicit type annotations** (${missingTypeCount} issues found): Improve code documentation and catch type errors early`);\n    }\n\n    if (unsafeAssertionCount > 0) {\n      recommendations.push(`3. **Fix unsafe type assertions** (${unsafeAssertionCount} issues found): Use type guards or proper type checking`);\n    }\n\n    recommendations.push('4. **Enable strict TypeScript mode**: Set strict: true in tsconfig.json');\n    recommendations.push('5. **Use type guards**: Implement proper type checking for unknown data');\n    recommendations.push('6. **Prefer interfaces over object literals**: Define clear contracts for data structures');\n\n    return recommendations.join('\\n');\n  }\n}\n\n// CLI interface\nfunction main() {\n  const args = process.argv.slice(2);\n  const dryRun = !args.includes('--fix');\n\n  console.log('🔍 Type Safety Enhancement Tool');\n  console.log(`Mode: ${dryRun ? 'Dry Run' : 'Fix Mode'}`);\n  console.log('');\n\n  const configPath = path.join(process.cwd(), 'tsconfig.json');\n\n  if (!fs.existsSync(configPath)) {\n    console.error('❌ tsconfig.json not found');\n    process.exit(1);\n  }\n\n  const enhancer = new TypeSafetyEnhancer(configPath);\n\n  console.log('📊 Analyzing project...');\n  const result = enhancer.analyze({ dryRun });\n\n  console.log(`Found ${result.issues.length} type safety issues`);\n  console.log('');\n\n  // Display summary\n  const summary = enhancer.generateSummary();\n  console.log('📈 Summary:');\n  console.log(`   Errors: ${summary.errors}`);\n  console.log(`   Warnings: ${summary.warnings}`);\n  console.log(`   Info: ${summary.info}`);\n  console.log('');\n\n  // Generate report\n  const report = enhancer.generateReport();\n  const reportPath = path.join(process.cwd(), 'type-safety-report.md');\n\n  if (dryRun) {\n    console.log('📝 Generating detailed report...');\n    fs.writeFileSync(reportPath, report);\n    console.log(`✅ Report saved to: ${reportPath}`);\n  } else {\n    console.log('🔧 Fix mode not implemented yet');\n    console.log('📝 Generating detailed report instead...');\n    fs.writeFileSync(reportPath, report);\n    console.log(`✅ Report saved to: ${reportPath}`);\n  }\n\n  // Exit with error code if there are error-level issues\n  if (summary.errors > 0) {\n    process.exit(1);\n  }\n}\n\nif (require.main === module) {\n  main();\n}\n\nexport { TypeSafetyEnhancer, TypeSafetyIssue, EnhancementResult };","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/scripts/validate-env.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1619,1622],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1619,1622],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4938,4941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4938,4941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":315,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8333,8336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8333,8336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env ts-node\n/**\n * 环境变量配置验证脚本\n *\n * 用途:\n * - 启动前验证所有必需的环境变量\n * - 检查配置文件中的占位符是否都有对应环境变量\n * - 验证配置值的合法性\n *\n * 使用:\n * npm run validate:env\n * 或\n * ts-node backend/src/scripts/validate-env.ts\n */\n\n// 加载环境变量\nimport dotenv from 'dotenv';\nimport path from 'path';\n\n// 加载.env文件\nconst envPath = path.resolve(__dirname, '../../.env');\ndotenv.config({ path: envPath });\n\nimport { EnvManager } from '../config/EnvManager';\nimport fs from 'fs';\n\ninterface ValidationResult {\n  passed: boolean;\n  errors: Array<string>;\n  warnings: Array<string>;\n  info: Array<string>;\n}\n\nclass EnvValidator {\n  private result: ValidationResult = {\n    passed: true,\n    errors: [],\n    warnings: [],\n    info: [],\n  };\n\n  /**\n   * 执行完整验证\n   */\n  async validate(): Promise<ValidationResult> {\n    console.log('🔍 开始环境变量验证...\\n');\n\n    // 1. 验证EnvManager初始化\n    this.validateEnvManager();\n\n    // 2. 验证必需的环境变量\n    this.validateRequiredVars();\n\n    // 3. 验证推荐的环境变量\n    this.validateRecommendedVars();\n\n    // 4. 验证配置文件占位符\n    await this.validateConfigPlaceholders();\n\n    // 5. 验证配置值合法性\n    this.validateConfigValues();\n\n    // 6. 生成报告\n    this.generateReport();\n\n    return this.result;\n  }\n\n  /**\n   * 验证EnvManager初始化\n   */\n  private validateEnvManager(): void {\n    try {\n      const envManager = EnvManager.getInstance();\n      const stats = envManager.getStats();\n\n      this.result.info.push(\n        `✅ EnvManager初始化成功 (总计${stats.total}个变量)`,\n      );\n\n      if (stats.missing > 0) {\n        this.result.errors.push(\n          `❌ 缺少${stats.missing}个必需环境变量`,\n        );\n        this.result.passed = false;\n      }\n    } catch (error: any) {\n      this.result.errors.push(`❌ EnvManager初始化失败: ${error.message}`);\n      this.result.passed = false;\n    }\n  }\n\n  /**\n   * 验证必需的环境变量\n   */\n  private validateRequiredVars(): void {\n    const envManager = EnvManager.getInstance();\n\n    const requiredVars = [\n      { key: 'TOKEN_SECRET', minLength: 32, description: 'JWT Token密钥' },\n      { key: 'DB_HOST', minLength: 1, description: '数据库主机' },\n      { key: 'DB_PORT', minLength: 1, description: '数据库端口' },\n      { key: 'DB_USER', minLength: 1, description: '数据库用户名' },\n      { key: 'DB_PASSWORD', minLength: 1, description: '数据库密码' },\n      { key: 'DB_NAME', minLength: 1, description: '数据库名称' },\n    ];\n\n    for (const { key, minLength, description } of requiredVars) {\n      if (!envManager.has(key)) {\n        this.result.errors.push(`❌ 缺少必需变量: ${key} (${description})`);\n        this.result.passed = false;\n      } else {\n        const value = envManager.get(key);\n        if (value.length < minLength) {\n          this.result.errors.push(\n            `❌ ${key} 长度不足 (需要至少${minLength}字符)`,\n          );\n          this.result.passed = false;\n        } else {\n          this.result.info.push(`✅ ${key}: ${description} - OK`);\n        }\n      }\n    }\n  }\n\n  /**\n   * 验证推荐的环境变量\n   */\n  private validateRecommendedVars(): void {\n    const envManager = EnvManager.getInstance();\n\n    const recommendedVars = [\n      { key: 'REDIS_HOST', description: 'Redis主机 (Token存储)', impact: '单实例部署可用，多实例需Redis' },\n      { key: 'REDIS_PORT', description: 'Redis端口', impact: '同上' },\n      { key: 'FASTGPT_API_KEY_1', description: 'FastGPT API密钥', impact: 'FastGPT智能体不可用' },\n      { key: 'FRONTEND_URL', description: '前端URL', impact: 'CORS配置可能不正确' },\n      { key: 'LOG_LEVEL', description: '日志级别', impact: '使用默认info级别' },\n    ];\n\n    for (const { key, description, impact } of recommendedVars) {\n      if (!envManager.has(key)) {\n        this.result.warnings.push(\n          `⚠️  推荐配置 ${key} 未设置\\n   说明: ${description}\\n   影响: ${impact}`,\n        );\n      } else {\n        this.result.info.push(`✅ ${key}: ${description} - OK`);\n      }\n    }\n  }\n\n  /**\n   * 验证配置文件中的占位符\n   */\n  private async validateConfigPlaceholders(): Promise<void> {\n    const configFiles = [\n      '../config/agents.json',\n      '../config/config.jsonc',\n    ];\n\n    for (const file of configFiles) {\n      const filePath = path.resolve(process.cwd(), file);\n\n      if (!fs.existsSync(filePath)) {\n        this.result.warnings.push(`⚠️  配置文件不存在: ${file}`);\n        continue;\n      }\n\n      try {\n        const content = fs.readFileSync(filePath, 'utf-8');\n        const placeholders = this.extractPlaceholders(content);\n\n        if (placeholders.length > 0) {\n          this.result.info.push(`\\n📄 ${file} 中的占位符:`);\n\n          const envManager = EnvManager.getInstance();\n          for (const placeholder of placeholders) {\n            if (!envManager.has(placeholder)) {\n              this.result.errors.push(\n                `❌ 占位符 \\${${placeholder}} 在 ${file} 中使用但环境变量未设置`,\n              );\n              this.result.passed = false;\n            } else {\n              this.result.info.push(`   ✅ \\${${placeholder}} - 已设置`);\n            }\n          }\n        } else {\n          this.result.warnings.push(\n            `⚠️  ${file} 中未找到环境变量占位符 (可能已硬编码敏感信息)`,\n          );\n        }\n      } catch (error: any) {\n        this.result.errors.push(`❌ 读取配置文件失败 ${file}: ${error.message}`);\n        this.result.passed = false;\n      }\n    }\n  }\n\n  /**\n   * 验证配置值合法性\n   */\n  private validateConfigValues(): void {\n    const envManager = EnvManager.getInstance();\n\n    // 验证端口号\n    const port = envManager.getInt('PORT', 3001);\n    if (port < 1 || port > 65535) {\n      this.result.errors.push(`❌ PORT 值不合法: ${port} (应在1-65535之间)`);\n      this.result.passed = false;\n    } else {\n      this.result.info.push(`✅ PORT: ${port} - OK`);\n    }\n\n    // 验证数据库端口\n    const dbPort = envManager.getInt('DB_PORT', 5432);\n    if (dbPort < 1 || dbPort > 65535) {\n      this.result.errors.push(`❌ DB_PORT 值不合法: ${dbPort}`);\n      this.result.passed = false;\n    } else {\n      this.result.info.push(`✅ DB_PORT: ${dbPort} - OK`);\n    }\n\n    // 验证NODE_ENV\n    const nodeEnv = envManager.getEnvironment();\n    const validEnvs = ['development', 'production', 'test'];\n    if (!validEnvs.includes(nodeEnv)) {\n      this.result.warnings.push(\n        `⚠️  NODE_ENV 值不标准: ${nodeEnv} (推荐: ${validEnvs.join('/')})`,\n      );\n    } else {\n      this.result.info.push(`✅ NODE_ENV: ${nodeEnv} - OK`);\n    }\n\n    // 验证TOKEN_SECRET强度 (生产环境)\n    if (envManager.isProduction()) {\n      const tokenSecret = envManager.get('TOKEN_SECRET');\n      if (tokenSecret.includes('change-in-production')) {\n        this.result.errors.push(\n          '❌ TOKEN_SECRET 使用默认值，生产环境必须修改！',\n        );\n        this.result.passed = false;\n      }\n    }\n  }\n\n  /**\n   * 提取配置文件中的环境变量占位符\n   */\n  private extractPlaceholders(content: string): string[] {\n    const matches = content.match(/\\$\\{([^}]+)\\}/g);\n    if (!matches) {\n      return [];\n    }\n\n    const placeholders = matches.map(match => match.slice(2, -1));\n    return [...new Set(placeholders)]; // 去重\n  }\n\n  /**\n   * 生成验证报告\n   */\n  private generateReport(): void {\n    console.log('\\n' + '='.repeat(60));\n    console.log('📊 环境变量验证报告');\n    console.log('='.repeat(60) + '\\n');\n\n    // 错误\n    if (this.result.errors.length > 0) {\n      console.log('❌ 错误 (' + this.result.errors.length + '):\\n');\n      this.result.errors.forEach(error => console.log(error));\n      console.log();\n    }\n\n    // 警告\n    if (this.result.warnings.length > 0) {\n      console.log('⚠️  警告 (' + this.result.warnings.length + '):\\n');\n      this.result.warnings.forEach(warning => console.log(warning));\n      console.log();\n    }\n\n    // 信息\n    if (this.result.info.length > 0 && process.env.VERBOSE === 'true') {\n      console.log('ℹ️  详细信息:\\n');\n      this.result.info.forEach(info => console.log(info));\n      console.log();\n    }\n\n    // 总结\n    console.log('='.repeat(60));\n    if (this.result.passed) {\n      console.log('✅ 验证通过！所有必需的环境变量已正确配置。');\n      if (this.result.warnings.length > 0) {\n        console.log(`   (有${this.result.warnings.length}个警告，建议修复)`);\n      }\n    } else {\n      console.log('❌ 验证失败！请修复上述错误后重试。');\n      console.log('\\n💡 提示:');\n      console.log('   1. 检查 backend/.env 文件是否存在');\n      console.log('   2. 参考 backend/ENV_TEMPLATE.txt 补充缺失配置');\n      console.log('   3. 确保所有敏感信息已从配置文件移至.env');\n    }\n    console.log('='.repeat(60) + '\\n');\n  }\n}\n\n// 执行验证\nasync function main() {\n  console.log('🚀 启动环境变量验证脚本...');\n\n  try {\n    const validator = new EnvValidator();\n    const result = await validator.validate();\n\n    // 退出码: 0=成功, 1=失败\n    process.exit(result.passed ? 0 : 1);\n  } catch (error: any) {\n    console.error('\\n❌ 验证过程发生严重错误:');\n    console.error(error.message);\n    if (error.stack) {\n      console.error('\\n堆栈跟踪:');\n      console.error(error.stack);\n    }\n    process.exit(1);\n  }\n}\n\n// 立即执行（不检查模块状态）\nmain().catch(error => {\n  console.error('❌ 脚本启动失败:', error);\n  process.exit(1);\n});\n\nexport { EnvValidator };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/AgentConfigService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'validateRequiredEnvVars' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":384,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":384,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10428,10431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10428,10431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":438,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":438,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12123,12126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12123,12126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":441,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12237,12240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12237,12240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":553,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":553,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15631,15634],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15631,15634],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":554,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":554,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15707,15710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15707,15710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":771,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":771,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22252,22255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22252,22255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":772,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":772,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22274,22277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22274,22277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":810,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":810,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23388,23391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23388,23391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":811,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":811,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23410,23413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23410,23413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1045,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1045,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29423,29426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29423,29426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs/promises';\nimport path from 'path';\nimport { AgentConfig, Agent, AgentStatus, AgentHealthStatus, JsonValue } from '@/types';\nimport { withClient } from '@/utils/db';\nimport { generateId } from '@/utils/helpers';\nimport {\n  deepReplaceEnvVariables,\n  validateRequiredEnvVars,\n  containsUnresolvedPlaceholders,\n} from '@/utils/envHelper';\nimport logger from '@/utils/logger';\nimport { ResourceError, ValidationError } from '@/types/errors';\n\ntype AgentSeed = {\n  id: string;\n  name: string;\n  description: string;\n  endpoint: string;\n  apiKey: string;\n  model: string;\n  provider: AgentConfig['provider'];\n  capabilities?: string[];\n  isActive?: boolean;\n  features?: Partial<AgentConfig['features']>;\n};\n\ntype AgentDbRow = {\n  id: string;\n  name: string;\n  description: string | null;\n  provider: AgentConfig['provider'];\n  endpoint: string;\n  api_key: string;\n  app_id: string | null;\n  model: string;\n  max_tokens: number | null;\n  temperature: number | null;\n  system_prompt: string | null;\n  capabilities: JsonValue | null;      // 明确JSON类型，替代any\n  rate_limit: JsonValue | null;         // 配置结构，替代any\n  features: JsonValue | null;           // 特性配置，替代any\n  metadata: JsonValue | null;           // 元数据，替代any\n  is_active: boolean;\n  created_at: Date | string;\n  updated_at: Date | string;\n};\n\nexport interface AgentMutationInput {\n  id?: string;\n  name: string;\n  description?: string;\n  provider: AgentConfig['provider'];\n  endpoint: string;\n  apiKey: string;\n  appId?: string;\n  model: string;\n  maxTokens?: number;\n  temperature?: number;\n  systemPrompt?: string;\n  capabilities?: string[];\n  rateLimit?: AgentConfig['rateLimit'];\n  features?: AgentConfig['features'];\n  isActive?: boolean;\n}\n\n/**\n * 智能体配置服务\n * 负责加载、管理和验证智能体配置\n */\nexport class AgentConfigService {\n  private configPath: string;\n  private agents: Map<string, AgentConfig> = new Map();\n  private lastLoadTime: number = 0;\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5分钟缓存\n  private loadingPromise: Promise<AgentConfig[]> | null = null;\n  private snapshotWriting = false;\n  private readonly builtinSeeds: AgentSeed[] = [\n    {\n      id: 'product-scene-preview',\n      name: '产品现场预览 (示例)',\n      description: '演示用智能体，请在后台完成正式配置并更新端点/密钥。',\n      endpoint: 'https://example.com/agents/product-preview',\n      apiKey: 'demo-api-key',\n      model: 'demo-product-model',\n      provider: 'custom',\n      capabilities: ['scene-preview', 'image-compose'],\n      isActive: false,\n    },\n    {\n      id: 'voice-conversation-assistant',\n      name: '语音通话助手 (示例)',\n      description: '演示用智能体，需替换为真实语音模型的访问配置。',\n      endpoint: 'https://example.com/agents/voice-call',\n      apiKey: 'demo-api-key',\n      model: 'demo-voice-model',\n      provider: 'custom',\n      capabilities: ['speech-to-text', 'text-to-speech'],\n      isActive: false,\n      features: {\n        supportsStream: true,\n        supportsDetail: true,\n        streamingConfig: {\n          enabled: true,\n          endpoint: 'same' as const,\n          statusEvents: true,\n          flowNodeStatus: false,\n        },\n      },\n    },\n  ];\n\n  constructor(configPath?: string) {\n    this.configPath =\n      configPath ||\n      process.env.AGENTS_CONFIG_PATH ||\n      path.join(__dirname, '../../../config/agents.json');\n  }\n\n  /**\n   * 加载智能体配置\n   */\n  async loadAgents(): Promise<AgentConfig[]> {\n    return this.ensureCache();\n  }\n\n  /**\n   * 获取特定智能体配置\n   */\n  async getAgent(id: string): Promise<AgentConfig | null> {\n    await this.ensureCache();\n    return this.agents.get(id) || null;\n  }\n\n  /**\n   * 获取可用的智能体列表（简化版本，用于前端显示）\n   */\n  async getAvailableAgents(): Promise<Agent[]> {\n    const configs = await this.ensureCache();\n\n    return configs\n      .filter((config) => config.isActive)\n      .map((config) => this.transformToAgent(config));\n  }\n\n  /**\n   * 获取所有智能体（包括不可用的）\n   */\n  async getAllAgents(): Promise<Agent[]> {\n    const configs = await this.ensureCache();\n\n    return configs.map((config) => this.transformToAgent(config));\n  }\n\n  /**\n   * 检查智能体健康状态\n   */\n  async checkAgentHealth(id: string): Promise<AgentHealthStatus> {\n    const config = await this.getAgent(id);\n    if (!config) {\n      return {\n        agentId: id,\n        status: 'error',\n        lastChecked: new Date().toISOString(),\n        error: '智能体不存在',\n      };\n    }\n\n    const startTime = Date.now();\n    let status: AgentStatus = 'inactive';\n    let error: string | undefined;\n\n    try {\n      // 这里可以实现具体的健康检查逻辑\n      // 例如发送一个简单的请求到智能体端点\n      if (config.isActive) {\n        status = 'active';\n      }\n    } catch (err) {\n      status = 'error';\n      error = err instanceof Error ? err.message : '健康检查失败';\n    }\n\n    const result: AgentHealthStatus = {\n      agentId: id,\n      status,\n      responseTime: Date.now() - startTime,\n      lastChecked: new Date().toISOString(),\n    };\n\n    if (error) {\n      result.error = error;\n    }\n\n    return result;\n  }\n\n  /**\n   * 更新智能体配置\n   */\n  async updateAgent(id: string, updates: Partial<AgentConfig>): Promise<void> {\n    await this.ensureCache();\n    const config = await this.getAgent(id);\n    if (!config) {\n      throw new ResourceError({\n        message: `智能体不存在: ${id}`,\n        code: 'AGENT_NOT_FOUND',\n        resourceType: 'agent',\n        resourceId: id,\n      });\n    }\n\n    const updatedConfig: AgentConfig = {\n      ...config,\n      ...updates,\n      updatedAt: new Date().toISOString(),\n    };\n\n    if (!this.validateAgentConfig(updatedConfig, id)) {\n      throw new ValidationError({\n        message: '更新后的配置验证失败',\n        code: 'INVALID_AGENT_CONFIG',\n        field: 'agentConfig',\n      });\n    }\n\n    await this.persistAgent(updatedConfig);\n  }\n\n  async createAgent(input: AgentMutationInput): Promise<AgentConfig> {\n    await this.ensureCache();\n    const id = input.id || generateId().replace(/-/g, '');\n    const now = new Date().toISOString();\n    const baseFeatures = this.ensureFeatureDefaults(input.features);\n\n    const config: AgentConfig = {\n      id,\n      name: input.name,\n      description: input.description || '',\n      endpoint: input.endpoint,\n      apiKey: input.apiKey,\n      model: input.model,\n      capabilities: input.capabilities ?? [],\n      provider: input.provider,\n      isActive: input.isActive ?? true,\n      features: baseFeatures,\n      createdAt: now,\n      updatedAt: now,\n      ...(input.appId ? { appId: input.appId } : {}),\n      ...(input.maxTokens !== undefined ? { maxTokens: input.maxTokens } : {}),\n      ...(input.temperature !== undefined\n        ? { temperature: input.temperature }\n        : {}),\n      ...(input.systemPrompt !== undefined\n        ? { systemPrompt: input.systemPrompt }\n        : {}),\n      ...(input.rateLimit ? { rateLimit: input.rateLimit } : {}),\n    };\n\n    if (!this.validateAgentConfig(config)) {\n      throw new ValidationError({\n        message: '智能体配置验证失败',\n        code: 'INVALID_AGENT_CONFIG',\n        field: 'agentConfig',\n      });\n    }\n\n    await this.insertAgent(config);\n    return config;\n  }\n\n  async deleteAgent(id: string): Promise<void> {\n    await this.ensureCache();\n    await withClient(async (client) => {\n      await client.query('DELETE FROM agent_configs WHERE id = $1', [id]);\n    });\n    this.agents.delete(id);\n    await this.writeSnapshotToFile();\n  }\n\n  async importAgents(inputs: AgentMutationInput[]): Promise<AgentConfig[]> {\n    const results: AgentConfig[] = [];\n    for (const input of inputs) {\n      await this.ensureCache();\n      const id = input.id || generateId().replace(/-/g, '');\n      const existed = await this.getAgent(id);\n      if (existed) {\n        await this.updateAgent(id, input as Partial<AgentConfig>);\n        const latest = await this.getAgent(id);\n        if (latest) {\n          results.push(latest);\n        }\n      } else {\n        const created = await this.createAgent({ ...input, id });\n        results.push(created);\n      }\n    }\n    return results;\n  }\n\n  async reloadAgents(): Promise<AgentConfig[]> {\n    this.agents.clear();\n    this.lastLoadTime = 0;\n    return this.ensureCache(true);\n  }\n\n  private async ensureCache(force = false): Promise<AgentConfig[]> {\n    const now = Date.now();\n    if (\n      !force &&\n      this.agents.size > 0 &&\n      now - this.lastLoadTime < this.CACHE_TTL\n    ) {\n      return Array.from(this.agents.values());\n    }\n\n    if (!this.loadingPromise) {\n      this.loadingPromise = this.loadAgentsFromDb()\n        .catch(async (error) => {\n          if (this.isTransientDbError(error)) {\n            logger.warn('[AgentConfigService] 数据库不可用，回退到文件加载', {\n              error: error instanceof Error ? error.message : error,\n            });\n            return this.loadAgentsFromFileOnly();\n          }\n\n          this.agents.clear();\n          this.lastLoadTime = 0;\n          throw error;\n        })\n        .finally(() => {\n          this.loadingPromise = null;\n        });\n    }\n\n    return this.loadingPromise;\n  }\n\n  private isTransientDbError(error: unknown): boolean {\n    if (!error) {\n      return false;\n    }\n    const message = error instanceof Error ? error.message : String(error);\n    return [\n      'DB_NOT_INITIALIZED',\n      'DATABASE_CONFIG_MISSING',\n      'ECONNREFUSED',\n      'ENOTFOUND',\n      'timeout',\n    ].some((token) => message.includes(token));\n  }\n\n  private async loadAgentsFromDb(): Promise<AgentConfig[]> {\n    const rows = await withClient(async (client) => {\n      const result = await client.query<AgentDbRow>(\n        'SELECT * FROM agent_configs ORDER BY created_at ASC',\n      );\n      return result.rows;\n    });\n\n    if (!rows || rows.length === 0) {\n      // 如果数据库为空，尝试从文件加载后写入数据库\n      await this.backfillFromFile();\n      const retryRows = await withClient(async (client) => {\n        const result = await client.query<AgentDbRow>(\n          'SELECT * FROM agent_configs ORDER BY created_at ASC',\n        );\n        return result.rows;\n      });\n      return this.applyCacheFromRows(retryRows);\n    }\n\n    return this.applyCacheFromRows(rows);\n  }\n\n  private async loadAgentsFromFileOnly(): Promise<AgentConfig[]> {\n    try {\n      const raw = await fs.readFile(this.configPath, 'utf-8');\n      const sanitized = this.sanitizeNumericPlaceholders(raw);\n      const parsed = JSON.parse(sanitized);\n      const list = Array.isArray(parsed?.agents) ? parsed.agents : [];\n\n      // 对于示例智能体使用静默模式，不记录环境变量警告\n      const replaced = deepReplaceEnvVariables(list, true) as Array<\n        Partial<AgentConfig> & Record<string, any>\n      >;\n\n      const map = new Map<string, AgentConfig>();\n      const fallbackTimestamp = new Date().toISOString();\n\n      for (const item of replaced) {\n        if (!item) {\n          continue;\n        }\n\n        const config: AgentConfig = {\n          id: String(item.id || ''),\n          name: String(item.name || ''),\n          description: String(item.description || ''),\n          endpoint: String(item.endpoint || ''),\n          apiKey: String(item.apiKey || ''),\n          provider: (item.provider as AgentConfig['provider']) || 'custom',\n          model: String(item.model || 'unknown-model'),\n          capabilities: Array.isArray(item.capabilities)\n            ? item.capabilities\n            : [],\n          isActive: item.isActive ?? true,\n          features: this.ensureFeatureDefaults(\n            item.features,\n          ),\n          createdAt: item.createdAt\n            ? String(item.createdAt)\n            : fallbackTimestamp,\n          updatedAt: item.updatedAt\n            ? String(item.updatedAt)\n            : fallbackTimestamp,\n        };\n\n        const appId = item.appId ? String(item.appId) : undefined;\n        if (appId) {\n          config.appId = appId;\n        }\n\n        if (typeof item.maxTokens === 'number') {\n          config.maxTokens = item.maxTokens;\n        }\n\n        if (typeof item.temperature === 'number') {\n          config.temperature = item.temperature;\n        }\n\n        if (item.systemPrompt) {\n          config.systemPrompt = String(item.systemPrompt);\n        }\n\n        if (item.rateLimit && typeof item.rateLimit === 'object') {\n          config.rateLimit = {\n            requestsPerMinute: Number(\n              (item.rateLimit as any).requestsPerMinute ?? 0,\n            ),\n            tokensPerMinute: Number(\n              (item.rateLimit as any).tokensPerMinute ?? 0,\n            ),\n          };\n        }\n\n        if (!this.validateAgentConfig(config, undefined, map)) {\n          continue;\n        }\n\n        map.set(config.id, config);\n      }\n\n      if (map.size === 0) {\n        logger.warn(\n          '[AgentConfigService] 未能从配置文件加载有效的智能体，使用内置示例配置',\n        );\n        return this.loadDefaultAgentsInMemory();\n      }\n\n      this.agents = map;\n      this.lastLoadTime = Date.now();\n      return Array.from(map.values());\n    } catch (error) {\n      logger.warn('[AgentConfigService] 读取配置文件失败，使用内置示例配置', {\n        error,\n      });\n      return this.loadDefaultAgentsInMemory();\n    }\n  }\n\n  private sanitizeNumericPlaceholders(source: string): string {\n    return source.replace(/:\\s*\\$\\{[^}]+\\}/g, ': 0');\n  }\n\n  private applyCacheFromRows(rows: AgentDbRow[]): AgentConfig[] {\n    this.agents.clear();\n\n    // 确保 rows 是一个数组\n    if (!Array.isArray(rows)) {\n      logger.warn('applyCacheFromRows received non-array data', { rows });\n      return [];\n    }\n\n    const configs = rows.map((row) => this.mapRowToConfig(row));\n    configs.forEach((cfg) => this.agents.set(cfg.id, cfg));\n    this.lastLoadTime = Date.now();\n    return configs;\n  }\n\n  private loadDefaultAgentsInMemory(): AgentConfig[] {\n    const now = new Date().toISOString();\n    const map = new Map<string, AgentConfig>();\n\n    for (const seed of this.builtinSeeds) {\n      const config: AgentConfig = {\n        id: seed.id,\n        name: seed.name,\n        description: seed.description,\n        endpoint: seed.endpoint,\n        apiKey: seed.apiKey,\n        provider: seed.provider,\n        model: seed.model,\n        capabilities: seed.capabilities ?? [],\n        isActive: seed.isActive ?? false,\n        features: this.ensureFeatureDefaults(\n          seed.features as AgentConfig['features'] | undefined,\n        ),\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      if (!this.validateAgentConfig(config, undefined, map)) {\n        continue;\n      }\n\n      map.set(config.id, config);\n    }\n\n    this.agents = map;\n    this.lastLoadTime = Date.now();\n    return Array.from(map.values());\n  }\n\n  private mapRowToConfig(row: AgentDbRow): AgentConfig {\n    const features = this.ensureFeatureDefaults(\n      typeof row.features === 'object' && row.features !== null ? row.features as AgentConfig['features'] : undefined\n    );\n    return {\n      id: row.id,\n      name: row.name,\n      description: row.description || '',\n      endpoint: row.endpoint,\n      apiKey: row.api_key,\n      model: row.model,\n      capabilities: Array.isArray(row.capabilities) ? row.capabilities as string[] : [],\n      provider: row.provider,\n      isActive: row.is_active,\n      features,\n      createdAt: new Date(row.created_at).toISOString(),\n      updatedAt: new Date(row.updated_at).toISOString(),\n      ...(row.app_id ? { appId: row.app_id } : {}),\n      ...(row.max_tokens !== null && row.max_tokens !== undefined\n        ? { maxTokens: row.max_tokens }\n        : {}),\n      ...(row.temperature !== null && row.temperature !== undefined\n        ? { temperature: row.temperature }\n        : {}),\n      ...(row.system_prompt !== null && row.system_prompt !== undefined\n        ? { systemPrompt: row.system_prompt }\n        : {}),\n      ...(row.rate_limit && typeof row.rate_limit === 'object' ? {\n        rateLimit: {\n          requestsPerMinute: (row.rate_limit as any).requestsPerMinute || 60,\n          tokensPerMinute: (row.rate_limit as any).tokensPerMinute || 60000\n        }\n      } : {}),\n    };\n  }\n\n  private ensureFeatureDefaults(\n    features: AgentConfig['features'] | undefined,\n  ): AgentConfig['features'] {\n    const streamingConfig = (features?.streamingConfig ?? {}) as Partial<\n      AgentConfig['features']['streamingConfig']\n    >;\n    return {\n      supportsChatId: features?.supportsChatId ?? true,\n      supportsStream: features?.supportsStream ?? true,\n      supportsDetail: features?.supportsDetail ?? true,\n      supportsFiles: features?.supportsFiles ?? true,\n      supportsImages: features?.supportsImages ?? false,\n      streamingConfig: {\n        enabled: streamingConfig?.enabled ?? true,\n        endpoint: streamingConfig?.endpoint ?? 'same',\n        statusEvents: streamingConfig?.statusEvents ?? true,\n        flowNodeStatus: streamingConfig?.flowNodeStatus ?? true,\n      },\n    };\n  }\n\n  private async persistAgent(config: AgentConfig): Promise<void> {\n    await withClient(async (client) => {\n      await client.query(\n        `UPDATE agent_configs SET\n          name = $1,\n          description = $2,\n          provider = $3,\n          endpoint = $4,\n          api_key = $5,\n          app_id = $6,\n          model = $7,\n          max_tokens = $8,\n          temperature = $9,\n          system_prompt = $10,\n          capabilities = $11::jsonb,\n          rate_limit = $12::jsonb,\n          features = $13::jsonb,\n          metadata = COALESCE(metadata, '{}'::jsonb),\n          is_active = $14,\n          updated_at = NOW()\n        WHERE id = $15`,\n        [\n          config.name,\n          config.description,\n          config.provider,\n          config.endpoint,\n          config.apiKey,\n          config.appId || null,\n          config.model,\n          config.maxTokens ?? null,\n          config.temperature ?? null,\n          config.systemPrompt ?? null,\n          JSON.stringify(config.capabilities ?? []),\n          JSON.stringify(config.rateLimit ?? null),\n          JSON.stringify(config.features ?? null),\n          config.isActive,\n          config.id,\n        ],\n      );\n    });\n    this.agents.set(config.id, config);\n    await this.writeSnapshotToFile();\n  }\n\n  private async insertAgent(config: AgentConfig): Promise<void> {\n    await withClient(async (client) => {\n      await client.query(\n        `INSERT INTO agent_configs (\n          id, name, description, provider, endpoint, api_key, app_id,\n          model, max_tokens, temperature, system_prompt, capabilities,\n          rate_limit, features, metadata, is_active\n        ) VALUES (\n          $1,$2,$3,$4,$5,$6,$7,\n          $8,$9,$10,$11,$12::jsonb,\n          $13::jsonb,$14::jsonb,$15::jsonb,$16\n        )\n        ON CONFLICT (id) DO UPDATE SET\n          name = EXCLUDED.name,\n          description = EXCLUDED.description,\n          provider = EXCLUDED.provider,\n          endpoint = EXCLUDED.endpoint,\n          api_key = EXCLUDED.api_key,\n          app_id = EXCLUDED.app_id,\n          model = EXCLUDED.model,\n          max_tokens = EXCLUDED.max_tokens,\n          temperature = EXCLUDED.temperature,\n          system_prompt = EXCLUDED.system_prompt,\n          capabilities = EXCLUDED.capabilities,\n          rate_limit = EXCLUDED.rate_limit,\n          features = EXCLUDED.features,\n          metadata = EXCLUDED.metadata,\n          is_active = EXCLUDED.is_active,\n          updated_at = NOW();`,\n        [\n          config.id,\n          config.name,\n          config.description,\n          config.provider,\n          config.endpoint,\n          config.apiKey,\n          config.appId || null,\n          config.model,\n          config.maxTokens ?? null,\n          config.temperature ?? null,\n          config.systemPrompt ?? null,\n          JSON.stringify(config.capabilities ?? []),\n          JSON.stringify(config.rateLimit ?? null),\n          JSON.stringify(config.features ?? null),\n          JSON.stringify({ source: 'db' }),\n          config.isActive,\n        ],\n      );\n    });\n    this.agents.set(config.id, config);\n    await this.writeSnapshotToFile();\n  }\n\n  private async backfillFromFile(): Promise<void> {\n    let seededFromFile = false;\n    try {\n      const file = await fs.readFile(this.configPath, 'utf-8');\n      const sanitized = this.sanitizeNumericPlaceholders(file);\n      const parsed = JSON.parse(sanitized);\n      let list: AgentConfig[] = Array.isArray(parsed?.agents)\n        ? parsed.agents\n        : [];\n\n      // 🔐 安全增强：环境变量替换\n      list = deepReplaceEnvVariables(list);\n\n      if (list.length > 0) {\n        for (const agent of list) {\n          if (this.validateAgentConfig(agent)) {\n            await this.insertAgent({\n              ...agent,\n              createdAt: agent.createdAt || new Date().toISOString(),\n              updatedAt: agent.updatedAt || new Date().toISOString(),\n            });\n            seededFromFile = true;\n          }\n        }\n      }\n    } catch (error) {\n      logger.warn('从文件回填智能体失败', { error });\n    }\n\n    if (!seededFromFile && this.agents.size === 0) {\n      await this.seedDefaultAgents();\n    }\n  }\n\n  private async seedDefaultAgents(): Promise<void> {\n    const now = new Date().toISOString();\n    for (const seed of this.builtinSeeds) {\n      const features = this.ensureFeatureDefaults(\n        seed.features as AgentConfig['features'] | undefined,\n      );\n      const config: AgentConfig = {\n        id: seed.id,\n        name: seed.name,\n        description: seed.description,\n        endpoint: seed.endpoint,\n        apiKey: seed.apiKey,\n        model: seed.model,\n        provider: seed.provider,\n        isActive: seed.isActive ?? false,\n        capabilities: seed.capabilities ?? [],\n        features,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      if (this.validateAgentConfig(config)) {\n        await this.insertAgent(config);\n      }\n    }\n  }\n\n  private async writeSnapshotToFile(): Promise<void> {\n    if (this.snapshotWriting) {\n      return;\n    }\n    this.snapshotWriting = true;\n    try {\n      const config = {\n        agents: Array.from(this.agents.values()),\n      };\n      await fs.writeFile(\n        this.configPath,\n        JSON.stringify(config, null, 2),\n        'utf-8',\n      );\n    } catch (error) {\n      logger.warn('写入智能体快照失败', { error });\n    } finally {\n      this.snapshotWriting = false;\n    }\n  }\n\n  /**\n   * 配置快照对比功能\n   * 比较数据库中的配置与文件中的配置\n   */\n  async compareConfigSnapshot(): Promise<{\n    isEqual: boolean;\n    dbOnly: AgentConfig[];\n    fileOnly: AgentConfig[];\n    differences: Array<{\n      id: string;\n      field: string;\n      dbValue: any;\n      fileValue: any;\n    }>;\n  }> {\n    // 获取数据库中的配置\n    const dbConfigs = await this.loadAgentsFromDb();\n    const dbConfigMap = new Map(dbConfigs.map((config) => [config.id, config]));\n\n    // 获取文件中的配置\n    let fileConfigs: AgentConfig[] = [];\n    try {\n      const raw = await fs.readFile(this.configPath, 'utf-8');\n      const sanitized = this.sanitizeNumericPlaceholders(raw);\n      const parsed = JSON.parse(sanitized);\n      fileConfigs = Array.isArray(parsed?.agents) ? parsed.agents : [];\n\n      // 对于示例智能体使用静默模式，不记录环境变量警告\n      fileConfigs = deepReplaceEnvVariables(fileConfigs, true);\n    } catch (error) {\n      logger.warn('[AgentConfigService] 读取配置文件失败', { error });\n      fileConfigs = [];\n    }\n\n    const fileConfigMap = new Map(\n      fileConfigs.map((config) => [config.id, config]),\n    );\n\n    // 找出仅在数据库中存在的配置\n    const dbOnly = dbConfigs.filter((config) => !fileConfigMap.has(config.id));\n\n    // 找出仅在文件中存在的配置\n    const fileOnly = fileConfigs.filter(\n      (config) => !dbConfigMap.has(config.id),\n    );\n\n    // 比较共同存在的配置\n    const differences: Array<{\n      id: string;\n      field: string;\n      dbValue: any;\n      fileValue: any;\n    }> = [];\n\n    for (const [id, dbConfig] of dbConfigMap) {\n      const fileConfig = fileConfigMap.get(id);\n      if (fileConfig) {\n        // 比较配置字段\n        const fieldsToCompare: (keyof AgentConfig)[] = [\n          'name',\n          'description',\n          'endpoint',\n          'apiKey',\n          'model',\n          'provider',\n          'isActive',\n          'maxTokens',\n          'temperature',\n          'systemPrompt',\n        ];\n\n        for (const field of fieldsToCompare) {\n          const dbValue = dbConfig[field];\n          const fileValue = fileConfig[field];\n\n          // 特殊处理数组和对象字段\n          if (field === 'capabilities') {\n            const dbCaps = Array.isArray(dbConfig.capabilities)\n              ? dbConfig.capabilities.sort()\n              : [];\n            const fileCaps = Array.isArray(fileConfig.capabilities)\n              ? fileConfig.capabilities.sort()\n              : [];\n            if (JSON.stringify(dbCaps) !== JSON.stringify(fileCaps)) {\n              differences.push({\n                id,\n                field: 'capabilities',\n                dbValue: dbCaps,\n                fileValue: fileCaps,\n              });\n            }\n          } else if (field === 'features') {\n            // features字段比较较为复杂，暂时跳过\n            continue;\n          } else if (field === 'rateLimit') {\n            // rateLimit字段比较较为复杂，暂时跳过\n            continue;\n          } else {\n            // 普通字段比较\n            if (dbValue !== fileValue) {\n              differences.push({\n                id,\n                field,\n                dbValue,\n                fileValue,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      isEqual:\n        dbOnly.length === 0 &&\n        fileOnly.length === 0 &&\n        differences.length === 0,\n      dbOnly,\n      fileOnly,\n      differences,\n    };\n  }\n\n  /**\n   * 清理废弃配置\n   * 删除不再使用的配置项\n   */\n  async cleanupObsoleteConfigs(): Promise<{\n    deletedCount: number;\n    deletedIds: string[];\n  }> {\n    const deletedIds: string[] = [];\n\n    try {\n      // 获取所有配置\n      const configs = await this.ensureCache();\n\n      // 定义废弃配置的判断标准\n      // 1. 非激活状态且长时间未更新的配置\n      // 2. 配置无效的条目\n      const now = Date.now();\n      const obsoleteThreshold = 30 * 24 * 60 * 60 * 1000; // 30天\n\n      const obsoleteConfigs = configs.filter((config) => {\n        // 检查是否为废弃配置\n        const isInactive = !config.isActive;\n        const isOld =\n          now - new Date(config.updatedAt).getTime() > obsoleteThreshold;\n        const isInvalid = !this.validateAgentConfig(config);\n\n        // 如果配置非激活且超过30天未更新，或者配置无效，则认为是废弃配置\n        return (isInactive && isOld) || isInvalid;\n      });\n\n      // 删除废弃配置\n      for (const config of obsoleteConfigs) {\n        try {\n          await withClient(async (client) => {\n            await client.query('DELETE FROM agent_configs WHERE id = $1', [\n              config.id,\n            ]);\n          });\n          this.agents.delete(config.id);\n          deletedIds.push(config.id);\n          logger.info(`[AgentConfigService] 已删除废弃配置: ${config.id}`);\n        } catch (error) {\n          logger.error(`[AgentConfigService] 删除废弃配置失败: ${config.id}`, {\n            error,\n          });\n        }\n      }\n\n      // 如果删除了配置，更新快照文件\n      if (deletedIds.length > 0) {\n        await this.writeSnapshotToFile();\n      }\n\n      return {\n        deletedCount: deletedIds.length,\n        deletedIds,\n      };\n    } catch (error) {\n      logger.error('[AgentConfigService] 清理废弃配置失败', { error });\n      return {\n        deletedCount: 0,\n        deletedIds: [],\n      };\n    }\n  }\n\n  /**\n   * 定期清理任务\n   * 每日执行的清理任务\n   */\n  async dailyCleanupTask(): Promise<void> {\n    logger.info('[AgentConfigService] 开始执行每日清理任务');\n\n    try {\n      // 1. 清理废弃配置\n      const cleanupResult = await this.cleanupObsoleteConfigs();\n      logger.info(\n        `[AgentConfigService] 清理废弃配置完成: ${cleanupResult.deletedCount} 个配置已删除`,\n      );\n\n      // 2. 重新加载配置缓存\n      this.agents.clear();\n      this.lastLoadTime = 0;\n      await this.ensureCache(true);\n\n      // 3. 写入新的快照文件\n      await this.writeSnapshotToFile();\n\n      logger.info('[AgentConfigService] 每日清理任务完成');\n    } catch (error) {\n      logger.error('[AgentConfigService] 每日清理任务失败', { error });\n    }\n  }\n\n  /**\n   * 获取配置健康状态\n   */\n  async getConfigHealthStatus(): Promise<{\n    totalConfigs: number;\n    activeConfigs: number;\n    inactiveConfigs: number;\n    invalidConfigs: number;\n    hasUnresolvedPlaceholders: number;\n    snapshotComparison: {\n      isEqual: boolean;\n      dbOnlyCount: number;\n      fileOnlyCount: number;\n      differenceCount: number;\n    };\n  }> {\n    // 获取所有配置\n    const configs = await this.ensureCache();\n\n    // 统计各种状态\n    const totalConfigs = configs.length;\n    const activeConfigs = configs.filter((c) => c.isActive).length;\n    const inactiveConfigs = totalConfigs - activeConfigs;\n\n    // 检查无效配置\n    let invalidConfigs = 0;\n    let hasUnresolvedPlaceholdersCount = 0;\n\n    for (const config of configs) {\n      if (!this.validateAgentConfig(config)) {\n        invalidConfigs++;\n      }\n\n      // 检查未解析的占位符\n      const sensitiveFields: Array<keyof AgentConfig> = ['endpoint', 'apiKey', 'appId'];\n      for (const field of sensitiveFields) {\n        const fieldValue = config[field];\n        if (\n          fieldValue &&\n          typeof fieldValue === 'string' &&\n          containsUnresolvedPlaceholders(fieldValue)\n        ) {\n          hasUnresolvedPlaceholdersCount++;\n          break;\n        }\n      }\n    }\n\n    // 执行快照对比\n    const comparison = await this.compareConfigSnapshot();\n\n    return {\n      totalConfigs,\n      activeConfigs,\n      inactiveConfigs,\n      invalidConfigs,\n      hasUnresolvedPlaceholders: hasUnresolvedPlaceholdersCount,\n      snapshotComparison: {\n        isEqual: comparison.isEqual,\n        dbOnlyCount: comparison.dbOnly.length,\n        fileOnlyCount: comparison.fileOnly.length,\n        differenceCount: comparison.differences.length,\n      },\n    };\n  }\n\n  private validateAgentConfig(\n    config: any,\n    existingId?: string,\n    collection: Map<string, AgentConfig> = this.agents,\n  ): config is AgentConfig {\n    const requiredFields = [\n      'id',\n      'name',\n      'description',\n      'endpoint',\n      'apiKey',\n      'model',\n      'provider',\n    ];\n\n    for (const field of requiredFields) {\n      if (!config[field]) {\n        logger.error('智能体配置缺少必需字段', { field });\n        return false;\n      }\n    }\n\n    // 🔐 安全检查：对于激活的智能体，确保没有未解析的环境变量占位符\n    // 示例/未激活的智能体可以包含占位符\n    if (config.isActive) {\n      const sensitiveFields = ['endpoint', 'apiKey', 'appId'];\n      for (const field of sensitiveFields) {\n        if (\n          config[field] &&\n          typeof config[field] === 'string' &&\n          containsUnresolvedPlaceholders(config[field])\n        ) {\n          logger.error('激活的智能体配置包含未解析的环境变量占位符', {\n            agentId: config.id,\n            field,\n            value: config[field],\n          });\n          return false;\n        }\n      }\n    }\n\n    if (collection.has(config.id) && config.id !== existingId) {\n      logger.error('智能体ID重复', { agentId: config.id });\n      return false;\n    }\n\n    if (config.provider === 'fastgpt') {\n      if (\n        !config.appId ||\n        typeof config.appId !== 'string' ||\n        !/^[a-fA-F0-9]{24}$/.test(config.appId)\n      ) {\n        logger.error(\n          'FastGPT 配置缺少有效的 appId（需要 24 位十六进制字符串）',\n          { agentId: config.id },\n        );\n        return false;\n      }\n    }\n\n    const validProviders = [\n      'fastgpt',\n      'openai',\n      'anthropic',\n      'dify',\n      'dashscope',\n      'custom',\n    ];\n    if (!validProviders.includes(config.provider)) {\n      logger.error('不支持的provider', { provider: config.provider });\n      return false;\n    }\n\n    try {\n      const endpointUrl = config.endpoint.startsWith('http')\n        ? config.endpoint\n        : `https://${config.endpoint}`;\n      new URL(endpointUrl);\n    } catch {\n      logger.error('无效的endpoint URL', { endpoint: config.endpoint });\n      return false;\n    }\n\n    return true;\n  }\n\n  private transformToAgent(config: AgentConfig): Agent {\n    return {\n      id: config.id,\n      name: config.name,\n      description: config.description,\n      model: config.model,\n      status: config.isActive ? 'active' : 'inactive',\n      capabilities: config.capabilities,\n      provider: config.provider,\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/AnalyticsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2968,2971],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2968,2971],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5609,5612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5609,5612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":267,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7705,7708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7705,7708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { withClient } from '@/utils/db';\nimport { generateId } from '@/utils/helpers';\nimport { geoService } from '@/services/GeoService';\nimport { withMongo, ObjectId } from '@/utils/mongo';\nimport logger from '@/utils/logger';\n\nexport interface ProvinceHeatmapPoint {\n  province: string;\n  count: number;\n}\n\nexport interface ProvinceHeatmapSummary {\n  overseas: number;\n  local: number;\n  unknown: number;\n}\n\nexport interface ProvinceHeatmapResult {\n  start: string;\n  end: string;\n  agentId: string | null;\n  total: number;\n  points: ProvinceHeatmapPoint[];\n  summary: ProvinceHeatmapSummary;\n  generatedAt: string;\n}\n\nconst MAP_PROVINCES = new Set(geoService.getProvinceNames());\n\nexport interface ConversationSeriesBucket {\n  date: string;\n  total: number;\n  byAgent: Array<{ agentId: string; count: number }>;\n}\n\nexport interface ConversationSeriesAgentTotal {\n  agentId: string;\n  name: string;\n  isActive: boolean;\n  count: number;\n}\n\nexport interface ConversationSeriesResult {\n  start: string;\n  end: string;\n  agentId: string | null;\n  granularity: 'day';\n  buckets: ConversationSeriesBucket[];\n  total: number;\n  agentTotals: ConversationSeriesAgentTotal[];\n  generatedAt: string;\n}\n\nexport interface AgentComparisonResult {\n  start: string;\n  end: string;\n  totals: ConversationSeriesAgentTotal[];\n  total: number;\n  generatedAt: string;\n}\n\nexport class AnalyticsService {\n  async recordAgentRequest(params: {\n    agentId: string;\n    sessionId?: string | null;\n    ip?: string | null;\n  }): Promise<void> {\n    const normalizedIp = geoService.normalizeIp(params.ip ?? null);\n    const lookup = geoService.lookup(normalizedIp ?? undefined);\n\n    const province = lookup?.province ?? '未知';\n    const country = lookup?.country ?? 'UNKNOWN';\n    const city = lookup?.city ?? null;\n\n    try {\n      await withClient(async (client) => {\n        await client.query(\n          `INSERT INTO chat_geo_events (\n            id,\n            agent_id,\n            session_id,\n            ip,\n            country,\n            province,\n            city\n          ) VALUES ($1,$2,$3,$4,$5,$6,$7)`,\n          [\n            generateId(),\n            params.agentId,\n            params.sessionId || null,\n            normalizedIp,\n            country,\n            province,\n            city,\n          ],\n        );\n      });\n    } catch (error) {\n      logger.warn('[AnalyticsService] recordAgentRequest failed', { error });\n    }\n  }\n\n  async getProvinceHeatmap(params: {\n    start: Date;\n    end: Date;\n    agentId?: string | null;\n  }): Promise<ProvinceHeatmapResult> {\n    const { start, end, agentId } = params;\n\n    const rows = await withClient(async (client) => {\n      const sql = `\n        SELECT COALESCE(province, '未知') AS province, COUNT(*)::text AS count\n        FROM chat_geo_events\n        WHERE created_at >= $1 AND created_at <= $2\n        ${agentId ? 'AND agent_id = $3' : ''}\n        GROUP BY COALESCE(province, '未知')\n      `;\n      const queryParams: any[] = agentId ? [start, end, agentId] : [start, end];\n      const { rows } = await client.query<{ province: string | null; count: string }>(sql, queryParams);\n      return rows;\n    });\n\n    const points: ProvinceHeatmapPoint[] = [];\n    let total = 0;\n    let overseas = 0;\n    let local = 0;\n    let unknown = 0;\n\n    rows.forEach((row) => {\n      const province = row.province || '未知';\n      const count = parseInt(row.count, 10) || 0;\n      total += count;\n      if (province === '海外') {\n        overseas += count;\n        return;\n      }\n      if (province === '本地') {\n        local += count;\n        return;\n      }\n      if (!MAP_PROVINCES.has(province)) {\n        unknown += count;\n        return;\n      }\n      points.push({ province, count });\n    });\n\n    points.sort((a, b) => b.count - a.count);\n\n    return {\n      start: start.toISOString(),\n      end: end.toISOString(),\n      agentId: agentId ?? null,\n      total,\n      points,\n      summary: {\n        overseas,\n        local,\n        unknown,\n      },\n      generatedAt: new Date().toISOString(),\n    };\n  }\n\n  async getConversationSeries(params: {\n    start: Date;\n    end: Date;\n    agentId?: string | null;\n  }): Promise<ConversationSeriesResult> {\n    const { start, end, agentId } = params;\n\n    const agentRows = await withClient(async (client) => {\n      const { rows } = await client.query<{ id: string; name: string; is_active: boolean; app_id: string | null }>(\n        'SELECT id, name, is_active, app_id FROM agent_configs ORDER BY name ASC',\n      );\n      return rows;\n    });\n\n    const agentById = new Map<string, { id: string; name: string; is_active: boolean; app_id: string | null }>();\n    const appIdToAgent = new Map<string, { id: string; name: string; is_active: boolean }>();\n    agentRows.forEach((row) => {\n      agentById.set(row.id, row);\n      if (row.app_id) {\n        appIdToAgent.set(row.app_id, { id: row.id, name: row.name, is_active: row.is_active });\n      }\n    });\n\n    const appIdsToQuery: string[] = (() => {\n      if (agentId) {\n        const agent = agentById.get(agentId);\n        return agent?.app_id ? [agent.app_id] : [];\n      }\n      return Array.from(appIdToAgent.keys());\n    })();\n\n    const appIdObjectIds = appIdsToQuery\n      .filter((id) => ObjectId.isValid(id))\n      .map((id) => new ObjectId(id));\n\n    const dayMap = new Map<string, Map<string, number>>();\n    const agentTotalsMap = new Map<string, number>();\n    const agentsWithActivity = new Set<string>();\n\n    if (appIdObjectIds.length > 0) {\n      try {\n        const mongoRows = await withMongo(async (db) => {\n          const pipeline: Record<string, any>[] = [\n            {\n              $match: {\n                createTime: {\n                  $gte: start,\n                  $lte: end,\n                },\n                appId: appIdsToQuery.length === 1\n                  ? appIdObjectIds[0]\n                  : { $in: appIdObjectIds },\n              },\n            },\n            {\n              $group: {\n                _id: {\n                  day: {\n                    $dateToString: { format: '%Y-%m-%d', date: '$createTime', timezone: 'UTC' },\n                  },\n                  appId: '$appId',\n                },\n                count: { $sum: 1 },\n              },\n            },\n          ];\n\n          type MongoAggRow = { _id: { day: string; appId: ObjectId }; count: number };\n          const docs = await db.collection<MongoAggRow>('chats').aggregate(pipeline).toArray();\n          return docs;\n        });\n\n        mongoRows.forEach((row) => {\n          const dayKey = row._id.day;\n          const appId = row._id.appId.toHexString();\n          const agent = appIdToAgent.get(appId);\n          if (!agent) {\n            return;\n          }\n          const agentKey = agent.id;\n          const perDay = dayMap.get(dayKey) ?? new Map<string, number>();\n          const count = Number(row.count || 0);\n          perDay.set(agentKey, (perDay.get(agentKey) ?? 0) + count);\n          dayMap.set(dayKey, perDay);\n          agentTotalsMap.set(agentKey, (agentTotalsMap.get(agentKey) ?? 0) + count);\n          agentsWithActivity.add(agentKey);\n        });\n      } catch (error) {\n        logger.warn('[AnalyticsService] Mongo 聚合失败，回退到 PostgreSQL 统计', { error });\n      }\n    }\n\n    if (dayMap.size === 0 && agentTotalsMap.size === 0) {\n      const pgRows = await withClient(async (client) => {\n        const sql = `\n          SELECT DATE_TRUNC('day', created_at) AS day, agent_id, COUNT(*)::int AS count\n          FROM chat_geo_events\n          WHERE created_at >= $1 AND created_at <= $2\n          ${agentId ? 'AND agent_id = $3' : ''}\n          GROUP BY day, agent_id\n          ORDER BY day ASC\n        `;\n        const params: any[] = agentId ? [start, end, agentId] : [start, end];\n        const { rows } = await client.query<{ day: Date; agent_id: string; count: number }>(sql, params);\n        return rows;\n      });\n\n      pgRows.forEach((row) => {\n        const dayKey = row.day.toISOString().slice(0, 10);\n        const agentKey = row.agent_id;\n        const perDay = dayMap.get(dayKey) ?? new Map<string, number>();\n        const count = Number(row.count || 0);\n        perDay.set(agentKey, (perDay.get(agentKey) ?? 0) + count);\n        dayMap.set(dayKey, perDay);\n        agentTotalsMap.set(agentKey, (agentTotalsMap.get(agentKey) ?? 0) + count);\n        agentsWithActivity.add(agentKey);\n      });\n    }\n\n    const msPerDay = 24 * 60 * 60 * 1000;\n    const startDay = new Date(Date.UTC(\n      start.getUTCFullYear(),\n      start.getUTCMonth(),\n      start.getUTCDate(),\n    ));\n    const endDay = new Date(Date.UTC(\n      end.getUTCFullYear(),\n      end.getUTCMonth(),\n      end.getUTCDate(),\n    ));\n    const bucketCount = Math.max(0, Math.floor((endDay.getTime() - startDay.getTime()) / msPerDay)) + 1;\n\n    const buckets: ConversationSeriesBucket[] = [];\n    let total = 0;\n    for (let i = 0; i < bucketCount; i += 1) {\n      const current = new Date(startDay.getTime() + i * msPerDay);\n      const key = current.toISOString().slice(0, 10);\n      const perDay = dayMap.get(key) ?? new Map<string, number>();\n      const byAgent = Array.from(perDay.entries()).map(([agent, count]) => ({ agentId: agent, count }));\n      const dayTotal = byAgent.reduce((sum, item) => sum + item.count, 0);\n      total += dayTotal;\n      buckets.push({ date: key, total: dayTotal, byAgent });\n    }\n\n    const relevantAgents = agentId\n      ? agentRows.filter((row) => row.id === agentId)\n      : agentRows.filter((row) => agentsWithActivity.has(row.id) || agentTotalsMap.has(row.id));\n\n    const agentTotals: ConversationSeriesAgentTotal[] = relevantAgents\n      .map((row) => ({\n        agentId: row.id,\n        name: row.name,\n        isActive: !!row.is_active,\n        count: agentTotalsMap.get(row.id) ?? 0,\n      }))\n      .sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));\n\n    return {\n      start: start.toISOString(),\n      end: end.toISOString(),\n      agentId: agentId ?? null,\n      granularity: 'day',\n      buckets,\n      total,\n      agentTotals,\n      generatedAt: new Date().toISOString(),\n    };\n  }\n\n  async getAgentTotals(params: { start: Date; end: Date }): Promise<AgentComparisonResult> {\n    const { start, end } = params;\n\n    const agentRows = await withClient(async (client) => {\n      const { rows } = await client.query<{ id: string; name: string; is_active: boolean; app_id: string | null }>(\n        'SELECT id, name, is_active, app_id FROM agent_configs ORDER BY name ASC',\n      );\n      return rows;\n    });\n\n    const appIdToAgent = new Map<string, { id: string; name: string; is_active: boolean }>();\n    agentRows.forEach((row) => {\n      if (row.app_id) {\n        appIdToAgent.set(row.app_id, { id: row.id, name: row.name, is_active: row.is_active });\n      }\n    });\n\n    const appIdObjectIds = Array.from(appIdToAgent.keys())\n      .filter((id) => ObjectId.isValid(id))\n      .map((id) => new ObjectId(id));\n\n    const countMap = new Map<string, number>();\n\n    if (appIdObjectIds.length > 0) {\n      try {\n        const mongoRows = await withMongo(async (db) => {\n          const pipeline = [\n            {\n              $match: {\n                createTime: {\n                  $gte: start,\n                  $lte: end,\n                },\n                appId: { $in: appIdObjectIds },\n              },\n            },\n            {\n              $group: {\n                _id: '$appId',\n                count: { $sum: 1 },\n              },\n            },\n          ];\n\n          type MongoAggRow = { _id: ObjectId; count: number };\n          return db.collection<MongoAggRow>('chats').aggregate(pipeline).toArray();\n        });\n\n        mongoRows.forEach((row) => {\n          const appId = row._id.toHexString();\n          const agent = appIdToAgent.get(appId);\n          if (!agent) {\n            return;\n          }\n          const count = Number(row.count || 0);\n          countMap.set(agent.id, (countMap.get(agent.id) ?? 0) + count);\n        });\n      } catch (error) {\n        logger.warn('[AnalyticsService] Mongo 聚合失败，使用 PostgreSQL 计数', { error });\n      }\n    }\n\n    if (countMap.size === 0) {\n      const pgRows = await withClient(async (client) => {\n        const sql = `\n          SELECT agent_id, COUNT(*)::int AS count\n          FROM chat_geo_events\n          WHERE created_at >= $1 AND created_at <= $2\n          GROUP BY agent_id\n        `;\n        const { rows } = await client.query<{ agent_id: string; count: number }>(sql, [start, end]);\n        return rows;\n      });\n\n      pgRows.forEach((row) => {\n        countMap.set(row.agent_id, Number(row.count || 0));\n      });\n    }\n\n    const totals: ConversationSeriesAgentTotal[] = agentRows\n      .filter((row) => countMap.has(row.id))\n      .map((row) => ({\n        agentId: row.id,\n        name: row.name,\n        isActive: !!row.is_active,\n        count: countMap.get(row.id) ?? 0,\n      }))\n      .sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));\n\n    const total = totals.reduce((sum, item) => sum + item.count, 0);\n\n    return {\n      start: start.toISOString(),\n      end: end.toISOString(),\n      totals,\n      total,\n      generatedAt: new Date().toISOString(),\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/AuditService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1545,1548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1545,1548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3818,3821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3818,3821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4149,4152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4149,4152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4169,4172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4169,4172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool } from 'pg';\nimport { getPool } from '@/utils/db';\nimport logger from '@/utils/logger';\nimport {\n  AuditLog,\n  CreateAuditLogParams,\n  AuditLogQuery,\n  AuditLogQueryResult,\n  AuditAction,\n  AuditStatus,\n  ResourceType,\n} from '@/types/audit';\nimport { SystemError } from '@/types/errors';\n\n/**\n * 审计日志服务\n *\n * 职责：\n * - 记录所有关键安全操作\n * - 提供审计日志查询接口\n * - 确保审计日志不可篡改\n * - 支持审计日志导出\n */\nexport class AuditService {\n  /**\n   * 延迟获取数据库连接池\n   * 避免在模块导入时调用 getPool()，确保 initDB() 已执行\n   */\n  private get pool(): Pool {\n    return getPool();\n  }\n\n  // 构造函数不再需要，使用 getter 延迟获取连接池\n\n  /**\n   * 记录审计日志（使用优化的数据库连接）\n   */\n  async log(params: CreateAuditLogParams): Promise<AuditLog> {\n    const {\n      userId,\n      username,\n      action,\n      resourceType,\n      resourceId,\n      details,\n      ipAddress,\n      userAgent,\n      status = AuditStatus.SUCCESS,\n      errorMessage,\n    } = params;\n\n    try {\n      const pool = getPool();\n      const result = await pool.query(\n        `INSERT INTO audit_logs (\n          user_id, username, action, resource_type, resource_id,\n          details, ip_address, user_agent, status, error_message\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n        RETURNING *`,\n        [\n          userId,\n          username,\n          action,\n          resourceType,\n          resourceId,\n          details ? JSON.stringify(details) : null,\n          ipAddress,\n          userAgent,\n          status,\n          errorMessage,\n        ],\n      );\n\n      const auditLog = this.mapRowToAuditLog((result as any).rows[0]);\n\n      // 同时写入 Winston 日志\n      logger.info('AUDIT_LOG', {\n        component: 'AuditService',\n        auditLog,\n      });\n\n      return auditLog;\n    } catch (error) {\n      logger.error('Failed to create audit log', {\n        component: 'AuditService',\n        error,\n        params,\n      });\n\n      throw new SystemError({\n        message: 'Failed to create audit log',\n        code: 'AUDIT_LOG_CREATE_FAILED',\n        originalError: error as Error,\n      });\n    }\n  }\n\n  /**\n   * 查询审计日志（使用优化的数据库连接）\n   */\n  async query(query: AuditLogQuery): Promise<AuditLogQueryResult> {\n    const {\n      userId,\n      action,\n      resourceType,\n      resourceId,\n      status,\n      startDate,\n      endDate,\n      limit = 50,\n      offset = 0,\n      orderBy = 'timestamp',\n      orderDirection = 'DESC',\n    } = query;\n\n    const pool = getPool();\n\n    try {\n      // 构建查询条件\n      const conditions: string[] = [];\n      const values: unknown[] = [];\n      let paramIndex = 1;\n\n      if (userId) {\n        conditions.push(`user_id = $${paramIndex++}`);\n        values.push(userId);\n      }\n\n      if (action) {\n        if (Array.isArray(action)) {\n          conditions.push(`action = ANY($${paramIndex++})`);\n          values.push(action);\n        } else {\n          conditions.push(`action = $${paramIndex++}`);\n          values.push(action);\n        }\n      }\n\n      if (resourceType) {\n        conditions.push(`resource_type = $${paramIndex++}`);\n        values.push(resourceType);\n      }\n\n      if (resourceId) {\n        conditions.push(`resource_id = $${paramIndex++}`);\n        values.push(resourceId);\n      }\n\n      if (status) {\n        conditions.push(`status = $${paramIndex++}`);\n        values.push(status);\n      }\n\n      if (startDate) {\n        conditions.push(`timestamp >= $${paramIndex++}`);\n        values.push(startDate);\n      }\n\n      if (endDate) {\n        conditions.push(`timestamp <= $${paramIndex++}`);\n        values.push(endDate);\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // 查询总数（使用缓存）\n      const countResult = await pool.query(\n        `SELECT COUNT(*) as count FROM audit_logs ${whereClause}`,\n        values,\n      );\n      const total = parseInt((countResult as any).rows[0]?.count || '0', 10);\n\n      // 查询数据（使用缓存）\n      const dataResult = await pool.query(\n        `SELECT * FROM audit_logs ${whereClause}\n         ORDER BY ${orderBy} ${orderDirection}\n         LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,\n        [...values, limit, offset],\n      );\n\n      const logs = (dataResult as any).rows.map((row: any) => this.mapRowToAuditLog(row));\n\n      const page = Math.floor(offset / limit) + 1;\n      const totalPages = Math.ceil(total / limit);\n\n      return {\n        logs,\n        total,\n        page,\n        pageSize: limit,\n        totalPages,\n      };\n    } catch (error) {\n      logger.error('Failed to query audit logs', {\n        component: 'AuditService',\n        error,\n        query,\n      });\n\n      throw new SystemError({\n        message: 'Failed to query audit logs',\n        code: 'AUDIT_LOG_QUERY_FAILED',\n        originalError: error as Error,\n      });\n    }\n  }\n\n  /**\n   * 获取用户审计日志\n   */\n  async getUserAuditLogs(\n    userId: string,\n    options: {\n      limit?: number;\n      offset?: number;\n      startDate?: Date;\n      endDate?: Date;\n    } = {},\n  ): Promise<AuditLogQueryResult> {\n    return this.query({\n      userId,\n      ...options,\n    });\n  }\n\n  /**\n   * 获取资源审计日志\n   */\n  async getResourceAuditLogs(\n    resourceType: ResourceType,\n    resourceId: string,\n    options: {\n      limit?: number;\n      offset?: number;\n    } = {},\n  ): Promise<AuditLogQueryResult> {\n    return this.query({\n      resourceType,\n      resourceId,\n      ...options,\n    });\n  }\n\n  /**\n   * 获取最近的审计日志\n   */\n  async getRecentLogs(limit: number = 100): Promise<AuditLog[]> {\n    const result = await this.query({\n      limit,\n      offset: 0,\n      orderBy: 'timestamp',\n      orderDirection: 'DESC',\n    });\n\n    return result.logs;\n  }\n\n  /**\n   * 获取失败的审计日志\n   */\n  async getFailedLogs(\n    options: {\n      limit?: number;\n      offset?: number;\n      startDate?: Date;\n      endDate?: Date;\n    } = {},\n  ): Promise<AuditLogQueryResult> {\n    return this.query({\n      status: AuditStatus.FAILURE,\n      ...options,\n    });\n  }\n\n  /**\n   * 导出审计日志（CSV格式）\n   */\n  async exportToCSV(query: AuditLogQuery): Promise<string> {\n    const result = await this.query({\n      ...query,\n      limit: 10000, // 最多导出10000条\n    });\n\n    const headers = [\n      'ID',\n      'Timestamp',\n      'User ID',\n      'Username',\n      'Action',\n      'Resource Type',\n      'Resource ID',\n      'Status',\n      'IP Address',\n      'User Agent',\n      'Error Message',\n    ];\n\n    const rows = result.logs.map((log) => [\n      log.id,\n      log.timestamp.toISOString(),\n      log.userId || '',\n      log.username || '',\n      log.action,\n      log.resourceType || '',\n      log.resourceId || '',\n      log.status,\n      log.ipAddress || '',\n      log.userAgent || '',\n      log.errorMessage || '',\n    ]);\n\n    const csv = [headers, ...rows]\n      .map((row) => row.map((cell) => `\"${String(cell).replace(/\"/g, '\"\"')}\"`).join(','))\n      .join('\\n');\n\n    return csv;\n  }\n\n  /**\n   * 清理过期审计日志\n   *\n   * @param retentionDays 保留天数，默认90天\n   */\n  async cleanupOldLogs(retentionDays: number = 90): Promise<number> {\n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n      const result = await this.pool.query(\n        'DELETE FROM audit_logs WHERE timestamp < $1',\n        [cutoffDate],\n      );\n\n      const deletedCount = result.rowCount || 0;\n\n      logger.info('Cleaned up old audit logs', {\n        component: 'AuditService',\n        retentionDays,\n        cutoffDate,\n        deletedCount,\n      });\n\n      return deletedCount;\n    } catch (error) {\n      logger.error('Failed to cleanup old audit logs', {\n        component: 'AuditService',\n        error,\n        retentionDays,\n      });\n\n      throw new SystemError({\n        message: 'Failed to cleanup old audit logs',\n        code: 'AUDIT_LOG_CLEANUP_FAILED',\n        originalError: error as Error,\n      });\n    }\n  }\n\n  /**\n   * 获取审计统计信息\n   */\n  async getStatistics(\n    options: {\n      startDate?: Date;\n      endDate?: Date;\n    } = {},\n  ): Promise<{\n    totalLogs: number;\n    successCount: number;\n    failureCount: number;\n    actionCounts: Record<string, number>;\n    topUsers: Array<{ userId: string; username: string; count: number }>;\n  }> {\n    const { startDate, endDate } = options;\n\n    try {\n      const conditions: string[] = [];\n      const values: unknown[] = [];\n      let paramIndex = 1;\n\n      if (startDate) {\n        conditions.push(`timestamp >= $${paramIndex++}`);\n        values.push(startDate);\n      }\n\n      if (endDate) {\n        conditions.push(`timestamp <= $${paramIndex++}`);\n        values.push(endDate);\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // 总数统计\n      const totalResult = await this.pool.query<{ count: string }>(\n        `SELECT COUNT(*) as count FROM audit_logs ${whereClause}`,\n        values,\n      );\n      const totalLogs = parseInt(totalResult.rows[0]?.count || '0', 10);\n\n      // 成功/失败统计\n      const statusResult = await this.pool.query<{ status: string; count: string }>(\n        `SELECT status, COUNT(*) as count FROM audit_logs ${whereClause} GROUP BY status`,\n        values,\n      );\n\n      let successCount = 0;\n      let failureCount = 0;\n\n      statusResult.rows.forEach((row) => {\n        const count = parseInt(row.count, 10);\n        if (row.status === AuditStatus.SUCCESS) {\n          successCount = count;\n        } else if (row.status === AuditStatus.FAILURE) {\n          failureCount = count;\n        }\n      });\n\n      // 操作类型统计\n      const actionResult = await this.pool.query<{ action: string; count: string }>(\n        `SELECT action, COUNT(*) as count FROM audit_logs ${whereClause} GROUP BY action ORDER BY count DESC`,\n        values,\n      );\n\n      const actionCounts: Record<string, number> = {};\n      actionResult.rows.forEach((row) => {\n        actionCounts[row.action] = parseInt(row.count, 10);\n      });\n\n      // Top 用户统计\n      const userResult = await this.pool.query<{ user_id: string; username: string; count: string }>(\n        `SELECT user_id, username, COUNT(*) as count \n         FROM audit_logs \n         ${whereClause} AND user_id IS NOT NULL\n         GROUP BY user_id, username \n         ORDER BY count DESC \n         LIMIT 10`,\n        values,\n      );\n\n      const topUsers = userResult.rows.map((row) => ({\n        userId: row.user_id,\n        username: row.username || 'Unknown',\n        count: parseInt(row.count, 10),\n      }));\n\n      return {\n        totalLogs,\n        successCount,\n        failureCount,\n        actionCounts,\n        topUsers,\n      };\n    } catch (error) {\n      logger.error('Failed to get audit statistics', {\n        component: 'AuditService',\n        error,\n        options,\n      });\n\n      throw new SystemError({\n        message: 'Failed to get audit statistics',\n        code: 'AUDIT_STATS_FAILED',\n        originalError: error as Error,\n      });\n    }\n  }\n\n  /**\n   * 辅助方法：将数据库行映射为 AuditLog\n   */\n  private mapRowToAuditLog(row: unknown): AuditLog {\n    const r = row as Record<string, unknown>;\n    const log: AuditLog = {\n      id: r.id as number,\n      timestamp: new Date(r.timestamp as string),\n      action: r.action as AuditAction,\n      status: r.status as AuditStatus,\n      createdAt: new Date(r.created_at as string),\n    };\n\n    // 只在有值时添加可选字段\n    if (r.user_id) {\n      log.userId = r.user_id as string;\n    }\n    if (r.username) {\n      log.username = r.username as string;\n    }\n    if (r.resource_type) {\n      log.resourceType = r.resource_type as ResourceType;\n    }\n    if (r.resource_id) {\n      log.resourceId = r.resource_id as string;\n    }\n    if (r.details) {\n      log.details = r.details as Record<string, unknown>;\n    }\n    if (r.ip_address) {\n      log.ipAddress = r.ip_address as string;\n    }\n    if (r.user_agent) {\n      log.userAgent = r.user_agent as string;\n    }\n    if (r.error_message) {\n      log.errorMessage = r.error_message as string;\n    }\n\n    return log;\n  }\n}\n\n// 导出单例\nexport const auditService = new AuditService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/AuthService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hashPassword' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { readJsonc } from '@/utils/config';\nimport { generateId } from '@/utils/helpers';\nimport { withClient, hashPassword } from '@/utils/db';\n\nexport interface DefaultAccount {\n  username: string;\n  password: string;\n  role?: string;\n}\n\nexport interface AuthUser {\n  id: string;\n  username: string;\n  role?: string;\n}\n\nexport interface LoginResult {\n  token: string;\n  user: AuthUser;\n  expiresIn: number; // seconds\n}\n\ninterface ConfigSchema {\n  auth?: {\n    defaultAccounts?: DefaultAccount[];\n    tokenTTLSeconds?: number;\n  };\n}\n\ninterface TokenRecord {\n  user: AuthUser;\n  exp: number; // epoch ms\n}\n\n/**\n * 简单鉴权服务（开发/演示用）\n * - 从 config/config.jsonc 读取默认账号\n * - 生成内存 token，并在 TTL 到期时失效\n */\nexport class AuthService {\n  private tokens = new Map<string, TokenRecord>();\n  private readonly defaultTTL = 24 * 60 * 60; // 24h\n  private accountsCache: Map<string, DefaultAccount> | null = null; // 内存账号缓存，仅用于开发/演示\n\n  private async getAccounts(): Promise<Map<string, DefaultAccount>> {\n    if (this.accountsCache) {\n      return this.accountsCache;\n    }\n    const cfg = await this.loadConfig();\n    const accounts = cfg.auth?.defaultAccounts || [\n      { username: 'admin', password: 'admin123!', role: 'admin' },\n    ];\n    this.accountsCache = new Map(accounts.map((a) => [a.username, { ...a }]));\n    return this.accountsCache;\n  }\n\n  async login(username: string, password: string): Promise<LoginResult> {\n    // \u0000d\u0000d -> \u0000d\u0000a\u0000d\u0000a \u0000d\u0000a\u0000d\u0000a\n    const dbUser = await withClient(async (client) => {\n      const { rows } = await client.query(\n        'SELECT id, username, password_plain, role, status FROM users WHERE username=$1 LIMIT 1',\n        [username],\n      );\n      return rows[0];\n    });\n\n    if (!dbUser || (dbUser.status && dbUser.status !== 'active')) {\n      throw new Error('INVALID_CREDENTIALS');\n    }\n\n    if (password !== (dbUser.password_plain || '')) {\n      throw new Error('INVALID_CREDENTIALS');\n    }\n\n    const user: AuthUser = { id: String(dbUser.id), username: dbUser.username, role: dbUser.role || undefined };\n    const cfg = await this.loadConfig();\n    const ttl = cfg.auth?.tokenTTLSeconds ?? this.defaultTTL;\n    const token = generateId();\n    const exp = Date.now() + ttl * 1000;\n\n    this.tokens.set(token, { user, exp });\n    return { token, user, expiresIn: ttl };\n  }\n\n  async profile(token: string): Promise<AuthUser> {\n    const record = this.tokens.get(token);\n    if (!record) {\n      throw new Error('UNAUTHORIZED');\n    }\n    if (Date.now() > record.exp) {\n      this.tokens.delete(token);\n      throw new Error('TOKEN_EXPIRED');\n    }\n    return record.user;\n  }\n\n  async logout(token: string): Promise<void> {\n    this.tokens.delete(token);\n  }\n\n  async changePassword(token: string, oldPassword: string, newPassword: string): Promise<void> {\n    const record = this.tokens.get(token);\n    if (!record) {\n      throw new Error('UNAUTHORIZED');\n    }\n    const username = record.user.username;\n\n    // 从数据库读取用户并校验旧密码\n    const dbUser = await withClient(async (client) => {\n      const { rows } = await client.query(\n        'SELECT id, username, password_plain FROM users WHERE username=$1 LIMIT 1',\n        [username],\n      );\n      return rows[0];\n    });\n    if (!dbUser) {\n      throw new Error('UNAUTHORIZED');\n    }\n    if ((dbUser.password_plain || '') !== oldPassword) {\n      throw new Error('INVALID_OLD_PASSWORD');\n    }\n\n    await withClient(async (client) => {\n      await client.query(\n        'UPDATE users SET password_plain=$1, updated_at=NOW() WHERE username=$2',\n        [newPassword, username],\n      );\n    });\n\n    // 可选：使当前token失效，强制重新登录（暂保留现状）\n    // this.tokens.delete(token);\n  }\n\n  private async loadConfig(): Promise<ConfigSchema> {\n    try {\n      return await readJsonc<ConfigSchema>('config/config.jsonc');\n    } catch (e) {\n      return {};\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/AuthServiceAdapter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getAuthService' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ip' is defined but never used. Allowed unused args must match /^_/u.","line":37,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 认证服务适配器\n *\n * 目的:\n * - 统一新旧AuthService的接口\n * - 使AuthController无需感知底层服务版本\n * - 渐进式迁移，保持向后兼容\n */\n\nimport { AuthService, AuthUser, LoginResult } from '@/services/AuthService';\nimport { AuthServiceV2, getAuthService } from '@/services/AuthServiceV2';\nimport logger from '@/utils/logger';\nimport { authService, isAuthV2 } from '@/services/authInstance';\n\n// 统一的接口定义\nexport interface IAuthServiceAdapter {\n  login(username: string, password: string, ip?: string): Promise<LoginResult>;\n  profile(token: string): Promise<AuthUser>;\n  logout(token: string): Promise<void>;\n  changePassword(\n    token: string,\n    oldPassword: string,\n    newPassword: string\n  ): Promise<void>;\n  refreshToken?(refreshToken: string): Promise<LoginResult>;\n}\n\n/**\n * V1服务适配器\n */\nexport class AuthServiceV1Adapter implements IAuthServiceAdapter {\n  constructor(private service: AuthService) {}\n\n  async login(\n    username: string,\n    password: string,\n    ip?: string,\n  ): Promise<LoginResult> {\n    // V1不支持IP参数，忽略\n    return this.service.login(username, password);\n  }\n\n  async profile(token: string): Promise<AuthUser> {\n    return this.service.profile(token);\n  }\n\n  async logout(token: string): Promise<void> {\n    await this.service.logout(token);\n  }\n\n  async changePassword(\n    token: string,\n    oldPassword: string,\n    newPassword: string,\n  ): Promise<void> {\n    await this.service.changePassword(token, oldPassword, newPassword);\n  }\n}\n\n/**\n * V2服务适配器\n */\nexport class AuthServiceV2Adapter implements IAuthServiceAdapter {\n  constructor(private service: AuthServiceV2) {}\n\n  async login(\n    username: string,\n    password: string,\n    ip?: string,\n  ): Promise<LoginResult> {\n    return this.service.login(username, password, ip);\n  }\n\n  async profile(token: string): Promise<AuthUser> {\n    const result = await this.service.validateToken(token);\n    if (!result.valid || !result.user) {\n      throw new Error(result.error || 'TOKEN_INVALID');\n    }\n    return result.user;\n  }\n\n  async logout(token: string): Promise<void> {\n    await this.service.logout(token);\n  }\n\n  async changePassword(\n    token: string,\n    oldPassword: string,\n    newPassword: string,\n  ): Promise<void> {\n    // V2需要userId，从token中提取\n    const result = await this.service.validateToken(token);\n    if (!result.valid || !result.user) {\n      throw new Error('UNAUTHORIZED');\n    }\n    await this.service.changePassword(result.user.id, oldPassword, newPassword);\n  }\n\n  async refreshToken(refreshToken: string): Promise<LoginResult> {\n    return this.service.refreshToken(refreshToken);\n  }\n}\n\n/**\n * 创建适配器工厂函数\n */\nexport function createAuthServiceAdapter(\n  service: AuthService | AuthServiceV2,\n  isV2: boolean,\n): IAuthServiceAdapter {\n  if (isV2) {\n    logger.debug('创建AuthServiceV2Adapter');\n    return new AuthServiceV2Adapter(service as AuthServiceV2);\n  } else {\n    logger.debug('创建AuthServiceV1Adapter');\n    return new AuthServiceV1Adapter(service as AuthService);\n  }\n}\n\n/**\n * 获取适配后的认证服务\n */\nexport function getAuthServiceAdapter(): IAuthServiceAdapter {\n\n  return createAuthServiceAdapter(authService, isAuthV2);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/AuthServiceV2.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3453,3456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3453,3456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":260,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6582,6585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6582,6585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":301,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7634,7637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7634,7637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":340,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8673,8676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8673,8676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":576,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":576,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15082,15085],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15082,15085],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 增强版认证服务 V2\n *\n * 安全特性:\n * - bcrypt密码哈希验证\n * - JWT token签名与验证\n * - Redis可选支持（Token黑名单、会话管理）\n * - 速率限制集成\n * - 审计日志记录\n *\n * 向后兼容:\n * - 保留原AuthService接口\n * - 支持渐进式迁移\n */\n\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\nimport Redis from 'ioredis';\nimport { withClient } from '@/utils/db';\nimport { generateId } from '@/utils/helpers';\nimport { EnvManager } from '@/config/EnvManager';\nimport logger from '@/utils/logger';\nimport { AuthenticationError, ValidationError, ResourceError, BusinessLogicError } from '@/types/errors';\n\n// ==================== 类型定义 ====================\n\nexport interface AuthUser {\n  id: string;\n  username: string;\n  email: string;\n  role: string;\n}\n\nexport interface LoginResult {\n  token: string;\n  refreshToken?: string;\n  user: AuthUser;\n  expiresIn: number; // seconds\n}\n\nexport interface JWTPayload {\n  sub: string;       // user id\n  username: string;\n  role: string;\n  iat: number;       // issued at\n  exp: number;       // expires at\n  jti?: string;      // JWT ID (用于黑名单)\n}\n\nexport interface TokenValidationResult {\n  valid: boolean;\n  user?: AuthUser;\n  error?: string;\n}\n\ninterface DbUser {\n  id: string;\n  username: string;\n  email: string | null;\n  password_hash: string;\n  role: string | null;\n  status: string;\n  failed_login_attempts: number | null;\n  locked_until: Date | null;\n  last_login_at: Date | null;\n}\n\n// ==================== 配置常量 ====================\n\nconst SALT_ROUNDS = 12;                          // bcrypt盐轮数\nconst DEFAULT_TOKEN_TTL = 24 * 60 * 60;          // 24小时\nconst REFRESH_TOKEN_TTL = 7 * 24 * 60 * 60;      // 7天\nconst MAX_FAILED_ATTEMPTS = 5;                   // 最大失败次数\nconst ACCOUNT_LOCK_DURATION = 15 * 60;           // 锁定15分钟\nconst TOKEN_BLACKLIST_PREFIX = 'auth:blacklist:'; // Redis黑名单前缀\nconst SESSION_PREFIX = 'auth:session:';          // Redis会话前缀\n\n// ==================== 主服务类 ====================\n\nexport class AuthServiceV2 {\n  private redis: Redis | null = null;\n  private tokenSecret: string;\n  private tokenTTL: number;\n\n  constructor() {\n    const envManager = EnvManager.getInstance();\n\n    // 获取JWT密钥\n    this.tokenSecret = envManager.get('TOKEN_SECRET');\n    if (!this.tokenSecret || this.tokenSecret.length < 32) {\n      throw new Error(\n        'TOKEN_SECRET must be set and at least 32 characters long for security',\n      );\n    }\n\n    // 获取Token有效期\n    this.tokenTTL = envManager.getInt('TOKEN_TTL_SECONDS', DEFAULT_TOKEN_TTL);\n\n    // 初始化Redis（可选）\n    this.initRedis();\n  }\n\n  /**\n   * 初始化Redis连接（如果配置）\n   */\n  private initRedis(): void {\n    const envManager = EnvManager.getInstance();\n    const redisHost = envManager.get('REDIS_HOST', '');\n\n    if (!redisHost) {\n      logger.info('Redis未配置，使用内存模式（单实例部署）');\n      return;\n    }\n\n    try {\n      this.redis = new Redis({\n        host: envManager.get('REDIS_HOST'),\n        port: envManager.getInt('REDIS_PORT', 6379),\n        password: envManager.get('REDIS_PASSWORD', ''),\n        db: envManager.getInt('REDIS_DB', 0),\n        retryStrategy: (times: number) => {\n          if (times > 3) {\n            logger.error('Redis连接失败，切换到内存模式');\n            return null; // 停止重试\n          }\n          return Math.min(times * 200, 2000);\n        },\n      });\n\n      this.redis.on('connect', () => {\n        logger.info('✅ Redis连接成功，Token存储启用');\n      });\n\n      this.redis.on('error', (err: Error) => {\n        logger.error('Redis错误，将降级到内存模式', { error: err.message });\n      });\n    } catch (error: any) {\n      logger.error('Redis初始化失败，使用内存模式', { error: error.message });\n      this.redis = null;\n    }\n  }\n\n  /**\n   * 用户登录\n   */\n  async login(username: string, password: string, ip?: string): Promise<LoginResult> {\n    logger.info('登录尝试', { username, ip });\n\n    // 1. 查询用户\n    const dbUser = await this.findUserByUsername(username);\n\n    if (!dbUser) {\n      logger.warn('登录失败：用户不存在', { username, ip });\n      throw new AuthenticationError({\n        message: '用户名或密码错误',\n        code: 'INVALID_CREDENTIALS',\n      });\n    }\n\n    // 2. 检查账号状态\n    if (dbUser.status !== 'active') {\n      logger.warn('登录失败：账号未激活', { username, status: dbUser.status, ip });\n      throw new BusinessLogicError({\n        message: '账号未激活',\n        code: 'ACCOUNT_INACTIVE',\n        rule: 'account_status',\n      });\n    }\n\n    // 3. 检查账号锁定\n    if (dbUser.locked_until && new Date(dbUser.locked_until) > new Date()) {\n      const remainingMinutes = Math.ceil(\n        (new Date(dbUser.locked_until).getTime() - Date.now()) / 60000,\n      );\n      logger.warn('登录失败：账号已锁定', {\n        username,\n        lockedUntil: dbUser.locked_until,\n        remainingMinutes,\n        ip,\n      });\n      throw new BusinessLogicError({\n        message: `账号已被锁定，请在 ${remainingMinutes} 分钟后重试`,\n        code: 'ACCOUNT_LOCKED',\n        rule: 'max_login_attempts',\n        data: { remainingMinutes },\n      });\n    }\n\n    // 4. 验证密码\n    const passwordValid = await bcrypt.compare(password, dbUser.password_hash);\n\n    if (!passwordValid) {\n      await this.handleFailedLogin(dbUser.id);\n      logger.warn('登录失败：密码错误', { username, ip });\n      throw new AuthenticationError({\n        message: '用户名或密码错误',\n        code: 'INVALID_CREDENTIALS',\n      });\n    }\n\n    // 5. 重置失败计数\n    await this.resetFailedAttempts(dbUser.id);\n\n    // 6. 更新最后登录时间\n    await this.updateLastLogin(dbUser.id, ip);\n\n    // 7. 生成Token\n    const user: AuthUser = {\n      id: dbUser.id,\n      username: dbUser.username,\n      email: dbUser.email || '',\n      role: dbUser.role || 'user',\n    };\n\n    const token = await this.generateToken(user);\n    const refreshToken = await this.generateRefreshToken(user);\n\n    // 8. 存储会话（如果有Redis）\n    if (this.redis) {\n      await this.storeSession(user.id, token, ip);\n    }\n\n    logger.info('✅ 登录成功', { userId: user.id, username, ip });\n\n    return {\n      token,\n      refreshToken,\n      user,\n      expiresIn: this.tokenTTL,\n    };\n  }\n\n  /**\n   * 验证Token\n   */\n  async validateToken(token: string): Promise<TokenValidationResult> {\n    try {\n      // 1. JWT签名验证\n      const payload = jwt.verify(token, this.tokenSecret) as JWTPayload;\n\n      // 2. 检查黑名单（如果有Redis）\n      if (this.redis && payload.jti) {\n        const isBlacklisted = await this.redis.exists(\n          `${TOKEN_BLACKLIST_PREFIX}${payload.jti}`,\n        );\n        if (isBlacklisted) {\n          return { valid: false, error: 'TOKEN_REVOKED' };\n        }\n      }\n\n      // 3. 构造用户信息\n      const user: AuthUser = {\n        id: payload.sub,\n        username: payload.username,\n        role: payload.role,\n        email: '',\n      };\n\n      return { valid: true, user };\n    } catch (error: any) {\n      if (error.name === 'TokenExpiredError') {\n        return { valid: false, error: 'TOKEN_EXPIRED' };\n      }\n      if (error.name === 'JsonWebTokenError') {\n        return { valid: false, error: 'TOKEN_INVALID' };\n      }\n      logger.error('Token验证失败', { error: error.message });\n      return { valid: false, error: 'TOKEN_VERIFICATION_FAILED' };\n    }\n  }\n\n  /**\n   * 登出（撤销Token）\n   */\n  async logout(token: string): Promise<void> {\n    if (!this.redis) {\n      logger.info('内存模式：登出仅记录日志');\n      return;\n    }\n\n    try {\n      const payload = jwt.decode(token) as JWTPayload;\n      if (!payload?.jti) {\n        return;\n      }\n\n      // 将Token加入黑名单\n      const ttl = payload.exp - Math.floor(Date.now() / 1000);\n      if (ttl > 0) {\n        await this.redis.setex(\n          `${TOKEN_BLACKLIST_PREFIX}${payload.jti}`,\n          ttl,\n          '1',\n        );\n      }\n\n      // 删除会话\n      await this.redis.del(`${SESSION_PREFIX}${payload.sub}`);\n\n      logger.info('✅ 登出成功', { userId: payload.sub, jti: payload.jti });\n    } catch (error: any) {\n      logger.error('登出失败', { error: error.message });\n    }\n  }\n\n  /**\n   * 刷新Token\n   */\n  async refreshToken(refreshToken: string): Promise<LoginResult> {\n    try {\n      const payload = jwt.verify(refreshToken, this.tokenSecret) as JWTPayload;\n\n      // 重新查询用户确保状态正确\n      const dbUser = await this.findUserById(payload.sub);\n      if (!dbUser || dbUser.status !== 'active') {\n        throw new ResourceError({\n          message: '用户不存在或未激活',\n          code: 'USER_NOT_FOUND_OR_INACTIVE',\n          resourceType: 'user',\n          resourceId: payload.sub,\n        });\n      }\n\n      const user: AuthUser = {\n        id: dbUser.id,\n        username: dbUser.username,\n        email: dbUser.email || '',\n        role: dbUser.role || 'user',\n      };\n\n      const newToken = await this.generateToken(user);\n      const newRefreshToken = await this.generateRefreshToken(user);\n\n      return {\n        token: newToken,\n        refreshToken: newRefreshToken,\n        user,\n        expiresIn: this.tokenTTL,\n      };\n    } catch (error: any) {\n      logger.error('Token刷新失败', { error: error.message });\n      throw new AuthenticationError({\n        message: 'Refresh Token 无效或已过期',\n        code: 'REFRESH_TOKEN_INVALID',\n      });\n    }\n  }\n\n  /**\n   * 修改密码\n   */\n  async changePassword(\n    userId: string,\n    oldPassword: string,\n    newPassword: string,\n  ): Promise<void> {\n    // 1. 查询用户\n    const dbUser = await this.findUserById(userId);\n    if (!dbUser) {\n      throw new ResourceError({\n        message: '用户不存在',\n        code: 'USER_NOT_FOUND',\n        resourceType: 'user',\n        resourceId: userId,\n      });\n    }\n\n    // 2. 验证旧密码\n    const oldPasswordValid = await bcrypt.compare(oldPassword, dbUser.password_hash);\n    if (!oldPasswordValid) {\n      throw new AuthenticationError({\n        message: '原密码错误',\n        code: 'INVALID_OLD_PASSWORD',\n      });\n    }\n\n    // 3. 验证新密码强度\n    this.validatePasswordStrength(newPassword);\n\n    // 4. 生成新密码哈希\n    const newPasswordHash = await bcrypt.hash(newPassword, SALT_ROUNDS);\n\n    // 5. 更新数据库\n    await withClient(async (client) => {\n      await client.query(\n        `UPDATE users \n         SET password_hash = $1, password_updated_at = CURRENT_TIMESTAMP \n         WHERE id = $2`,\n        [newPasswordHash, userId],\n      );\n    });\n\n    // 6. 撤销所有现有Token（强制重新登录）\n    if (this.redis) {\n      await this.redis.del(`${SESSION_PREFIX}${userId}`);\n    }\n\n    logger.info('✅ 密码修改成功', { userId });\n  }\n\n  /**\n   * 创建新用户（注册）\n   */\n  async register(\n    username: string,\n    password: string,\n    email?: string,\n  ): Promise<AuthUser> {\n    // 1. 验证密码强度\n    this.validatePasswordStrength(password);\n\n    // 2. 检查用户名是否已存在\n    const existingUser = await this.findUserByUsername(username);\n    if (existingUser) {\n      throw new BusinessLogicError({\n        message: '用户名已存在',\n        code: 'USERNAME_ALREADY_EXISTS',\n        rule: 'unique_username',\n        data: { username },\n      });\n    }\n\n    // 3. 生成密码哈希\n    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);\n\n    // 4. 插入数据库\n    const userId = generateId();\n    await withClient(async (client) => {\n      await client.query(\n        `INSERT INTO users (id, username, email, password_hash, role, status, created_at, updated_at)\n         VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,\n        [userId, username, email || null, passwordHash, 'user', 'active'],\n      );\n    });\n\n    logger.info('✅ 用户注册成功', { userId, username });\n\n    return {\n      id: userId,\n      username,\n      email: email || '',\n      role: 'user',\n    };\n  }\n\n  /**\n   * 获取用户信息（通过token）\n   */\n  async profile(token: string): Promise<AuthUser> {\n    const result = await this.validateToken(token);\n    if (!result.valid || !result.user) {\n      throw new AuthenticationError({\n        message: 'Token 验证失败',\n        code: result.error || 'UNAUTHORIZED',\n      });\n    }\n    return result.user;\n  }\n\n  // ==================== 私有辅助方法 ====================\n\n  private async generateToken(user: AuthUser): Promise<string> {\n    const jti = generateId();\n    const payload: JWTPayload = {\n      sub: user.id,\n      username: user.username,\n      role: user.role || 'user',\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + this.tokenTTL,\n      jti,\n    };\n\n    return jwt.sign(payload, this.tokenSecret);\n  }\n\n  private async generateRefreshToken(user: AuthUser): Promise<string> {\n    const payload: JWTPayload = {\n      sub: user.id,\n      username: user.username,\n      role: user.role || 'user',\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + REFRESH_TOKEN_TTL,\n    };\n\n    return jwt.sign(payload, this.tokenSecret);\n  }\n\n  private async findUserByUsername(username: string): Promise<DbUser | null> {\n    const result = await withClient(async (client) => {\n      const { rows } = await client.query<DbUser>(\n        `SELECT id, username, email, password_hash, role, status, \n                failed_login_attempts, locked_until, last_login_at\n         FROM users \n         WHERE username = $1 \n         LIMIT 1`,\n        [username],\n      );\n      return rows[0] || null;\n    });\n    return result;\n  }\n\n  private async findUserById(userId: string): Promise<DbUser | null> {\n    const result = await withClient(async (client) => {\n      const { rows } = await client.query<DbUser>(\n        `SELECT id, username, email, password_hash, role, status, \n                failed_login_attempts, locked_until, last_login_at\n         FROM users \n         WHERE id = $1 \n         LIMIT 1`,\n        [userId],\n      );\n      return rows[0] || null;\n    });\n    return result;\n  }\n\n  private async handleFailedLogin(userId: string): Promise<void> {\n    await withClient(async (client) => {\n      // 增加失败次数\n      await client.query(\n        `UPDATE users \n         SET failed_login_attempts = COALESCE(failed_login_attempts, 0) + 1 \n         WHERE id = $1`,\n        [userId],\n      );\n\n      // 检查是否需要锁定\n      const { rows } = await client.query(\n        'SELECT failed_login_attempts FROM users WHERE id = $1',\n        [userId],\n      );\n\n      const attempts = rows[0]?.failed_login_attempts || 0;\n      if (attempts >= MAX_FAILED_ATTEMPTS) {\n        const lockUntil = new Date(Date.now() + ACCOUNT_LOCK_DURATION * 1000);\n        await client.query(\n          'UPDATE users SET locked_until = $1 WHERE id = $2',\n          [lockUntil, userId],\n        );\n        logger.warn('账号已锁定', { userId, lockUntil });\n      }\n    });\n  }\n\n  private async resetFailedAttempts(userId: string): Promise<void> {\n    await withClient(async (client) => {\n      await client.query(\n        'UPDATE users SET failed_login_attempts = 0, locked_until = NULL WHERE id = $1',\n        [userId],\n      );\n    });\n  }\n\n  private async updateLastLogin(userId: string, ip?: string): Promise<void> {\n    await withClient(async (client) => {\n      await client.query(\n        'UPDATE users SET last_login_at = CURRENT_TIMESTAMP, last_login_ip = $1 WHERE id = $2',\n        [ip || null, userId],\n      );\n    });\n  }\n\n  private async storeSession(userId: string, token: string, ip?: string): Promise<void> {\n    if (!this.redis) {\n      return;\n    }\n\n    try {\n      const sessionData = JSON.stringify({\n        token,\n        ip,\n        createdAt: new Date().toISOString(),\n      });\n      await this.redis.setex(`${SESSION_PREFIX}${userId}`, this.tokenTTL, sessionData);\n    } catch (error: any) {\n      logger.error('会话存储失败', { userId, error: error.message });\n    }\n  }\n\n  private validatePasswordStrength(password: string): void {\n    if (password.length < 8) {\n      throw new ValidationError({\n        message: '密码长度至少8位',\n        code: 'PASSWORD_TOO_SHORT',\n        field: 'password',\n      });\n    }\n    if (!/[A-Z]/.test(password)) {\n      throw new ValidationError({\n        message: '密码必须包含大写字母',\n        code: 'PASSWORD_MISSING_UPPERCASE',\n        field: 'password',\n      });\n    }\n    if (!/[a-z]/.test(password)) {\n      throw new ValidationError({\n        message: '密码必须包含小写字母',\n        code: 'PASSWORD_MISSING_LOWERCASE',\n        field: 'password',\n      });\n    }\n    if (!/[0-9]/.test(password)) {\n      throw new ValidationError({\n        message: '密码必须包含数字',\n        code: 'PASSWORD_MISSING_NUMBER',\n        field: 'password',\n      });\n    }\n    if (!/[!@#$%^&*()_+\\-=[\\]{};':\"\\\\|,.<>/?]/.test(password)) {\n      throw new ValidationError({\n        message: '密码必须包含特殊字符',\n        code: 'PASSWORD_MISSING_SPECIAL_CHAR',\n        field: 'password',\n      });\n    }\n  }\n\n  /**\n   * 清理资源\n   */\n  async close(): Promise<void> {\n    if (this.redis) {\n      await this.redis.quit();\n      logger.info('Redis连接已关闭');\n    }\n  }\n}\n\n// 导出单例\nlet authServiceInstance: AuthServiceV2 | null = null;\n\nexport function getAuthService(): AuthServiceV2 {\n  if (!authServiceInstance) {\n    authServiceInstance = new AuthServiceV2();\n  }\n  return authServiceInstance;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/CacheService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":447,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":447,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9532,9535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9532,9535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":453,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":453,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9699,9702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9699,9702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Redis 缓存服务\n * 提供统一的缓存接口，支持多实例共享状态\n */\n\nimport Redis from 'ioredis';\nimport logger from '@/utils/logger';\n\nexport interface CacheOptions {\n  ttl?: number;        // 过期时间（秒）\n  nx?: boolean;        // 仅当 key 不存在时设置\n  prefix?: string;     // key 前缀\n}\n\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  sets: number;\n  dels: number;\n  errors: number;\n  hitRate: number;\n}\n\n/**\n * Redis 缓存服务类\n */\nexport class CacheService {\n  private client: Redis | null = null;\n  private connected = false;\n  private stats: CacheStats = {\n    hits: 0,\n    misses: 0,\n    sets: 0,\n    dels: 0,\n    errors: 0,\n    hitRate: 0,\n  };\n\n  private readonly prefix: string = 'llmchat';\n  private readonly defaultTTL: number = 300; // 5 分钟\n\n  /**\n   * 检查是否已连接\n   */\n  isConnected(): boolean {\n    return this.connected && this.client !== null;\n  }\n\n  /**\n   * 连接到 Redis\n   */\n  async connect(): Promise<void> {\n    if (this.connected && this.client) {\n      return;\n    }\n\n    const redisHost = process.env.REDIS_HOST;\n    const redisPort = parseInt(process.env.REDIS_PORT || '6379', 10);\n    const redisPassword = process.env.REDIS_PASSWORD;\n\n    if (!redisHost) {\n      logger.warn('Redis 未配置，缓存功能将被禁用');\n      return;\n    }\n\n    try {\n      this.client = new Redis({\n        host: redisHost,\n        port: redisPort,\n        ...(redisPassword ? { password: redisPassword } : {}),\n        retryStrategy: (times) => {\n          if (times > 10) {\n            logger.error('Redis 重连次数超过限制');\n            return null;\n          }\n          return Math.min(times * 100, 3000);\n        },\n        maxRetriesPerRequest: 3,\n      });\n\n      this.client.on('error', (err) => {\n        logger.error('Redis 客户端错误', { error: err });\n        this.stats.errors++;\n      });\n\n      this.client.on('connect', () => {\n        logger.info('Redis 连接成功');\n        this.connected = true;\n      });\n\n      this.client.on('close', () => {\n        logger.warn('Redis 连接断开');\n        this.connected = false;\n      });\n\n      this.client.on('reconnecting', () => {\n        logger.info('Redis 重新连接中...');\n      });\n\n      // ioredis 自动连接，不需要显式调用 connect()\n      // 等待连接完成\n      await this.client.ping();\n      this.connected = true;\n\n      logger.info('✓ Redis 缓存服务已启动', { prefix: this.prefix, defaultTTL: this.defaultTTL });\n    } catch (error) {\n      logger.error('Redis 连接失败', { error });\n      this.client = null;\n      this.connected = false;\n    }\n  }\n\n  /**\n   * 断开 Redis 连接\n   */\n  async disconnect(): Promise<void> {\n    if (this.client) {\n      await this.client.quit();\n      this.connected = false;\n      logger.info('Redis 连接已关闭');\n    }\n  }\n\n  /**\n   * 生成完整的 key（带前缀）\n   */\n  private getFullKey(key: string, prefix?: string): string {\n    const p = prefix || this.prefix;\n    return `${p}:${key}`;\n  }\n\n  /**\n   * 获取缓存\n   */\n  async get<T>(key: string, options?: CacheOptions): Promise<T | null> {\n    if (!this.client || !this.connected) {\n      return null;\n    }\n\n    try {\n      const fullKey = this.getFullKey(key, options?.prefix);\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        this.stats.misses++;\n        return null;\n      }\n\n      this.stats.hits++;\n      this.updateHitRate();\n\n      return JSON.parse(value) as T;\n    } catch (error) {\n      logger.error('缓存读取失败', { key, error });\n      this.stats.errors++;\n      return null;\n    }\n  }\n\n  /**\n   * 设置缓存\n   */\n  async set<T>(key: string, value: T, options?: CacheOptions): Promise<boolean> {\n    if (!this.client || !this.connected) {\n      return false;\n    }\n\n    try {\n      const fullKey = this.getFullKey(key, options?.prefix);\n      const ttl = options?.ttl || this.defaultTTL;\n      const serialized = JSON.stringify(value);\n\n      if (options?.nx) {\n        // 仅当 key 不存在时设置（用于分布式锁）\n        const result = await this.client.set(fullKey, serialized, 'EX', ttl, 'NX');\n        this.stats.sets++;\n        return result === 'OK';\n      } else {\n        await this.client.setex(fullKey, ttl, serialized);\n        this.stats.sets++;\n        return true;\n      }\n    } catch (error) {\n      logger.error('缓存写入失败', { key, error });\n      this.stats.errors++;\n      return false;\n    }\n  }\n\n  /**\n   * 删除缓存\n   */\n  async del(key: string, options?: CacheOptions): Promise<boolean> {\n    if (!this.client || !this.connected) {\n      return false;\n    }\n\n    try {\n      const fullKey = this.getFullKey(key, options?.prefix);\n      const result = await this.client.del(fullKey);\n      this.stats.dels++;\n      return result > 0;\n    } catch (error) {\n      logger.error('缓存删除失败', { key, error });\n      this.stats.errors++;\n      return false;\n    }\n  }\n\n  /**\n   * 批量删除（通过模式匹配）\n   */\n  async delPattern(pattern: string, options?: CacheOptions): Promise<number> {\n    if (!this.client || !this.connected) {\n      return 0;\n    }\n\n    try {\n      const fullPattern = this.getFullKey(pattern, options?.prefix);\n      const keys = await this.client.keys(fullPattern);\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      const result = await this.client.del(keys);\n      this.stats.dels += result;\n      return result;\n    } catch (error) {\n      logger.error('批量删除缓存失败', { pattern, error });\n      this.stats.errors++;\n      return 0;\n    }\n  }\n\n  /**\n   * 检查 key 是否存在\n   */\n  async exists(key: string, options?: CacheOptions): Promise<boolean> {\n    if (!this.client || !this.connected) {\n      return false;\n    }\n\n    try {\n      const fullKey = this.getFullKey(key, options?.prefix);\n      const result = await this.client.exists(fullKey);\n      return result > 0;\n    } catch (error) {\n      logger.error('检查缓存存在失败', { key, error });\n      return false;\n    }\n  }\n\n  /**\n   * 设置过期时间\n   */\n  async expire(key: string, ttl: number, options?: CacheOptions): Promise<boolean> {\n    if (!this.client || !this.connected) {\n      return false;\n    }\n\n    try {\n      const fullKey = this.getFullKey(key, options?.prefix);\n      const result = await this.client.expire(fullKey, ttl);\n      return result === 1;\n    } catch (error) {\n      logger.error('设置缓存过期时间失败', { key, ttl, error });\n      return false;\n    }\n  }\n\n  /**\n   * 原子递增\n   */\n  async incr(key: string, options?: CacheOptions): Promise<number> {\n    if (!this.client || !this.connected) {\n      return 0;\n    }\n\n    try {\n      const fullKey = this.getFullKey(key, options?.prefix);\n      const result = await this.client.incr(fullKey);\n\n      // 如果是新 key，设置过期时间\n      if (result === 1 && options?.ttl) {\n        await this.client.expire(fullKey, options.ttl);\n      }\n\n      return result;\n    } catch (error) {\n      logger.error('缓存递增失败', { key, error });\n      this.stats.errors++;\n      return 0;\n    }\n  }\n\n  /**\n   * 获取或设置缓存（缓存未命中时执行 fallback）\n   */\n  async getOrSet<T>(\n    key: string,\n    fallback: () => Promise<T>,\n    options?: CacheOptions,\n  ): Promise<T | null> {\n    // 尝试从缓存获取\n    const cached = await this.get<T>(key, options);\n    if (cached !== null) {\n      return cached;\n    }\n\n    try {\n      // 缓存未命中，执行 fallback\n      const value = await fallback();\n\n      // 写入缓存\n      await this.set(key, value, options);\n\n      return value;\n    } catch (error) {\n      logger.error('getOrSet fallback 执行失败', { key, error });\n      return null;\n    }\n  }\n\n  /**\n   * 分布式锁（简单实现）\n   */\n  async lock(key: string, ttl: number = 10): Promise<boolean> {\n    return this.set(`lock:${key}`, Date.now(), { ttl, nx: true });\n  }\n\n  /**\n   * 释放分布式锁\n   */\n  async unlock(key: string): Promise<boolean> {\n    return this.del(`lock:${key}`);\n  }\n\n  /**\n   * 更新命中率\n   */\n  private updateHitRate(): void {\n    const total = this.stats.hits + this.stats.misses;\n    this.stats.hitRate = total > 0 ? (this.stats.hits / total) * 100 : 0;\n  }\n\n  /**\n   * 获取统计信息\n   */\n  getStats(): CacheStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * 重置统计信息\n   */\n  resetStats(): void {\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      dels: 0,\n      errors: 0,\n      hitRate: 0,\n    };\n  }\n\n  /**\n   * Ping Redis\n   */\n  async ping(): Promise<boolean> {\n    if (!this.client || !this.connected) {\n      return false;\n    }\n\n    try {\n      const result = await this.client.ping();\n      return result === 'PONG';\n    } catch (error) {\n      logger.error('Redis ping 失败', { error });\n      return false;\n    }\n  }\n\n  /**\n   * 健康检查\n   */\n  async healthCheck(): Promise<{ status: string; details: { stats: CacheStats; redisConnected: boolean } }> {\n    if (!this.client) {\n      return {\n        status: 'down',\n        details: {\n          stats: this.stats,\n          redisConnected: false,\n        },\n      };\n    }\n\n    try {\n      const pong = await this.client.ping();\n      return {\n        status: pong === 'PONG' ? 'healthy' : 'degraded',\n        details: {\n          stats: this.stats,\n          redisConnected: this.connected,\n        },\n      };\n    } catch (error) {\n      return {\n        status: 'down',\n        details: {\n          stats: this.stats,\n          redisConnected: false,\n        },\n      };\n    }\n  }\n}\n\n// 全局单例\nlet cacheServiceInstance: CacheService | null = null;\n\n/**\n * 获取缓存服务实例\n */\nexport function getCacheService(): CacheService {\n  if (!cacheServiceInstance) {\n    cacheServiceInstance = new CacheService();\n  }\n  return cacheServiceInstance;\n}\n\n/**\n * 初始化缓存服务\n */\nexport async function initCacheService(): Promise<CacheService> {\n  const service = getCacheService();\n  await service.connect();\n  return service;\n}\n\n/**\n * 缓存装饰器（用于方法级缓存）\n */\nexport function Cacheable(key: string, ttl: number = 300) {\n  return function (\n    _target: any,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const cache = getCacheService();\n      const cacheKey = `${key}:${JSON.stringify(args)}`;\n\n      // 尝试从缓存获取\n      const cached = await cache.get(cacheKey);\n      if (cached !== null) {\n        return cached;\n      }\n\n      // 缓存未命中，执行原方法\n      const result = await originalMethod.apply(this, args);\n\n      // 写入缓存\n      await cache.set(cacheKey, result, { ttl });\n\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n\nexport default CacheService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/CadOperationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/CadParserService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2020,2023],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2020,2023],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3142,3145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3142,3145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3788,3791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3788,3791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CAD 文件解析服务\n *\n * 使用 dxf-parser 解析 DXF 文件\n */\n\nimport DxfParser from 'dxf-parser';\nimport {\n  DxfEntity,\n  CadFileInfo,\n  Point3D,\n  LineEntity,\n  CircleEntity,\n  ArcEntity,\n  PolylineEntity,\n  TextEntity,\n  DxfEntityType,\n} from '@llmchat/shared-types';\nimport logger from '@/utils/logger';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * CAD 解析服务类\n */\nexport class CadParserService {\n  private parser: DxfParser;\n\n  constructor() {\n    this.parser = new DxfParser();\n  }\n\n  /**\n   * 解析 DXF 文件内容\n   */\n  parseDxf(dxfContent: string): {\n    entities: DxfEntity[];\n    layers: string[];\n    bounds?: CadFileInfo['bounds'];\n  } {\n    try {\n      logger.debug('[CadParserService] 开始解析 DXF 文件');\n\n      const dxf = this.parser.parseSync(dxfContent);\n\n      if (!dxf?.entities) {\n        throw new Error('DXF 文件解析失败：无法读取实体');\n      }\n\n      const entities: DxfEntity[] = [];\n      const layersSet = new Set<string>();\n      const minX = Infinity, minY = Infinity;\n      const maxX = -Infinity, maxY = -Infinity;\n\n      // 转换实体\n      for (const entity of dxf.entities) {\n        const converted = this.convertEntity(entity);\n        if (converted) {\n          entities.push(converted);\n          layersSet.add(converted.layer);\n\n          // 更新边界\n          this.updateBounds(converted, { minX, minY, maxX, maxY });\n        }\n      }\n\n      const bounds = {\n        minX: isFinite(minX) ? minX : 0,\n        minY: isFinite(minY) ? minY : 0,\n        maxX: isFinite(maxX) ? maxX : 0,\n        maxY: isFinite(maxY) ? maxY : 0,\n      };\n\n      logger.info('[CadParserService] DXF 解析完成', {\n        entityCount: entities.length,\n        layerCount: layersSet.size,\n        bounds,\n      });\n\n      return {\n        entities,\n        layers: Array.from(layersSet),\n        bounds,\n      };\n    } catch (error) {\n      logger.error('[CadParserService] DXF 解析失败', { error });\n      throw new Error(`DXF 文件解析失败: ${error instanceof Error ? error.message : '未知错误'}`);\n    }\n  }\n\n  /**\n   * 转换实体为统一格式\n   */\n  private convertEntity(entity: any): DxfEntity | null {\n    const baseEntity = {\n      handle: entity.handle || uuidv4(),\n      layer: entity.layer || '0',\n      color: entity.color,\n      lineType: entity.lineType,\n    };\n\n    switch (entity.type) {\n      case 'LINE':\n        return {\n          ...baseEntity,\n          type: 'LINE',\n          start: this.toPoint3D(entity.vertices[0]),\n          end: this.toPoint3D(entity.vertices[1]),\n        } as LineEntity;\n\n      case 'CIRCLE':\n        return {\n          ...baseEntity,\n          type: 'CIRCLE',\n          center: this.toPoint3D(entity.center),\n          radius: entity.radius || 0,\n        } as CircleEntity;\n\n      case 'ARC':\n        return {\n          ...baseEntity,\n          type: 'ARC',\n          center: this.toPoint3D(entity.center),\n          radius: entity.radius || 0,\n          startAngle: entity.startAngle || 0,\n          endAngle: entity.endAngle || 0,\n        } as ArcEntity;\n\n      case 'LWPOLYLINE':\n      case 'POLYLINE':\n        return {\n          ...baseEntity,\n          type: entity.type as 'POLYLINE' | 'LWPOLYLINE',\n          vertices: (entity.vertices || []).map((v: any) => this.toPoint3D(v)),\n          closed: entity.shape || false,\n        } as PolylineEntity;\n\n      case 'TEXT':\n      case 'MTEXT':\n        return {\n          ...baseEntity,\n          type: entity.type as 'TEXT' | 'MTEXT',\n          position: this.toPoint3D(entity.startPoint || entity.position),\n          text: entity.text || '',\n          height: entity.textHeight || entity.height || 1,\n          rotation: entity.rotation || 0,\n        } as TextEntity;\n\n      default:\n        logger.debug('[CadParserService] 跳过不支持的实体类型', { type: entity.type });\n        return null;\n    }\n  }\n\n  /**\n   * 转换为 Point3D\n   */\n  private toPoint3D(point: any): Point3D {\n    return {\n      x: point?.x || 0,\n      y: point?.y || 0,\n      z: point?.z || 0,\n    };\n  }\n\n  /**\n   * 更新边界\n   */\n  private updateBounds(\n    entity: DxfEntity,\n    bounds: { minX: number; minY: number; maxX: number; maxY: number },\n  ): void {\n    const points: Point3D[] = [];\n\n    switch (entity.type) {\n      case 'LINE':\n        points.push(entity.start, entity.end);\n        break;\n      case 'CIRCLE':\n        points.push(\n          { x: entity.center.x - entity.radius, y: entity.center.y - entity.radius, z: 0 },\n          { x: entity.center.x + entity.radius, y: entity.center.y + entity.radius, z: 0 },\n        );\n        break;\n      case 'ARC':\n        points.push(\n          { x: entity.center.x - entity.radius, y: entity.center.y - entity.radius, z: 0 },\n          { x: entity.center.x + entity.radius, y: entity.center.y + entity.radius, z: 0 },\n        );\n        break;\n      case 'POLYLINE':\n      case 'LWPOLYLINE':\n        points.push(...entity.vertices);\n        break;\n      case 'TEXT':\n      case 'MTEXT':\n        points.push(entity.position);\n        break;\n    }\n\n    for (const point of points) {\n      bounds.minX = Math.min(bounds.minX, point.x);\n      bounds.minY = Math.min(bounds.minY, point.y);\n      bounds.maxX = Math.max(bounds.maxX, point.x);\n      bounds.maxY = Math.max(bounds.maxY, point.y);\n    }\n  }\n\n  /**\n   * 生成 DXF 文件摘要\n   */\n  generateSummary(entities: DxfEntity[]): string {\n    const typeCount: Record<string, number> = {};\n    const layerCount: Record<string, number> = {};\n\n    for (const entity of entities) {\n      typeCount[entity.type] = (typeCount[entity.type] || 0) + 1;\n      layerCount[entity.layer] = (layerCount[entity.layer] || 0) + 1;\n    }\n\n    const summary = [\n      `图纸包含 ${entities.length} 个实体`,\n      `实体类型分布: ${Object.entries(typeCount).map(([type, count]) => `${type}(${count})`).join(', ')}`,\n      `图层分布: ${Object.entries(layerCount).map(([layer, count]) => `${layer}(${count})`).join(', ')}`,\n    ];\n\n    return summary.join('\\n');\n  }\n\n  /**\n   * 查询实体\n   */\n  queryEntities(\n    entities: DxfEntity[],\n    filter?: { type?: DxfEntityType; layer?: string },\n  ): DxfEntity[] {\n    let results = entities;\n\n    if (filter?.type) {\n      results = results.filter(e => e.type === filter.type);\n    }\n\n    if (filter?.layer) {\n      results = results.filter(e => e.layer === filter.layer);\n    }\n\n    return results;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/ChatHistoryService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[381,384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[381,384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1283,1286],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1283,1286],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3464,3467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3464,3467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4075,4078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4075,4078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { withClient } from '@/utils/db';\nimport { generateId } from '@/utils/helpers';\n\nexport interface ChatHistoryQueryOptions {\n  limit?: number;\n  offset?: number;\n  roles?: Array<'user' | 'assistant' | 'system'>;\n}\n\nexport interface StoredChatMessage {\n  id: string;\n  sessionId: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  metadata?: Record<string, any> | null;\n  createdAt: string;\n}\n\nexport interface StoredChatSession {\n  id: string;\n  agentId: string;\n  title: string | null;\n  userId: string | null;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport class ChatHistoryService {\n  async ensureSession(sessionId: string, agentId: string, title?: string | null): Promise<void> {\n    await withClient(async (client) => {\n      await client.query(\n        `INSERT INTO chat_sessions (id, agent_id, title)\n         VALUES ($1, $2, $3)\n         ON CONFLICT (id) DO UPDATE SET\n           agent_id = EXCLUDED.agent_id,\n           title = COALESCE(EXCLUDED.title, chat_sessions.title),\n           updated_at = NOW()`,\n        [sessionId, agentId, title || null],\n      );\n    });\n  }\n\n  async appendMessage(params: {\n    sessionId: string;\n    agentId: string;\n    role: 'user' | 'assistant' | 'system';\n    content: string;\n    metadata?: Record<string, any> | null;\n    messageId?: string;\n    titleHint?: string;\n  }): Promise<string> {\n    const messageId = params.messageId || generateId();\n    await withClient(async (client) => {\n      await client.query('BEGIN');\n      try {\n        await client.query(\n          `INSERT INTO chat_sessions (id, agent_id, title)\n           VALUES ($1,$2,$3)\n           ON CONFLICT (id) DO UPDATE SET\n             agent_id = EXCLUDED.agent_id,\n             title = COALESCE(EXCLUDED.title, chat_sessions.title),\n             updated_at = NOW()`\n          , [params.sessionId, params.agentId, params.titleHint || null],\n        );\n\n        await client.query(\n          `INSERT INTO chat_messages (id, session_id, role, content, metadata)\n           VALUES ($1,$2,$3,$4,$5::jsonb)`\n          , [\n            messageId,\n            params.sessionId,\n            params.role,\n            params.content,\n            JSON.stringify(params.metadata ?? null),\n          ],\n        );\n\n        await client.query(\n          `UPDATE chat_sessions\n             SET updated_at = NOW(),\n                 title = COALESCE($2, title)\n           WHERE id = $1`,\n          [params.sessionId, params.titleHint || null],\n        );\n\n        await client.query('COMMIT');\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      }\n    });\n\n    return messageId;\n  }\n\n  async getHistory(sessionId: string, options?: ChatHistoryQueryOptions): Promise<{\n    session: StoredChatSession | null;\n    messages: StoredChatMessage[];\n  }> {\n    const rolesFilter = options?.roles;\n    const limit = Math.min(Math.max(options?.limit ?? 100, 1), 500);\n    const offset = Math.max(options?.offset ?? 0, 0);\n\n    const { session, messages } = await withClient(async (client) => {\n      const sessionResult = await client.query<{\n        id: string;\n        agent_id: string;\n        user_id: string | null;\n        title: string | null;\n        created_at: Date;\n        updated_at: Date;\n      }>('SELECT * FROM chat_sessions WHERE id = $1', [sessionId]);\n\n      const messageQueryParts: string[] = [\n        'SELECT * FROM chat_messages WHERE session_id = $1',\n      ];\n      const params: any[] = [sessionId];\n\n      if (rolesFilter && rolesFilter.length > 0) {\n        messageQueryParts.push(`AND role = ANY($${params.length + 1})`);\n        params.push(rolesFilter);\n      }\n\n      messageQueryParts.push('ORDER BY created_at ASC');\n      messageQueryParts.push(`LIMIT $${params.length + 1}`);\n      params.push(limit);\n      messageQueryParts.push(`OFFSET $${params.length + 1}`);\n      params.push(offset);\n\n      const messagesResult = await client.query<{\n        id: string;\n        session_id: string;\n        role: 'user' | 'assistant' | 'system';\n        content: string;\n        metadata: any;\n        created_at: Date;\n      }>(messageQueryParts.join(' '), params);\n\n      return {\n        session: sessionResult.rows[0] || null,\n        messages: messagesResult.rows,\n      };\n    });\n\n    return {\n      session: session\n        ? {\n          id: session.id,\n          agentId: session.agent_id,\n          title: session.title,\n          userId: session.user_id,\n          createdAt: new Date(session.created_at).toISOString(),\n          updatedAt: new Date(session.updated_at).toISOString(),\n        }\n        : null,\n      messages: messages.map((msg) => ({\n        id: msg.id,\n        sessionId: msg.session_id,\n        role: msg.role,\n        content: msg.content,\n        metadata: msg.metadata ?? null,\n        createdAt: new Date(msg.created_at).toISOString(),\n      })),\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/ChatInitService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3453,3456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3453,3456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4196,4199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4196,4199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4253,4256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4253,4256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport { AgentConfigService } from './AgentConfigService';\nimport { AgentConfig, FastGPTInitResponse } from '@/types';\nimport { AdaptiveTtlPolicy } from '@/utils/adaptiveCache';\nimport logger from '@/utils/logger';\n\n/**\n * 聊天初始化服务\n * 负责调用FastGPT的初始化API并处理流式输出\n */\nexport class ChatInitService {\n  private httpClient: ReturnType<typeof axios.create>;\n  private agentService: AgentConfigService;\n  private cache: Map<string, { data: FastGPTInitResponse; expiresAt: number }> = new Map();\n  private readonly cachePolicy = new AdaptiveTtlPolicy({\n    initialTtl: 5 * 60 * 1000,\n    minTtl: 60 * 1000,\n    maxTtl: 15 * 60 * 1000,\n    step: 60 * 1000,\n    sampleSize: 20,\n    adjustIntervalMs: 2 * 60 * 1000,\n  });\n\n  constructor(agentService: AgentConfigService) {\n    this.agentService = agentService;\n    this.httpClient = axios.create({\n      timeout: 30000,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n  }\n\n  /**\n   * 获取初始化数据（非流式）\n   */\n  async getInitData(appId: string, chatId?: string): Promise<FastGPTInitResponse> {\n    // 检查缓存\n    const cacheKey = `${appId}_${chatId || 'default'}`;\n    const cached = this.cache.get(cacheKey);\n    const now = Date.now();\n    if (cached && cached.expiresAt > now) {\n      logger.debug('✅ 使用缓存的初始化数据');\n      this.cachePolicy.recordHit();\n      return cached.data;\n    }\n\n    this.cachePolicy.recordMiss();\n\n    // 获取智能体配置（此处的 appId 实际是前端传入的智能体ID）\n    const agent = await this.agentService.getAgent(appId);\n    if (!agent) {\n      throw new Error(`智能体不存在: ${appId}`);\n    }\n\n    if (agent.provider !== 'fastgpt') {\n      throw new Error(`智能体 ${appId} 不是FastGPT类型，无法获取初始化数据`);\n    }\n\n    // 额外校验：FastGPT 必须配置 appId（24位hex），避免将智能体ID误传给 FastGPT\n    if (!agent.appId || !/^[a-fA-F0-9]{24}$/.test(agent.appId)) {\n      throw new Error('FastGPT 智能体缺少有效的 appId 配置');\n    }\n\n    // 调用FastGPT API（传递真实的 FastGPT appId，而非本地的智能体ID）\n    const initData = await this.callFastGPTInitAPI(agent, chatId);\n\n    // 缓存结果\n    this.cache.set(cacheKey, {\n      data: initData,\n      expiresAt: Date.now() + this.cachePolicy.getTtl(),\n    });\n\n    return initData;\n  }\n\n  /**\n   * 获取初始化数据（流式）\n   */\n  async getInitDataStream(\n    appId: string,\n    chatId: string | undefined,\n    onChunk: (chunk: string) => void,\n    onComplete: (data: FastGPTInitResponse) => void,\n    onError: (error: Error) => void,\n  ): Promise<void> {\n    try {\n      // 先获取完整的初始化数据\n      const initData = await this.getInitData(appId, chatId);\n\n      // 提取开场白文本\n      const welcomeText = initData.app.chatConfig.welcomeText || '';\n\n      if (!welcomeText) {\n        // 如果没有开场白，直接返回完整数据\n        onComplete(initData);\n        return;\n      }\n\n      // 在流式输出前进行换行规范化，将字面量 \"\\n\"/\"\\r\\n\" 转换为真实换行符\n      const normalizedWelcomeText = this.normalizeWelcomeText(welcomeText);\n\n      // 流式输出开场白文本\n      await this.streamWelcomeText(normalizedWelcomeText, onChunk);\n\n      // 流式输出完成后，返回完整数据\n      onComplete(initData);\n\n    } catch (error) {\n      onError(error instanceof Error ? error : new Error('获取初始化数据失败'));\n    }\n  }\n\n  /**\n   * 调用FastGPT初始化API\n   */\n  private async callFastGPTInitAPI(\n    agent: AgentConfig,\n    chatId?: string,\n  ): Promise<FastGPTInitResponse> {\n    try {\n      // 构建FastGPT API URL\n      const baseUrl = agent.endpoint.replace('/api/v1/chat/completions', '');\n      const initUrl = `${baseUrl}/api/core/chat/init`;\n\n      // 构建请求参数：使用 agent.appId 作为 FastGPT 的 appId\n      const params: any = { appId: agent.appId };\n      if (chatId) {\n        params.chatId = chatId;\n      }\n\n      logger.debug('🚀 调用FastGPT初始化API', { initUrl, params });\n\n      // 发送请求\n      const response = await this.httpClient.get(initUrl, {\n        params,\n        headers: {\n          'Authorization': `Bearer ${agent.apiKey}`,\n        },\n      });\n\n      const responseData = response.data;\n      if (responseData.code !== 200) {\n        throw new Error(`FastGPT API错误: ${responseData.message || '未知错误'}`);\n      }\n\n      logger.debug('✅ FastGPT初始化API调用成功');\n      return responseData.data;\n\n    } catch (error) {\n      logger.error('❌ FastGPT初始化API调用失败', { error });\n      if (error && typeof error === 'object' && 'isAxiosError' in error && (error as any).isAxiosError) {\n        const axiosError = error as any;\n        const message = axiosError.response?.data?.message || axiosError.message;\n        throw new Error(`FastGPT API调用失败: ${message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * 流式输出开场白文本\n   */\n  private async streamWelcomeText(\n    text: string,\n    onChunk: (chunk: string) => void,\n  ): Promise<void> {\n    // 将文本按字符分割，模拟打字机效果\n    const chars = Array.from(text);\n    const delay = 50; // 每个字符间隔50ms\n\n    for (let i = 0; i < chars.length; i++) {\n      const char = chars[i];\n      onChunk(char ?? '');\n\n      // 添加延迟，模拟真实的打字效果\n      if (i < chars.length - 1) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  // 将字面量换行标记标准化为真实换行，且统一为 \\n\n  private normalizeWelcomeText(text: string): string {\n    if (!text) {\n      return '';\n    }\n    return text\n      // 已经存在的真实 CRLF -> LF\n      .replace(/\\r\\n/g, '\\n')\n      // 字面量 \"\\\\r\\\\n\" -> LF\n      .replace(/\\\\r\\\\n/g, '\\n')\n      // 字面量 \"\\\\n\" -> LF\n      .replace(/\\\\n/g, '\\n')\n      // 单独真实 CR -> LF\n      .replace(/\\r/g, '\\n')\n      // 字面量 \"\\\\r\" -> LF\n      .replace(/\\\\r/g, '\\n');\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.cachePolicy.reset();\n    logger.debug('🧹 初始化数据缓存已清除');\n  }\n\n  /**\n   * 清除过期缓存\n   */\n  clearExpiredCache(): void {\n    const now = Date.now();\n    for (const [key, value] of this.cache.entries()) {\n      if (value.expiresAt <= now) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/ChatLogService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[410,413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[410,413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[444,447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[444,447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[484,487],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[484,487],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[715,718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[715,718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3078,3081],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3078,3081],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3102,3105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3102,3105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3132,3135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3132,3135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4267,4270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4267,4270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4897,4900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4897,4900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5820,5823],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5820,5823],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs';\nimport path from 'path';\nimport { withClient } from '@/utils/db';\nimport { loadAppConfig } from '@/utils/appConfig';\nimport { ObservabilityDispatcher } from '@/services/ObservabilityDispatcher';\nimport logger from '@/utils/logger';\n\ninterface NormalLogEntry {\n  timestamp: string;\n  type: 'normal';\n  agentId: string;\n  provider: string;\n  endpoint: string;\n  requestMeta?: Record<string, any> | undefined;\n  rawResponse?: any | undefined;\n  normalizedResponse?: any | undefined;\n}\n\ninterface StreamLogEntry {\n  timestamp: string;\n  type: 'stream';\n  agentId: string;\n  provider?: string | undefined;\n  endpoint?: string | undefined;\n  chatId?: string | undefined;\n  eventType: string;\n  data: any;\n}\n\nexport class ChatLogService {\n  private enabled: boolean;\n  private logDir: string;\n  private recordNormal: boolean;\n  private recordStream: boolean;\n  private includeRaw: boolean;\n  private includeNormalized: boolean;\n  private observability = ObservabilityDispatcher.getInstance();\n\n  constructor() {\n    const cfg = loadAppConfig();\n    const cfgLog = cfg.logging || {};\n\n    // 默认开启，允许通过配置文件/环境变量关闭\n    this.enabled =\n      cfgLog.enabled ?? ((process.env.LOG_CHAT_RESPONSES ?? 'true') === 'true');\n\n    // 默认写入项目根目录 ./log（以编译后 dist 下 __dirname 回溯到仓库根）\n    this.logDir =\n      cfgLog.dir || process.env.LOG_CHAT_DIR || path.resolve(__dirname, '../../..', 'log');\n\n    // 记录范围（默认：都记录）\n    this.recordNormal = cfgLog.record?.normal ?? true;\n    this.recordStream = cfgLog.record?.stream ?? true;\n\n    // 输出内容（默认：都包含）\n    this.includeRaw = cfgLog.include?.raw ?? true;\n    this.includeNormalized = cfgLog.include?.normalized ?? true;\n  }\n\n  private ensureDir() {\n    try {\n      if (!fs.existsSync(this.logDir)) {\n        fs.mkdirSync(this.logDir, { recursive: true });\n      }\n    } catch (e) {\n      // 避免影响主流程\n      logger.warn('[ChatLogService] 创建日志目录失败', { error: e });\n    }\n  }\n\n  private getLogFilePath(): string {\n    const date = new Date();\n    const y = date.getFullYear();\n    const m = String(date.getMonth() + 1).padStart(2, '0');\n    const d = String(date.getDate()).padStart(2, '0');\n    const file = `chat-${y}${m}${d}.log`;\n    return path.join(this.logDir, file);\n  }\n\n  private appendFile(entry: object) {\n    if (!this.enabled) {\n      return;\n    }\n    this.ensureDir();\n    const line = JSON.stringify(entry) + '\\n';\n    try {\n      fs.appendFile(this.getLogFilePath(), line, (err) => {\n        if (err) {\n          logger.warn('[ChatLogService] 写入日志失败', { error: err });\n        }\n      });\n    } catch (e) {\n      logger.warn('[ChatLogService] 追加日志异常', { error: e });\n    }\n  }\n\n  private async appendDb(level: 'INFO'|'WARN'|'ERROR', message: string) {\n    try {\n      await withClient(async (client) => {\n        await client.query('INSERT INTO logs(level, message) VALUES ($1, $2)', [level, message]);\n      });\n    } catch (e) {\n      logger.warn('[ChatLogService] 数据库写入失败', { error: e });\n    }\n  }\n\n  logCompletion(params: {\n    agentId: string;\n    provider: string;\n    endpoint: string;\n    requestMeta?: Record<string, any>;\n    rawResponse?: any;\n    normalizedResponse?: any;\n  }) {\n    if (!this.enabled || !this.recordNormal) {\n      return;\n    }\n    const entry: NormalLogEntry = {\n      timestamp: new Date().toISOString(),\n      type: 'normal',\n      agentId: params.agentId,\n      provider: params.provider,\n      endpoint: params.endpoint,\n      requestMeta: params.requestMeta,\n      rawResponse: this.includeRaw ? params.rawResponse : undefined,\n      normalizedResponse: this.includeNormalized ? params.normalizedResponse : undefined,\n    };\n    this.appendFile(entry);\n    this.appendDb('INFO', JSON.stringify(entry));\n    this.pushObservability('normal', 'INFO', {\n      agentId: params.agentId,\n      provider: params.provider,\n      endpoint: params.endpoint,\n      payload: {\n        requestMeta: params.requestMeta,\n        rawResponse: this.includeRaw ? params.rawResponse ?? null : null,\n        normalizedResponse: this.includeNormalized ? params.normalizedResponse ?? null : null,\n      },\n      timestamp: entry.timestamp,\n    });\n  }\n\n  logStreamEvent(params: {\n    agentId: string;\n    chatId?: string;\n    provider?: string;\n    endpoint?: string;\n    eventType: string;\n    data: any;\n  }) {\n    if (!this.enabled || !this.recordStream) {\n      return;\n    }\n    const entry: StreamLogEntry = {\n      timestamp: new Date().toISOString(),\n      type: 'stream',\n      agentId: params.agentId,\n      provider: params.provider,\n      endpoint: params.endpoint,\n      chatId: params.chatId,\n      eventType: params.eventType,\n      data: params.data,\n    };\n    this.appendFile(entry);\n    {\n      const level: 'INFO' | 'WARN' | 'ERROR' =\n        params.eventType === 'error' ? 'ERROR' : 'INFO';\n      this.appendDb(level, JSON.stringify(entry));\n      const obsPayload: {\n        agentId: string;\n        payload: any;\n        timestamp: string;\n        provider?: string;\n        endpoint?: string;\n        chatId?: string;\n        eventType?: string;\n      } = {\n        agentId: params.agentId,\n        payload: params.data ?? null,\n        timestamp: entry.timestamp,\n      };\n      if (params.provider) {\n        obsPayload.provider = params.provider;\n      }\n      if (params.endpoint) {\n        obsPayload.endpoint = params.endpoint;\n      }\n      if (params.chatId) {\n        obsPayload.chatId = params.chatId;\n      }\n      if (params.eventType) {\n        obsPayload.eventType = params.eventType;\n      }\n      this.pushObservability('stream', level, obsPayload);\n    }\n  }\n\n  private pushObservability(\n    channel: 'normal' | 'stream',\n    level: 'INFO' | 'WARN' | 'ERROR',\n    payload: {\n      agentId: string;\n      provider?: string;\n      endpoint?: string;\n      chatId?: string;\n      eventType?: string;\n      payload: any;\n      timestamp: string;\n    },\n  ) {\n    try {\n      if (!this.observability.isEnabled()) {\n        return;\n      }\n      const event: import('./ObservabilityDispatcher').ObservabilityEvent = {\n        timestamp: payload.timestamp,\n        channel,\n        level,\n        agentId: payload.agentId,\n        payload: payload.payload ?? null,\n      };\n      if (payload.provider) {\n        event.provider = payload.provider;\n      }\n      if (payload.endpoint) {\n        event.endpoint = payload.endpoint;\n      }\n      if (payload.chatId) {\n        event.chatId = payload.chatId;\n      }\n      if (payload.eventType) {\n        event.eventType = payload.eventType;\n      }\n      this.observability.enqueue(event);\n    } catch (error) {\n      logger.warn('[ChatLogService] 推送观测事件失败', { error });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/ChatProxyService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":582,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":582,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15884,15887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15884,15887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":587,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":587,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[16018,16018],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":832,"column":13,"nodeType":"BlockStatement","messageId":"unexpected","endLine":832,"endColumn":15,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[22574,22574],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport {\n  AgentConfig,\n  ChatMessage,\n  ChatOptions,\n  ChatResponse,\n  StreamStatus,\n  RequestHeaders,\n  JsonValue,\n} from '@/types';\nimport {\n  FastGPTResponse,\n  FastGPTStreamChunk,\n  OpenAIResponse,\n  OpenAIStreamChunk,\n  AnthropicResponse,\n  AnthropicStreamChunk,\n  DifyResponse,\n  DifyStreamChunk,\n  DifyFile,\n  SSEEventData,\n  ReasoningPayload,\n} from '@/types/provider';\nimport { AgentConfigService } from './AgentConfigService';\nimport { generateId, generateTimestamp, getErrorMessage } from '@/utils/helpers';\nimport { ChatLogService } from './ChatLogService';\nimport { getProtectionService, ProtectedRequestContext } from './ProtectionService';\nimport logger from '@/utils/logger';\nimport {\n  getNormalizedEventKey,\n  isChatIdEvent,\n  isChunkLikeEvent,\n  isDatasetEvent,\n  isEndEvent,\n  isInteractiveEvent,\n  isReasoningEvent,\n  isStatusEvent,\n  isSummaryEvent,\n  isToolEvent,\n  isUsageEvent,\n} from '@/utils/fastgptEvents';\nimport { ValidationError, ResourceError, ExternalServiceError } from '@/types/errors';\n\ninterface SSEParsedEvent {\n  event: string;\n  data: string;\n  id?: string;\n  retry?: number;\n}\n\n/**\n * AI 提供商请求数据格式（通用）\n */\nexport interface ProviderRequestData {\n  [key: string]: unknown; // 允许提供商特定字段\n}\n\n/**\n * AI 提供商响应数据格式（通用）\n */\nexport interface ProviderResponseData {\n  [key: string]: unknown;\n}\n\n/**\n * AI提供商适配器接口\n */\nexport interface AIProvider {\n  name: string;\n  transformRequest(messages: ChatMessage[], config: AgentConfig, stream: boolean, options?: ChatOptions): ProviderRequestData;\n  transformResponse(response: ProviderResponseData | FastGPTResponse | OpenAIResponse | AnthropicResponse | DifyResponse): ChatResponse;\n  transformStreamResponse(chunk: Record<string, JsonValue> | FastGPTStreamChunk | OpenAIStreamChunk | AnthropicStreamChunk | DifyStreamChunk): string;\n  validateConfig(config: AgentConfig): boolean;\n  buildHeaders(config: AgentConfig): RequestHeaders;\n}\n\n/**\n * FastGPT提供商适配器\n */\nexport class FastGPTProvider implements AIProvider {\n  name = 'FastGPT';\n\n  transformRequest(messages: ChatMessage[], config: AgentConfig, stream: boolean = false, options?: ChatOptions): ProviderRequestData {\n    const detail = options?.detail ?? config.features?.supportsDetail ?? false;\n    const request: ProviderRequestData = {\n      chatId: options?.chatId || `chat_${Date.now()}`,\n      stream: stream && config.features.streamingConfig.enabled,\n      detail,\n      messages: messages.map(msg => ({\n        role: msg.role,\n        content: msg.content,\n      })),\n    };\n\n    // 添加 FastGPT 特有参数支持\n    if (options?.variables) {\n      request.variables = options.variables;\n    }\n\n    if (options?.responseChatItemId) {\n      request.responseChatItemId = options.responseChatItemId;\n    }\n\n    // 添加系统消息\n    if (config.systemPrompt && Array.isArray(request.messages)) {\n      (request.messages as Array<{ role: string; content: string }>).unshift({\n        role: 'system',\n        content: config.systemPrompt,\n      });\n    }\n\n    logger.debug('FastGPT 请求数据', { request });\n    return request;\n  }\n\n  transformResponse(response: FastGPTResponse): ChatResponse {\n    const firstChoice = response.choices?.[0];\n    const result: ChatResponse = {\n      id: response.id || generateId(),\n      object: response.object || 'chat.completion',\n      created: response.created || generateTimestamp(),\n      model: response.model || 'fastgpt',\n      choices: response.choices && response.choices.length > 0 ? response.choices.map(choice => ({\n        index: choice.index,\n        message: {\n          role: (choice.message?.role || 'assistant') as 'user' | 'system' | 'assistant',\n          content: choice.message?.content || '',\n        },\n        finish_reason: choice.finish_reason || 'stop',\n      })) : [{\n        index: 0,\n        message: {\n          role: 'assistant' as const,\n          content: firstChoice?.message?.content || '',\n        },\n        finish_reason: firstChoice?.finish_reason || 'stop',\n      }],\n    };\n\n    if (response.usage) {\n      result.usage = {\n        prompt_tokens: response.usage.prompt_tokens ?? 0,\n        completion_tokens: response.usage.completion_tokens ?? 0,\n        total_tokens: response.usage.total_tokens ?? 0,\n      };\n    }\n\n    return result;\n  }\n\n  transformStreamResponse(chunk: FastGPTStreamChunk): string {\n    // FastGPT流式响应格式\n    if (chunk.choices?.[0]?.delta) {\n      return chunk.choices[0].delta.content || '';\n    }\n    return '';\n  }\n\n  validateConfig(config: AgentConfig): boolean {\n    return (\n      config.provider === 'fastgpt' &&\n      config.apiKey.startsWith('fastgpt-') &&\n      config.endpoint.includes('/chat/completions')\n    );\n  }\n\n  buildHeaders(config: AgentConfig): RequestHeaders {\n    return {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${config.apiKey}`,\n    };\n  }\n}\n\n/**\n * OpenAI提供商适配器\n */\nexport class OpenAIProvider implements AIProvider {\n  name = 'OpenAI';\n\n  transformRequest(messages: ChatMessage[], config: AgentConfig, stream: boolean = false, options?: ChatOptions) {\n    return {\n      model: config.model,\n      messages: messages.map(msg => ({\n        role: msg.role,\n        content: msg.content,\n      })),\n      stream: stream && config.features.streamingConfig.enabled,\n      max_tokens: options?.maxTokens || config.maxTokens,\n      temperature: options?.temperature || config.temperature || 0.7,\n    };\n  }\n\n  transformResponse(response: OpenAIResponse): ChatResponse {\n    const result: ChatResponse = {\n      id: response.id || generateId(),\n      object: response.object || 'chat.completion',\n      created: response.created || generateTimestamp(),\n      model: response.model,\n      choices: response.choices.map((choice) => ({\n        index: choice.index,\n        message: {\n          role: choice.message.role as 'user' | 'system' | 'assistant',\n          content: choice.message.content,\n        },\n        finish_reason: choice.finish_reason,\n      })),\n    };\n\n    if (response.usage) {\n      result.usage = response.usage;\n    }\n\n    return result;\n  }\n\n  transformStreamResponse(chunk: OpenAIStreamChunk): string {\n    if (chunk.choices?.[0]?.delta) {\n      return chunk.choices[0].delta.content || '';\n    }\n    return '';\n  }\n\n  validateConfig(config: AgentConfig): boolean {\n    return (\n      config.provider === 'openai' &&\n      config.apiKey.startsWith('sk-') &&\n      config.endpoint.includes('openai.com')\n    );\n  }\n\n  buildHeaders(config: AgentConfig): RequestHeaders {\n    return {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${config.apiKey}`,\n    };\n  }\n}\n\n/**\n * Anthropic提供商适配器\n */\nexport class AnthropicProvider implements AIProvider {\n  name = 'Anthropic';\n\n  transformRequest(messages: ChatMessage[], config: AgentConfig, stream: boolean = false, options?: ChatOptions) {\n    return {\n      model: config.model,\n      max_tokens: options?.maxTokens || config.maxTokens || 4096,\n      messages: messages.map(msg => ({\n        role: msg.role,\n        content: msg.content,\n      })),\n      stream: stream && config.features.streamingConfig.enabled,\n      temperature: options?.temperature || config.temperature || 0.7,\n    };\n  }\n\n  transformResponse(response: AnthropicResponse): ChatResponse {\n    const firstContent = response.content?.[0];\n    return {\n      id: response.id || generateId(),\n      object: 'chat.completion',\n      created: generateTimestamp(),\n      model: response.model,\n      choices: [{\n        index: 0,\n        message: {\n          role: 'assistant' as const,\n          content: firstContent?.text || '',\n        },\n        finish_reason: response.stop_reason || 'stop',\n      }],\n      usage: {\n        prompt_tokens: response.usage?.input_tokens || 0,\n        completion_tokens: response.usage?.output_tokens || 0,\n        total_tokens: (response.usage?.input_tokens || 0) + (response.usage?.output_tokens || 0),\n      },\n    };\n  }\n\n  transformStreamResponse(chunk: AnthropicStreamChunk): string {\n    if (chunk.type === 'content_block_delta' && chunk.delta) {\n      return chunk.delta.text || '';\n    }\n    return '';\n  }\n\n  validateConfig(config: AgentConfig): boolean {\n    return (\n      config.endpoint.includes('anthropic.com') &&\n      config.apiKey.startsWith('sk-ant-') &&\n      config.provider === 'anthropic'\n    );\n  }\n\n  buildHeaders(config: AgentConfig): RequestHeaders {\n    return {\n      'Content-Type': 'application/json',\n      'x-api-key': config.apiKey,\n      'anthropic-version': '2023-06-01',\n    };\n  }\n}\n\n/**\n * Dify 提供商适配器\n *\n * Dify API 规范:\n * - 端点: POST /v1/chat-messages\n * - 认证: Bearer {api_key}\n * - 请求格式: { query, response_mode, conversation_id, user, inputs, files }\n * - SSE 事件: message, message_end, message_file, error, ping\n */\nexport class DifyProvider implements AIProvider {\n  name = 'Dify';\n\n  /**\n   * 转换请求格式\n   *\n   * Dify 使用 query 字段而非 messages 数组，需要提取最后一条用户消息\n   */\n  transformRequest(messages: ChatMessage[], config: AgentConfig, stream: boolean = false, options?: ChatOptions) {\n    // 提取最后一条用户消息作为 query\n    const lastUserMessage = messages.filter(msg => msg.role === 'user').pop();\n    if (!lastUserMessage) {\n      throw new ValidationError({\n        message: 'Dify 请求必须包含至少一条用户消息',\n        code: 'MISSING_USER_MESSAGE',\n      });\n    }\n\n    const request: ProviderRequestData = {\n      query: lastUserMessage.content,\n      response_mode: stream && config.features.streamingConfig.enabled ? 'streaming' : 'blocking',\n      user: options?.userId || 'default-user',\n    };\n\n    // 添加会话 ID（Dify 使用 conversation_id）\n    if (options?.chatId) {\n      request.conversation_id = options.chatId;\n    }\n\n    // 添加输入变量（Dify 特有）\n    if (options?.variables) {\n      request.inputs = options.variables;\n    }\n\n    // 添加文件（Dify 特有）\n    if (options?.files && Array.isArray(options.files)) {\n      request.files = (options.files as Array<Partial<DifyFile>>).map((file) => ({\n        type: file.type || 'file',\n        transfer_method: file.transfer_method || 'remote_url',\n        url: file.url || '',\n      }));\n    }\n\n    logger.debug('Dify 请求数据', {\n      component: 'DifyProvider',\n      request,\n      originalMessagesCount: messages.length,\n    });\n\n    return request;\n  }\n\n  /**\n   * 转换响应格式\n   *\n   * Dify 响应格式转换为统一的 ChatResponse 格式\n   */\n  transformResponse(response: DifyResponse): ChatResponse {\n    return {\n      id: response.message_id || generateId(),\n      object: 'chat.completion',\n      created: response.created_at || generateTimestamp(),\n      model: response.mode || 'dify',\n      choices: [{\n        index: 0,\n        message: {\n          role: 'assistant',\n          content: response.answer || '',\n        },\n        finish_reason: 'stop',\n      }],\n      usage: response.metadata?.usage || {\n        prompt_tokens: 0,\n        completion_tokens: 0,\n        total_tokens: 0,\n      },\n      // Dify 特有元数据\n      metadata: {\n        conversation_id: response.conversation_id,\n        retriever_resources: response.metadata?.retriever_resources || [],\n      },\n    };\n  }\n\n  /**\n   * 转换流式响应\n   *\n   * Dify SSE 事件处理\n   */\n  transformStreamResponse(chunk: DifyStreamChunk): string {\n    // Dify 流式响应事件类型：message, message_end, message_file, error, ping\n    if (chunk.event === 'message' && chunk.answer) {\n      return chunk.answer;\n    }\n\n    // message_end 事件不返回内容，但包含元数据\n    if (chunk.event === 'message_end') {\n      logger.debug('Dify 消息结束', {\n        component: 'DifyProvider',\n        messageId: chunk.id,\n        conversationId: chunk.conversation_id,\n        metadata: chunk.metadata,\n      });\n    }\n\n    // error 事件\n    if (chunk.event === 'error') {\n      logger.error('Dify 流式响应错误', {\n        component: 'DifyProvider',\n        status: chunk.status,\n        code: chunk.code,\n        message: chunk.message,\n      });\n      throw new ExternalServiceError({\n        message: `Dify 错误: ${chunk.message || '未知错误'}`,\n        code: 'DIFY_STREAM_ERROR',\n        service: 'Dify',\n      });\n    }\n\n    // message_file 事件（文件消息）\n    if (chunk.event === 'message_file') {\n      logger.info('Dify 文件消息', {\n        component: 'DifyProvider',\n        type: chunk.type,\n        url: chunk.url,\n      });\n      // 可以在这里处理文件消息的特殊逻辑\n      return `[文件: ${chunk.type}]`;\n    }\n\n    // ping 事件用于保持连接，不返回内容\n    return '';\n  }\n\n  /**\n   * 验证配置\n   *\n   * Dify API Key 格式: app-xxx\n   */\n  validateConfig(config: AgentConfig): boolean {\n    const isValidProvider = config.provider === 'dify';\n    const hasValidApiKey = Boolean(config.apiKey && (config.apiKey.startsWith('app-') || config.apiKey.includes('dify')));\n    const hasValidEndpoint = Boolean(config.endpoint && config.endpoint.length > 0);\n\n    if (!isValidProvider) {\n      logger.warn('Dify 配置验证失败: provider 不匹配', {\n        component: 'DifyProvider',\n        provider: config.provider,\n      });\n    }\n    if (!hasValidApiKey) {\n      logger.warn('Dify 配置验证失败: API Key 格式不正确', {\n        component: 'DifyProvider',\n        apiKeyPrefix: config.apiKey?.substring(0, 4),\n      });\n    }\n    if (!hasValidEndpoint) {\n      logger.warn('Dify 配置验证失败: endpoint 缺失', {\n        component: 'DifyProvider',\n      });\n    }\n\n    return isValidProvider && hasValidApiKey && hasValidEndpoint;\n  }\n\n  /**\n   * 构建请求头\n   *\n   * Dify 使用 Bearer token 认证\n   */\n  buildHeaders(config: AgentConfig): RequestHeaders {\n    return {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${config.apiKey}`,\n    };\n  }\n}\n\n/**\n * 聊天代理服务\n */\nexport class ChatProxyService {\n  private agentService: AgentConfigService;\n  private httpClient: ReturnType<typeof axios.create>;\n  private providers: Map<string, AIProvider> = new Map();\n  private chatLog: ChatLogService = new ChatLogService();\n  private protectionService = getProtectionService();\n\n  constructor(agentService: AgentConfigService) {\n    this.agentService = agentService;\n    this.httpClient = axios.create({\n      timeout: parseInt(process.env.REQUEST_TIMEOUT || '30000'),\n    });\n\n    // 注册提供商适配器\n    this.registerProvider(new FastGPTProvider());\n    this.registerProvider(new OpenAIProvider());\n    this.registerProvider(new AnthropicProvider());\n    this.registerProvider(new DifyProvider());\n  }\n\n  /**\n   * 注册提供商适配器\n   */\n  private registerProvider(provider: AIProvider): void {\n    this.providers.set(provider.name.toLowerCase(), provider);\n  }\n\n  /**\n   * 发送聊天消息（非流式）\n   */\n  async sendMessage(\n    agentId: string,\n    messages: ChatMessage[],\n    options?: ChatOptions,\n    protectionContext?: ProtectedRequestContext,\n  ): Promise<ChatResponse> {\n    const config = await this.agentService.getAgent(agentId);\n    if (!config) {\n      throw new ResourceError({\n        message: `智能体不存在: ${agentId}`,\n        code: 'AGENT_NOT_FOUND',\n        resourceType: 'agent',\n        resourceId: agentId,\n      });\n    }\n\n    if (!config.isActive) {\n      throw new ValidationError({\n        message: `智能体未激活: ${agentId}`,\n        code: 'AGENT_INACTIVE',\n      });\n    }\n\n    const provider = this.getProvider(config.provider);\n    if (!provider) {\n      throw new ValidationError({\n        message: `不支持的提供商: ${config.provider}`,\n        code: 'UNSUPPORTED_PROVIDER',\n      });\n    }\n\n    // 创建受保护的请求操作\n    const protectedOperation = async (): Promise<ChatResponse> => {\n      // 转换请求格式\n      const requestData = provider.transformRequest(messages, config, false, options);\n\n      // 构建请求头\n      const headers = provider.buildHeaders(config);\n\n      // 发送请求\n      const response = await this.httpClient.post(\n        config.endpoint,\n        requestData,\n        { headers },\n      );\n\n      // 转换响应格式并记录日志\n      const normalized = provider.transformResponse(response.data);\n      try {\n        this.chatLog.logCompletion({\n          agentId,\n          provider: config.provider,\n          endpoint: config.endpoint,\n          requestMeta: {\n            messagesCount: Array.isArray(messages) ? messages.length : 0,\n            chatId: (requestData as any)?.chatId,\n          },\n          rawResponse: response.data,\n          normalizedResponse: normalized,\n        });\n      } catch {}\n      return normalized;\n    };\n\n    try {\n      if (protectionContext) {\n        // 使用保护机制执行请求\n        return await this.protectionService.executeProtectedRequest(\n          protectionContext,\n          protectedOperation,\n        );\n      } else {\n        // 直接执行请求（向后兼容）\n        return await protectedOperation();\n      }\n    } catch (error) {\n      logger.error('智能体请求失败', { agentId, error });\n      throw new ExternalServiceError({\n        message: `智能体请求失败: ${getErrorMessage(error)}`,\n        code: 'AGENT_REQUEST_FAILED',\n        service: config.provider,\n        originalError: error,\n      });\n    }\n  }\n\n  /**\n   * 发送流式聊天消息\n   */\n  async sendStreamMessage(\n    agentId: string,\n    messages: ChatMessage[],\n    onChunk: (chunk: string) => void,\n    onStatus: (status: StreamStatus) => void,\n    options?: ChatOptions,\n    onEvent?: (eventName: string, data: SSEEventData) => void,\n    protectionContext?: ProtectedRequestContext,\n  ): Promise<void> {\n    const config = await this.agentService.getAgent(agentId);\n    if (!config) {\n      throw new ResourceError({\n        message: `智能体不存在: ${agentId}`,\n        code: 'AGENT_NOT_FOUND',\n        resourceType: 'agent',\n        resourceId: agentId,\n      });\n    }\n\n    if (!config.isActive) {\n      throw new ValidationError({\n        message: `智能体未激活: ${agentId}`,\n        code: 'AGENT_INACTIVE',\n      });\n    }\n\n    if (!config.features.streamingConfig.enabled) {\n      throw new ValidationError({\n        message: `智能体不支持流式响应: ${agentId}`,\n        code: 'STREAM_NOT_SUPPORTED',\n      });\n    }\n\n    const provider = this.getProvider(config.provider);\n    if (!provider) {\n      throw new ValidationError({\n        message: `不支持的提供商: ${config.provider}`,\n        code: 'UNSUPPORTED_PROVIDER',\n      });\n    }\n\n    // 创建受保护的流式请求操作\n    const protectedOperation = async (): Promise<void> => {\n      // 转换请求格式\n      const requestData = provider.transformRequest(messages, config, true, options);\n\n      // 构建请求头\n      const headers = provider.buildHeaders(config);\n\n      // 在发送请求前，将本次使用的 chatId 透传给上层（用于交互节点继续运行复用 chatId）\n      let usedChatId: string | undefined;\n      try {\n        usedChatId = (requestData as Record<string, unknown>)?.chatId as string | undefined;\n        if (usedChatId) {\n          // 记录 chatId 事件\n          try {\n            this.chatLog.logStreamEvent({\n              agentId,\n              chatId: usedChatId,\n              provider: config.provider,\n              endpoint: config.endpoint,\n              eventType: 'chatId',\n              data: { chatId: usedChatId },\n            });\n          } catch (logError) {\n            // 日志记录失败不影响主流程\n            console.warn('[ChatProxyService] chatId 日志记录失败:', logError);\n          }\n          onEvent?.('chatId', { chatId: usedChatId });\n        }\n      } catch (chatIdError) {\n        // chatId 提取失败不影响主流程\n        console.warn('[ChatProxyService] chatId 提取失败:', chatIdError);\n      }\n\n      // 发送流式请求\n      const response = await this.httpClient.post(\n        config.endpoint,\n        requestData,\n        {\n          headers,\n          responseType: 'stream',\n        },\n      );\n\n      // 处理流式响应\n      await this.handleStreamResponse(\n        response.data,\n        provider,\n        config,\n        onChunk,\n        onStatus,\n        onEvent,\n        { agentId, endpoint: config.endpoint, provider: config.provider, ...(usedChatId ? { chatId: usedChatId } : {}) },\n      );\n    };\n\n    try {\n      if (protectionContext) {\n        // 使用保护机制执行流式请求\n        await this.protectionService.executeProtectedRequest(\n          protectionContext,\n          protectedOperation,\n        );\n      } else {\n        // 直接执行流式请求（向后兼容）\n        await protectedOperation();\n      }\n    } catch (error) {\n      logger.error('智能体流式请求失败', { agentId, error });\n      onStatus?.({\n        type: 'error',\n        status: 'error',\n        error: getErrorMessage(error),\n      });\n      throw new ExternalServiceError({\n        message: `智能体流式请求失败: ${getErrorMessage(error)}`,\n        code: 'AGENT_STREAM_REQUEST_FAILED',\n        service: config.provider,\n        originalError: error,\n      });\n    }\n  }\n\n  private findNextEventBoundary(buffer: string): { index: number; length: number } | null {\n    const lfIndex = buffer.indexOf('\\n\\n');\n    const crlfIndex = buffer.indexOf('\\r\\n\\r\\n');\n\n    if (lfIndex === -1 && crlfIndex === -1) {\n      return null;\n    }\n\n    if (lfIndex === -1) {\n      return { index: crlfIndex, length: 4 };\n    }\n\n    if (crlfIndex === -1) {\n      return { index: lfIndex, length: 2 };\n    }\n\n    return crlfIndex < lfIndex\n      ? { index: crlfIndex, length: 4 }\n      : { index: lfIndex, length: 2 };\n  }\n\n  private parseSSEEventBlock(rawBlock: string): SSEParsedEvent | null {\n    const lines = rawBlock.split(/\\r?\\n/);\n    let event = '';\n    const dataLines: string[] = [];\n    let id: string | undefined;\n    let retry: number | undefined;\n\n    for (const line of lines) {\n      if (!line || line.startsWith(':')) {\n        continue;\n      }\n\n      const separatorIndex = line.indexOf(':');\n      const field = separatorIndex === -1 ? line : line.slice(0, separatorIndex);\n      let value = separatorIndex === -1 ? '' : line.slice(separatorIndex + 1);\n      if (value.startsWith(' ')) {\n        value = value.slice(1);\n      }\n\n      switch (field) {\n        case 'event':\n          event = value.trim();\n          break;\n        case 'data':\n          dataLines.push(value);\n          break;\n        case 'id':\n          id = value.trim();\n          break;\n        case 'retry': {\n          const parsedRetry = parseInt(value, 10);\n          if (!Number.isNaN(parsedRetry)) {\n            retry = parsedRetry;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n\n    const data = dataLines.join('\\n');\n    if (!event && !data) {\n      return null;\n    }\n\n    const result: SSEParsedEvent = { event, data };\n    if (typeof id === 'string') {\n      result.id = id;\n    }\n    if (typeof retry === 'number') {\n      result.retry = retry;\n    }\n\n    return result;\n  }\n\n  private logStreamEvent(\n    ctx: { agentId: string; chatId?: string; endpoint: string; provider: string } | undefined,\n    eventType: string,\n    data: SSEEventData,\n  ): void {\n    try {\n      this.chatLog.logStreamEvent({\n        agentId: ctx?.agentId || 'unknown',\n        ...(ctx?.provider ? { provider: ctx.provider } : {}),\n        ...(ctx?.endpoint ? { endpoint: ctx.endpoint } : {}),\n        ...(ctx?.chatId ? { chatId: ctx.chatId } : {}),\n        eventType,\n        data,\n      });\n    } catch {}\n  }\n\n  private extractReasoningPayload(data: Record<string, JsonValue> | null): ReasoningPayload {\n    if (!data || typeof data !== 'object') {\n      return null;\n    }\n\n    // 尝试从不同的可能位置提取推理内容\n    const choices = data.choices as Array<Record<string, JsonValue>> | undefined;\n    const firstChoice = choices?.[0];\n    const delta = (firstChoice?.delta || data.delta) as Record<string, JsonValue> | undefined;\n\n    return (\n      delta?.reasoning_content ||\n      data.reasoning_content ||\n      data.reasoning ||\n      null\n    ) as ReasoningPayload;\n  }\n\n  /**\n   * 分发FastGPT事件到相应的回调函数\n   *\n   * @param provider AI提供商适配器\n   * @param eventName 事件名称\n   * @param payload 事件数据\n   * @param onChunk 内容块回调函数\n   * @param onStatus 状态回调函数\n   * @param onEvent 通用事件回调函数\n   * @param ctx 上下文信息\n   */\n  private dispatchFastGPTEvent(\n    provider: AIProvider,\n    eventName: string,\n    payload: Record<string, JsonValue> | string | null,\n    onChunk: (chunk: string) => void,\n    onStatus?: (status: StreamStatus) => void,\n    onEvent?: (eventName: string, data: SSEEventData) => void,\n    ctx?: { agentId: string; chatId?: string; endpoint: string; provider: string },\n  ): void {\n    const payloadEvent = (typeof payload === 'object' && payload !== null && 'event' in payload)\n      ? payload.event\n      : '';\n    const resolvedEvent = (eventName || (typeof payloadEvent === 'string' ? payloadEvent : '') || '').trim();\n    const eventKey = getNormalizedEventKey(resolvedEvent || 'message');\n\n    const emitEvent = (name: string, data: SSEEventData) => {\n      if (!onEvent) {\n        return;\n      }\n      try {\n        onEvent(name, data);\n      } catch (emitError) {\n        logger.warn('事件回调执行失败', { error: emitError });\n      }\n    };\n\n    // 处理chatId事件\n    if (isChatIdEvent(resolvedEvent)) {\n      this.logStreamEvent(ctx, 'chatId', payload);\n      emitEvent('chatId', payload);\n      return;\n    }\n\n    // 处理交互事件\n    if (isInteractiveEvent(resolvedEvent)) {\n      this.logStreamEvent(ctx, 'interactive', payload);\n      emitEvent('interactive', payload);\n      return;\n    }\n\n    // 处理流程响应事件\n    if (eventKey === getNormalizedEventKey('flowResponses')) {\n      this.logStreamEvent(ctx, 'flowResponses', payload);\n      onStatus?.({ type: 'progress', status: 'completed', moduleName: '执行完成' });\n      emitEvent(resolvedEvent || 'flowResponses', payload);\n      return;\n    }\n\n    // 处理状态事件\n    if (isStatusEvent(resolvedEvent)) {\n      const payloadObj = (typeof payload === 'object' && payload !== null) ? payload : {};\n      const statusEvent: StreamStatus = {\n        type: 'flowNodeStatus',\n        status: ((payloadObj.status as string) ?? 'running') as StreamStatus['status'],\n        moduleName: (payloadObj.name || payloadObj.moduleName || payloadObj.id || '未知模块') as string,\n      };\n      this.logStreamEvent(ctx, 'flowNodeStatus', payload);\n      onStatus?.(statusEvent);\n      emitEvent(resolvedEvent || 'flowNodeStatus', payload);\n      return;\n    }\n\n    // 处理answer事件 - 这是主要的内容流\n    if (eventKey === getNormalizedEventKey('answer')) {\n      const payloadObj = (typeof payload === 'object' && payload !== null) ? payload : {};\n      const choices = payloadObj.choices as Array<Record<string, JsonValue>> | undefined;\n      const delta = (choices?.[0])?.delta as Record<string, JsonValue> | undefined;\n      const answerContent = (delta?.content ?? payloadObj.content ?? '') as string;\n\n      if (answerContent) {\n        this.logStreamEvent(ctx, 'answer', payload);\n        onChunk(answerContent);\n      }\n\n      const reasoningContent = this.extractReasoningPayload(payloadObj);\n      if (reasoningContent) {\n        const reasoningData = typeof reasoningContent === 'object' && reasoningContent !== null\n          ? reasoningContent\n          : { content: reasoningContent };\n        this.logStreamEvent(ctx, 'reasoning', reasoningData);\n        emitEvent('reasoning', reasoningData);\n      }\n      return; // 重要：直接返回，避免后续的兜底处理\n    }\n\n    // 处理推理事件\n    if (isReasoningEvent(resolvedEvent)) {\n      this.logStreamEvent(ctx, 'reasoning', payload);\n      emitEvent('reasoning', { event: resolvedEvent || 'reasoning', data: payload });\n      return;\n    }\n\n    // 处理数据集、摘要、工具事件\n    if (isDatasetEvent(resolvedEvent) || isSummaryEvent(resolvedEvent) || isToolEvent(resolvedEvent)) {\n      this.logStreamEvent(ctx, resolvedEvent || 'event', payload);\n      emitEvent(resolvedEvent || 'event', payload);\n      return;\n    }\n\n    // 处理使用量事件\n    if (isUsageEvent(resolvedEvent)) {\n      this.logStreamEvent(ctx, 'usage', payload);\n      emitEvent('usage', payload);\n      return;\n    }\n\n    // 处理结束事件\n    if (isEndEvent(resolvedEvent)) {\n      this.logStreamEvent(ctx, resolvedEvent || 'end', payload);\n      onStatus?.({ type: 'complete', status: 'completed' });\n      emitEvent(resolvedEvent || 'end', payload);\n      return;\n    }\n\n    // 兜底处理：只处理非answer事件，避免重复处理\n    if (eventKey !== getNormalizedEventKey('answer')) {\n      // 将 payload 转换为提供商期望的格式\n      const chunkData = (typeof payload === 'object' && payload !== null)\n        ? payload\n        : {} as Record<string, JsonValue>;\n      const transformed = provider.transformStreamResponse(chunkData);\n      if (transformed) {\n        this.logStreamEvent(ctx, 'chunk', transformed);\n        onChunk(transformed);\n      }\n    }\n\n    // 发送未识别的事件\n    if (resolvedEvent && !isChunkLikeEvent(resolvedEvent)) {\n      emitEvent(resolvedEvent, payload);\n    }\n  }\n\n  /**\n   * 处理流式响应 - 兼容 FastGPT 全事件并支持多行 data\n   */\n  private async handleStreamResponse(\n    stream: NodeJS.ReadableStream,\n    provider: AIProvider,\n    config: AgentConfig,\n    onChunk: (chunk: string) => void,\n    onStatus?: (status: StreamStatus) => void,\n    onEvent?: (eventName: string, data: SSEEventData) => void,\n    ctx?: { agentId: string; chatId?: string; endpoint: string; provider: string },\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      let buffer = '';\n      let completed = false;\n\n      logger.debug('开始处理流式响应', { provider: config.provider });\n\n      const flushEventBlock = (rawBlock: string) => {\n        const parsed = this.parseSSEEventBlock(rawBlock.replace(/\\r/g, ''));\n        if (!parsed) {\n          return;\n        }\n\n        const rawData = parsed.data;\n        if (!rawData) {\n          return;\n        }\n\n        if (rawData.trim() === '[DONE]') {\n          if (completed) {\n            return;\n          }\n          completed = true;\n          logger.debug('流式响应完成 [DONE]');\n          this.logStreamEvent(ctx, 'complete', { done: true });\n          onStatus?.({ type: 'complete', status: 'completed' });\n          resolve();\n          return;\n        }\n\n        let payload: Record<string, JsonValue> | string = rawData;\n        if (typeof rawData === 'string') {\n          const trimmed = rawData.trim();\n          if (trimmed.startsWith('{') || trimmed.startsWith('[')) {\n            try {\n              payload = JSON.parse(rawData) as Record<string, JsonValue>;\n            } catch (parseError) {\n              logger.warn('解析 SSE 数据失败', { parseError, rawData });\n              payload = rawData;\n            }\n          }\n        }\n\n        this.dispatchFastGPTEvent(provider, parsed.event, payload, onChunk, onStatus, onEvent, ctx);\n      };\n\n      stream.on('data', (chunk: Buffer) => {\n        buffer += chunk.toString();\n\n        let boundary: { index: number; length: number } | null;\n        while ((boundary = this.findNextEventBoundary(buffer)) !== null) {\n          const rawBlock = buffer.slice(0, boundary.index);\n          buffer = buffer.slice(boundary.index + boundary.length);\n\n          if (rawBlock.trim().length === 0) {\n            continue;\n          }\n\n          flushEventBlock(rawBlock);\n        }\n      });\n\n      stream.on('end', () => {\n        if (buffer.trim().length > 0) {\n          flushEventBlock(buffer);\n          buffer = '';\n        }\n\n        if (!completed) {\n          completed = true;\n          logger.debug('流式响应结束');\n          this.logStreamEvent(ctx, 'complete', { ended: true });\n          onStatus?.({ type: 'complete', status: 'completed' });\n          resolve();\n        }\n      });\n\n      stream.on('error', (error: Error) => {\n        logger.error('流式响应错误', { error });\n        this.logStreamEvent(ctx, 'error', { message: error.message });\n        onStatus?.({ type: 'error', status: 'error', error: error.message });\n        if (!completed) {\n          completed = true;\n          reject(error);\n        }\n      });\n    });\n  }\n\n  /**\n   * 获取提供商适配器\n   */\n  private getProvider(providerName: string): AIProvider | undefined {\n    return this.providers.get(providerName.toLowerCase());\n  }\n\n  /**\n   * 验证智能体配置\n   */\n  async validateAgentConfig(agentId: string): Promise<boolean> {\n    const config = await this.agentService.getAgent(agentId);\n    if (!config) {\n      return false;\n    }\n\n    const provider = this.getProvider(config.provider);\n    if (!provider) {\n      return false;\n    }\n\n    return provider.validateConfig(config);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/CircuitBreakerService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":156,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":156,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metrics' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":270,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":270,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 熔断器服务 - 保护外部API调用\n * 实现三种状态：CLOSED、OPEN、HALF_OPEN\n */\n\nimport logger from '@/utils/logger';\n\nexport enum CircuitState {\n  CLOSED = 'CLOSED',     // 正常状态，允许请求通过\n  OPEN = 'OPEN',         // 熔断状态，拒绝所有请求\n  HALF_OPEN = 'HALF_OPEN' // 半开状态，允许少量请求测试\n}\n\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;     // 失败阈值\n  successThreshold: number;     // 成功阈值（半开状态）\n  timeout: number;             // 超时时间（毫秒）\n  resetTimeout: number;        // 重置时间（毫秒）\n  monitoringEnabled?: boolean; // 是否启用监控\n}\n\nexport interface CircuitBreakerMetrics {\n  state: CircuitState;\n  failureCount: number;\n  successCount: number;\n  lastFailureTime?: Date;\n  lastSuccessTime?: Date;\n  totalRequests: number;\n  totalFailures: number;\n  totalSuccesses: number;\n  averageResponseTime: number;\n  circuitOpenCount: number;\n  lastStateChange: Date;\n}\n\nexport interface CircuitBreakerEvents {\n  onStateChange?: (oldState: CircuitState, newState: CircuitState, metrics: CircuitBreakerMetrics) => void;\n  onFailure?: (error: Error, metrics: CircuitBreakerMetrics) => void;\n  onSuccess?: (responseTime: number, metrics: CircuitBreakerMetrics) => void;\n  onTimeout?: (metrics: CircuitBreakerMetrics) => void;\n}\n\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failureCount = 0;\n  private successCount = 0;\n  private lastFailureTime?: Date;\n  private lastSuccessTime?: Date;\n  private nextAttempt = Date.now();\n  private metrics: CircuitBreakerMetrics;\n  private responseTimes: number[] = [];\n  private circuitOpenCount = 0;\n\n  constructor(\n    private readonly name: string,\n    private readonly config: CircuitBreakerConfig,\n    private readonly events?: CircuitBreakerEvents,\n  ) {\n    this.metrics = {\n      state: this.state,\n      failureCount: 0,\n      successCount: 0,\n      totalRequests: 0,\n      totalFailures: 0,\n      totalSuccesses: 0,\n      averageResponseTime: 0,\n      circuitOpenCount: 0,\n      lastStateChange: new Date(),\n    };\n  }\n\n  /**\n   * 执行受保护的操作\n   */\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    const startTime = Date.now();\n    this.metrics.totalRequests++;\n\n    // 检查是否允许请求通过\n    if (!this.allowRequest()) {\n      const error = new Error(`熔断器 ${this.name} 处于 ${this.state} 状态，拒绝请求`);\n      this.events?.onFailure?.(error, this.getMetrics());\n      throw error;\n    }\n\n    try {\n      // 设置超时\n      const result = await this.withTimeout(operation(), this.config.timeout);\n      const responseTime = Date.now() - startTime;\n\n      this.onSuccess(responseTime);\n      this.events?.onSuccess?.(responseTime, this.getMetrics());\n\n      return result;\n    } catch (error) {\n      this.onFailure(error as Error);\n      this.events?.onFailure?.(error as Error, this.getMetrics());\n      throw error;\n    }\n  }\n\n  /**\n   * 检查是否允许请求通过\n   */\n  private allowRequest(): boolean {\n    const now = Date.now();\n\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        return true;\n\n      case CircuitState.OPEN:\n        if (now < this.nextAttempt) {\n          return false;\n        }\n        // 尝试进入半开状态\n        this.transitionTo(CircuitState.HALF_OPEN);\n        return true;\n\n      case CircuitState.HALF_OPEN:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * 处理成功情况\n   */\n  private onSuccess(responseTime: number): void {\n    this.metrics.totalSuccesses++;\n    this.lastSuccessTime = new Date();\n    this.updateResponseTime(responseTime);\n\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        this.failureCount = 0;\n        break;\n\n      case CircuitState.HALF_OPEN:\n        this.successCount++;\n        if (this.successCount >= this.config.successThreshold) {\n          this.transitionTo(CircuitState.CLOSED);\n        }\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  /**\n   * 处理失败情况\n   */\n  private onFailure(error: Error): void {\n    this.metrics.totalFailures++;\n    this.lastFailureTime = new Date();\n    this.failureCount++;\n\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        if (this.failureCount >= this.config.failureThreshold) {\n          this.transitionTo(CircuitState.OPEN);\n        }\n        break;\n\n      case CircuitState.HALF_OPEN:\n        this.transitionTo(CircuitState.OPEN);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  /**\n   * 状态转换\n   */\n  private transitionTo(newState: CircuitState): void {\n    const oldState = this.state;\n    this.state = newState;\n    this.metrics.lastStateChange = new Date();\n\n    switch (newState) {\n      case CircuitState.OPEN:\n        this.nextAttempt = Date.now() + this.config.resetTimeout;\n        this.circuitOpenCount++;\n        this.metrics.circuitOpenCount = this.circuitOpenCount;\n        logger.warn('熔断器打开', { name: this.name, nextAttemptTime: new Date(this.nextAttempt).toISOString() });\n        break;\n\n      case CircuitState.CLOSED:\n        this.failureCount = 0;\n        this.successCount = 0;\n        logger.info('熔断器关闭，恢复正常服务', { name: this.name });\n        break;\n\n      case CircuitState.HALF_OPEN:\n        this.successCount = 0;\n        logger.info('熔断器进入半开状态，开始测试服务', { name: this.name });\n        break;\n    }\n\n    this.metrics.state = newState;\n    this.events?.onStateChange?.(oldState, newState, this.getMetrics());\n  }\n\n  /**\n   * 带超时的操作执行\n   */\n  private async withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error('操作超时')), timeoutMs);\n    });\n\n    return Promise.race([promise, timeoutPromise]);\n  }\n\n  /**\n   * 更新响应时间统计\n   */\n  private updateResponseTime(responseTime: number): void {\n    this.responseTimes.push(responseTime);\n    if (this.responseTimes.length > 100) {\n      this.responseTimes.shift();\n    }\n    this.metrics.averageResponseTime = this.responseTimes.reduce((sum, time) => sum + time, 0) / this.responseTimes.length;\n  }\n\n  /**\n   * 获取熔断器指标\n   */\n  getMetrics(): CircuitBreakerMetrics {\n    return {\n      ...this.metrics,\n      state: this.state,\n      failureCount: this.failureCount,\n      successCount: this.successCount,\n      ...(this.lastFailureTime && { lastFailureTime: this.lastFailureTime }),\n      ...(this.lastSuccessTime && { lastSuccessTime: this.lastSuccessTime }),\n    };\n  }\n\n  /**\n   * 获取当前状态\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n\n  /**\n   * 手动重置熔断器\n   */\n  reset(): void {\n    this.transitionTo(CircuitState.CLOSED);\n  }\n\n  /**\n   * 强制打开熔断器\n   */\n  forceOpen(): void {\n    this.transitionTo(CircuitState.OPEN);\n  }\n\n  /**\n   * 获取健康状态\n   */\n  getHealthStatus(): { healthy: boolean; state: CircuitState; message: string } {\n    const metrics = this.getMetrics();\n\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        return {\n          healthy: true,\n          state: this.state,\n          message: '服务正常',\n        };\n\n      case CircuitState.HALF_OPEN:\n        return {\n          healthy: false,\n          state: this.state,\n          message: '服务恢复中，正在测试',\n        };\n\n      case CircuitState.OPEN: {\n        const timeUntilReset = Math.max(0, this.nextAttempt - Date.now());\n        return {\n          healthy: false,\n          state: this.state,\n          message: `服务熔断，${Math.ceil(timeUntilReset / 1000)}秒后重试`,\n        };\n      }\n\n      default:\n        return {\n          healthy: false,\n          state: this.state,\n          message: '未知状态',\n        };\n    }\n  }\n}\n\n/**\n * 熔断器管理器 - 管理多个熔断器实例\n */\nexport class CircuitBreakerManager {\n  private static instance: CircuitBreakerManager;\n  private circuitBreakers: Map<string, CircuitBreaker> = new Map();\n\n  private constructor() {}\n\n  static getInstance(): CircuitBreakerManager {\n    if (!CircuitBreakerManager.instance) {\n      CircuitBreakerManager.instance = new CircuitBreakerManager();\n    }\n    return CircuitBreakerManager.instance;\n  }\n\n  /**\n   * 创建或获取熔断器\n   */\n  getCircuitBreaker(\n    name: string,\n    config?: CircuitBreakerConfig,\n    events?: CircuitBreakerEvents,\n  ): CircuitBreaker {\n    let circuitBreaker = this.circuitBreakers.get(name);\n\n    if (!circuitBreaker && config) {\n      circuitBreaker = new CircuitBreaker(name, config, events);\n      this.circuitBreakers.set(name, circuitBreaker);\n    }\n\n    if (!circuitBreaker) {\n      throw new Error(`熔断器 ${name} 不存在且未提供配置`);\n    }\n\n    return circuitBreaker;\n  }\n\n  /**\n   * 获取所有熔断器状态\n   */\n  getAllCircuitBreakers(): { name: string; metrics: CircuitBreakerMetrics }[] {\n    return Array.from(this.circuitBreakers.entries()).map(([name, circuitBreaker]) => ({\n      name,\n      metrics: circuitBreaker.getMetrics(),\n    }));\n  }\n\n  /**\n   * 获取所有熔断器健康状态\n   */\n  getHealthStatus(): { name: string; healthy: boolean; state: CircuitState; message: string }[] {\n    return Array.from(this.circuitBreakers.entries()).map(([name, circuitBreaker]) => ({\n      name,\n      ...circuitBreaker.getHealthStatus(),\n    }));\n  }\n\n  /**\n   * 重置所有熔断器\n   */\n  resetAll(): void {\n    this.circuitBreakers.forEach(circuitBreaker => circuitBreaker.reset());\n  }\n\n  /**\n   * 删除熔断器\n   */\n  removeCircuitBreaker(name: string): boolean {\n    return this.circuitBreakers.delete(name);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/DashScopeService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ChatResponse' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":48},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5673,5676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5673,5676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 阿里云 DashScope API 服务\n *\n * 封装通义千问系列模型的 API 调用\n * 支持标准 OpenAI 兼容接口和 Function Calling\n */\n\nimport axios, { AxiosInstance } from 'axios';\nimport { ChatMessage, ChatOptions, ChatResponse } from '@/types';\nimport { CadFunctionTool } from '@llmchat/shared-types';\nimport logger from '@/utils/logger';\n\nexport interface DashScopeConfig {\n  apiKey: string;\n  model?: string;\n  baseURL?: string;\n  timeout?: number;\n}\n\nexport interface DashScopeMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\nexport interface DashScopeRequest {\n  model: string;\n  messages: DashScopeMessage[];\n  stream?: boolean;\n  temperature?: number;\n  max_tokens?: number;\n  tools?: CadFunctionTool[];\n  tool_choice?: 'auto' | 'none';\n}\n\nexport interface DashScopeFunctionCall {\n  name: string;\n  arguments: string;\n}\n\nexport interface DashScopeChoice {\n  index: number;\n  message: {\n    role: 'assistant';\n    content: string;\n    tool_calls?: Array<{\n      id: string;\n      type: 'function';\n      function: DashScopeFunctionCall;\n    }>;\n  };\n  finish_reason: 'stop' | 'length' | 'tool_calls';\n}\n\nexport interface DashScopeResponse {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: DashScopeChoice[];\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\n/**\n * DashScope 服务类\n */\nexport class DashScopeService {\n  private client: AxiosInstance;\n  private config: Required<DashScopeConfig>;\n\n  constructor(config: DashScopeConfig) {\n    this.config = {\n      model: config.model || 'qwen-max',\n      baseURL: config.baseURL || 'https://dashscope.aliyuncs.com/compatible-mode/v1',\n      timeout: config.timeout || 60000,\n      apiKey: config.apiKey,\n    };\n\n    this.client = axios.create({\n      baseURL: this.config.baseURL,\n      timeout: this.config.timeout,\n      headers: {\n        'Authorization': `Bearer ${this.config.apiKey}`,\n        'Content-Type': 'application/json',\n      },\n    });\n\n    logger.info('[DashScopeService] 初始化成功', {\n      model: this.config.model,\n      baseURL: this.config.baseURL,\n    });\n  }\n\n  /**\n   * 发送聊天请求（非流式）\n   */\n  async chatCompletion(\n    messages: ChatMessage[],\n    options?: ChatOptions & { tools?: CadFunctionTool[] },\n  ): Promise<DashScopeResponse> {\n    const request: DashScopeRequest = {\n      model: this.config.model,\n      messages: this.transformMessages(messages),\n      stream: false,\n      temperature: options?.temperature ?? 0.7,\n      max_tokens: options?.maxTokens ?? 8000,\n    };\n\n    // 添加工具定义（Function Calling）\n    if (options?.tools && options.tools.length > 0) {\n      request.tools = options.tools;\n      request.tool_choice = 'auto';\n    }\n\n    try {\n      logger.debug('[DashScopeService] 发送请求', {\n        model: request.model,\n        messageCount: messages.length,\n        hasTools: !!request.tools,\n      });\n\n      const response = await this.client.post<DashScopeResponse>(\n        '/chat/completions',\n        request,\n      );\n\n      logger.info('[DashScopeService] 请求成功', {\n        model: response.data.model,\n        finishReason: response.data.choices[0]?.finish_reason,\n        usage: response.data.usage,\n      });\n\n      return response.data;\n    } catch (error) {\n      logger.error('[DashScopeService] 请求失败', { error });\n      throw this.handleError(error);\n    }\n  }\n\n  /**\n   * 发送流式聊天请求\n   */\n  async *chatCompletionStream(\n    messages: ChatMessage[],\n    options?: ChatOptions & { tools?: CadFunctionTool[] },\n  ): AsyncGenerator<string, void, unknown> {\n    const request: DashScopeRequest = {\n      model: this.config.model,\n      messages: this.transformMessages(messages),\n      stream: true,\n      temperature: options?.temperature ?? 0.7,\n      max_tokens: options?.maxTokens ?? 8000,\n    };\n\n    // 添加工具定义\n    if (options?.tools && options.tools.length > 0) {\n      request.tools = options.tools;\n      request.tool_choice = 'auto';\n    }\n\n    try {\n      logger.debug('[DashScopeService] 发送流式请求', {\n        model: request.model,\n        messageCount: messages.length,\n        hasTools: !!request.tools,\n      });\n\n      const response = await this.client.post('/chat/completions', request, {\n        responseType: 'stream',\n      });\n\n      const stream = response.data;\n\n      for await (const chunk of stream) {\n        const lines = chunk.toString().split('\\n').filter((line: string) => line.trim());\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n\n            if (data === '[DONE]') {\n              logger.info('[DashScopeService] 流式响应结束');\n              return;\n            }\n\n            try {\n              const parsed = JSON.parse(data);\n              const content = parsed.choices[0]?.delta?.content;\n\n              if (content) {\n                yield content;\n              }\n\n              // 处理 Function Calling\n              const toolCalls = parsed.choices[0]?.delta?.tool_calls;\n              if (toolCalls) {\n                logger.debug('[DashScopeService] 收到工具调用', { toolCalls });\n                // 这里可以进一步处理工具调用\n              }\n            } catch (parseError) {\n              logger.warn('[DashScopeService] 解析流式数据失败', { data, parseError });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      logger.error('[DashScopeService] 流式请求失败', { error });\n      throw this.handleError(error);\n    }\n  }\n\n  /**\n   * 转换消息格式\n   */\n  private transformMessages(messages: ChatMessage[]): DashScopeMessage[] {\n    return messages.map(msg => ({\n      role: msg.role as 'system' | 'user' | 'assistant',\n      content: msg.content,\n    }));\n  }\n\n  /**\n   * 错误处理\n   */\n  private handleError(error: any): Error {\n    if (axios.isAxiosError(error)) {\n      const status = error.response?.status;\n      const message = error.response?.data?.error?.message || error.message;\n\n      logger.error('[DashScopeService] API 错误', {\n        status,\n        message,\n        code: error.response?.data?.error?.code,\n      });\n\n      switch (status) {\n        case 401:\n          return new Error('DashScope API Key 无效或已过期');\n        case 429:\n          return new Error('DashScope API 请求频率超限，请稍后重试');\n        case 500:\n        case 502:\n        case 503:\n          return new Error('DashScope 服务暂时不可用，请稍后重试');\n        default:\n          return new Error(`DashScope API 错误: ${message}`);\n      }\n    }\n\n    return error instanceof Error ? error : new Error('未知错误');\n  }\n\n  /**\n   * 健康检查\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      const testMessages: ChatMessage[] = [\n        { role: 'user', content: 'Hello' },\n      ];\n\n      await this.chatCompletion(testMessages, { maxTokens: 10 });\n      return true;\n    } catch (error) {\n      logger.error('[DashScopeService] 健康检查失败', { error });\n      return false;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/DifyInitService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4291,4294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4291,4294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4348,4351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4348,4351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5707,5710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5707,5710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5764,5767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5764,5767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":356,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":356,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10014,10017],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10014,10017],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":357,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10071,10074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10071,10074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport { AgentConfigService } from './AgentConfigService';\nimport { AgentConfig } from '@/types';\nimport { AdaptiveTtlPolicy } from '@/utils/adaptiveCache';\nimport logger from '@/utils/logger';\nimport { ResourceError, ValidationError, ExternalServiceError } from '@/types/errors';\n\n/**\n * Dify应用信息接口\n */\nexport interface DifyAppInfo {\n  name: string;\n  description: string;\n  icon: string;\n  icon_background: string;\n  model_config: {\n    model: string;\n    parameters: {\n      temperature: number;\n      max_tokens: number;\n      top_p?: number;\n      presence_penalty?: number;\n      frequency_penalty?: number;\n    };\n  };\n}\n\n/**\n * Dify应用参数接口\n */\nexport interface DifyAppParameters {\n  user_input_form: Array<{\n    variable: string;\n    label: string;\n    required: boolean;\n    max_length?: number;\n    default?: string;\n    options?: string[];\n  }>;\n  file_upload?: {\n    enabled: boolean;\n    allowed_file_types: string[];\n    allowed_file_extensions: string[];\n    allowed_file_upload_methods: string[];\n  };\n  system_parameters?: {\n    image_file_size_limit?: string;\n    video_file_size_limit?: string;\n    audio_file_size_limit?: string;\n  };\n}\n\n/**\n * Dify初始化响应\n */\nexport interface DifyInitResponse {\n  appInfo: DifyAppInfo;\n  parameters: DifyAppParameters;\n  // 从appInfo提取的便捷字段（测试用）\n  model?: string;\n  system_prompt?: string;\n  temperature?: number;\n  max_tokens?: number;\n}\n\n/**\n * Dify初始化服务\n * 负责调用Dify的info和parameters API\n */\nexport class DifyInitService {\n  private httpClient: ReturnType<typeof axios.create>;\n  private agentService: AgentConfigService;\n  private cache: Map<string, { data: DifyInitResponse; expiresAt: number }> = new Map();\n  private readonly cachePolicy = new AdaptiveTtlPolicy({\n    initialTtl: 5 * 60 * 1000, // 5分钟\n    minTtl: 60 * 1000, // 1分钟\n    maxTtl: 15 * 60 * 1000, // 15分钟\n    step: 60 * 1000,\n    sampleSize: 20,\n    adjustIntervalMs: 2 * 60 * 1000,\n  });\n\n  constructor(agentService: AgentConfigService) {\n    this.agentService = agentService;\n    this.httpClient = axios.create({\n      timeout: 30000,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n  }\n\n  /**\n   * 获取初始化数据（包含应用信息和参数配置）\n   */\n  async getInitData(agentId: string): Promise<DifyInitResponse> {\n    // 检查缓存\n    const cached = this.cache.get(agentId);\n    const now = Date.now();\n    if (cached && cached.expiresAt > now) {\n      logger.debug('✅ 使用缓存的Dify初始化数据', { agentId });\n      this.cachePolicy.recordHit();\n      return cached.data;\n    }\n\n    this.cachePolicy.recordMiss();\n\n    // 获取智能体配置\n    const agent = await this.agentService.getAgent(agentId);\n    if (!agent) {\n      throw new ResourceError({\n        message: `智能体不存在: ${agentId}`,\n        code: 'AGENT_NOT_FOUND',\n        resourceType: 'agent',\n        resourceId: agentId,\n      });\n    }\n\n    if (agent.provider !== 'dify') {\n      throw new ValidationError({\n        message: `智能体 ${agentId} 不是Dify类型，无法获取初始化数据`,\n        code: 'INVALID_PROVIDER_TYPE',\n        field: 'provider',\n        value: agent.provider,\n      });\n    }\n\n    // 并行调用Dify API\n    const [appInfo, parameters] = await Promise.all([\n      this.callDifyInfoAPI(agent),\n      this.callDifyParametersAPI(agent),\n    ]);\n\n    const initData: DifyInitResponse = { appInfo, parameters };\n\n    // 缓存结果\n    this.cache.set(agentId, {\n      data: initData,\n      expiresAt: Date.now() + this.cachePolicy.getTtl(),\n    });\n\n    return initData;\n  }\n\n  /**\n   * 调用Dify应用信息API\n   */\n  async callDifyInfoAPI(agent: AgentConfig): Promise<DifyAppInfo> {\n    try {\n      // 构建Dify API URL\n      const baseUrl = agent.endpoint.replace(/\\/v1\\/chat-messages$/, '');\n      const infoUrl = `${baseUrl}/v1/info`;\n\n      logger.debug('🚀 调用Dify Info API', { infoUrl, agentId: agent.id });\n\n      // 发送请求\n      const response = await this.httpClient.get(infoUrl, {\n        headers: {\n          'Authorization': `Bearer ${agent.apiKey}`,\n        },\n      });\n\n      logger.debug('✅ Dify Info API调用成功', { agentId: agent.id });\n      return response.data;\n\n    } catch (error) {\n      logger.error('❌ Dify Info API调用失败', {\n        agentId: agent.id,\n        error: error instanceof Error ? error.message : error,\n      });\n      if (error && typeof error === 'object' && 'isAxiosError' in error && (error as any).isAxiosError) {\n        const axiosError = error as any;\n        const message = axiosError.response?.data?.message || axiosError.message;\n        const statusCode = axiosError.response?.status;\n        throw new ExternalServiceError({\n          message: `Dify Info API调用失败 (${statusCode || 'unknown'}): ${message}`,\n          code: 'DIFY_INFO_API_ERROR',\n          service: 'Dify',\n          endpoint: `${agent.endpoint}/info`,\n          originalError: axiosError,\n        });\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * 调用Dify应用参数API\n   */\n  async callDifyParametersAPI(agent: AgentConfig): Promise<DifyAppParameters> {\n    try {\n      // 构建Dify API URL\n      const baseUrl = agent.endpoint.replace(/\\/v1\\/chat-messages$/, '');\n      const parametersUrl = `${baseUrl}/v1/parameters`;\n\n      logger.debug('🚀 调用Dify Parameters API', { parametersUrl, agentId: agent.id });\n\n      // 发送请求\n      const response = await this.httpClient.get(parametersUrl, {\n        headers: {\n          'Authorization': `Bearer ${agent.apiKey}`,\n        },\n      });\n\n      logger.debug('✅ Dify Parameters API调用成功', { agentId: agent.id });\n      return response.data;\n\n    } catch (error) {\n      logger.error('❌ Dify Parameters API调用失败', {\n        agentId: agent.id,\n        error: error instanceof Error ? error.message : error,\n      });\n      if (error && typeof error === 'object' && 'isAxiosError' in error && (error as any).isAxiosError) {\n        const axiosError = error as any;\n        const message = axiosError.response?.data?.message || axiosError.message;\n        const statusCode = axiosError.response?.status;\n        throw new ExternalServiceError({\n          message: `Dify Parameters API调用失败 (${statusCode || 'unknown'}): ${message}`,\n          code: 'DIFY_PARAMETERS_API_ERROR',\n          service: 'Dify',\n          endpoint: `${agent.endpoint}/parameters`,\n          originalError: axiosError,\n        });\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * 直接通过endpoint和apiKey获取应用信息（用于管理端自动获取）\n   */\n  async fetchAppInfoByCredentials(\n    endpoint: string,\n    apiKey: string,\n  ): Promise<{\n    name: string;\n    description: string;\n    model: string;\n    temperature?: number;\n    maxTokens?: number;\n    capabilities: string[];\n    features: AgentConfig['features'];\n    variables?: Array<{\n      name: string;\n      label: string;\n      required: boolean;\n      type: string;\n    }>;\n    fileUpload?: {\n      enabled: boolean;\n      allowedTypes: string[];\n    };\n  }> {\n    try {\n      // 构建Dify API URL\n      const baseUrl = endpoint.replace(/\\/v1\\/chat-messages$/, '');\n      const infoUrl = `${baseUrl}/v1/info`;\n      const parametersUrl = `${baseUrl}/v1/parameters`;\n\n      logger.debug('🔍 自动获取Dify应用信息', { endpoint });\n\n      // 并行调用API\n      const [infoResponse, paramsResponse] = await Promise.all([\n        this.httpClient.get(infoUrl, {\n          headers: { 'Authorization': `Bearer ${apiKey}` },\n        }),\n        this.httpClient.get(parametersUrl, {\n          headers: { 'Authorization': `Bearer ${apiKey}` },\n        }),\n      ]);\n\n      const appInfo: DifyAppInfo = infoResponse.data;\n      const params: DifyAppParameters = paramsResponse.data;\n\n      // 提取能力标签\n      const capabilities: string[] = ['chat'];\n      if (params.file_upload?.enabled) {\n        capabilities.push('file-upload');\n      }\n      if (params.user_input_form && params.user_input_form.length > 0) {\n        capabilities.push('variables');\n      }\n\n      // 转换变量定义\n      const variables = params.user_input_form.map(field => ({\n        name: field.variable,\n        label: field.label,\n        required: field.required,\n        type: field.options ? 'select' : field.max_length ? 'textarea' : 'text',\n      }));\n\n      // 转换文件上传配置\n      const fileUpload = params.file_upload ? {\n        enabled: params.file_upload.enabled,\n        allowedTypes: params.file_upload.allowed_file_extensions || [],\n      } : undefined;\n\n      logger.info('✅ Dify应用信息获取成功', {\n        name: appInfo.name,\n        model: appInfo.model_config.model,\n      });\n\n      const result: {\n        name: string;\n        description: string;\n        model: string;\n        temperature?: number;\n        maxTokens?: number;\n        capabilities: string[];\n        features: AgentConfig['features'];\n        variables?: Array<{\n          name: string;\n          label: string;\n          required: boolean;\n          type: string;\n        }>;\n        fileUpload?: {\n          enabled: boolean;\n          allowedTypes: string[];\n        };\n      } = {\n        name: appInfo.name,\n        description: appInfo.description || `Dify应用: ${appInfo.name}`,\n        model: appInfo.model_config.model,\n        temperature: appInfo.model_config.parameters.temperature,\n        maxTokens: appInfo.model_config.parameters.max_tokens,\n        capabilities,\n        features: {\n          supportsChatId: true, // Dify使用conversation_id\n          supportsStream: true,\n          supportsDetail: false, // Dify没有detail模式\n          supportsFiles: params.file_upload?.enabled || false,\n          supportsImages: params.file_upload?.allowed_file_types?.includes('image') || false,\n          streamingConfig: {\n            enabled: true,\n            endpoint: 'same',\n            statusEvents: false, // Dify没有FastGPT的状态事件\n            flowNodeStatus: false,\n          },\n        },\n        variables,\n      };\n\n      // 只有在fileUpload存在时才添加\n      if (fileUpload) {\n        result.fileUpload = fileUpload;\n      }\n\n      return result;\n\n    } catch (error) {\n      logger.error('❌ Dify应用信息获取失败', {\n        endpoint,\n        error: error instanceof Error ? error.message : error,\n      });\n      if (error && typeof error === 'object' && 'isAxiosError' in error && (error as any).isAxiosError) {\n        const axiosError = error as any;\n        const message = axiosError.response?.data?.message || axiosError.message;\n        const statusCode = axiosError.response?.status;\n        throw new ExternalServiceError({\n          message: `Dify API调用失败 (${statusCode || 'unknown'}): ${message}`,\n          code: 'DIFY_API_ERROR',\n          service: 'Dify',\n          originalError: axiosError,\n        });\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.cachePolicy.reset();\n    logger.debug('🧹 Dify初始化数据缓存已清除');\n  }\n\n  /**\n   * 清除过期缓存\n   */\n  clearExpiredCache(): void {\n    const now = Date.now();\n    for (const [key, value] of this.cache.entries()) {\n      if (value.expiresAt <= now) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/DifySessionService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[235,238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[235,238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[426,429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[426,429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1116,1119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1116,1119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3688,3691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3688,3691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":224,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5047,5050],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5047,5050],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":267,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6082,6085],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6082,6085],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":307,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":307,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7036,7039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7036,7039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":353,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8141,8144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8141,8144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":397,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9236,9239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9236,9239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":445,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10306,10309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10306,10309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios, { AxiosInstance } from 'axios';\nimport { AgentConfig } from '@/types';\nimport logger from '@/utils/logger';\n\n/**\n * Dify 会话接口\n */\nexport interface DifyConversation {\n  id: string;\n  name: string;\n  inputs: Record<string, any>;\n  status: string;\n  introduction: string;\n  created_at: number;\n}\n\n/**\n * Dify 消息接口\n */\nexport interface DifyMessage {\n  id: string;\n  conversation_id: string;\n  inputs: Record<string, any>;\n  query: string;\n  answer: string;\n  message_files?: Array<{\n    id: string;\n    type: string;\n    url: string;\n    belongs_to: string;\n  }>;\n  feedback?: {\n    rating: 'like' | 'dislike' | null;\n  };\n  retriever_resources?: Array<{\n    position: number;\n    dataset_id: string;\n    dataset_name: string;\n    document_id: string;\n    document_name: string;\n    segment_id: string;\n    score: number;\n    content: string;\n  }>;\n  created_at: number;\n}\n\n/**\n * Dify 消息详情（扩展版）\n */\nexport interface DifyMessageDetail extends DifyMessage {\n  metadata: {\n    usage: {\n      prompt_tokens: number;\n      completion_tokens: number;\n      total_tokens: number;\n    };\n    retriever_resources: any[];\n  };\n}\n\n/**\n * Dify 会话列表参数\n */\nexport interface DifyConversationListParams {\n  user?: string;      // 用户标识\n  limit?: number;     // 返回数量限制 (默认 20, 最大 100)\n  last_id?: string;   // 上一页最后一个会话 ID，用于分页\n}\n\n/**\n * Dify 消息列表参数\n */\nexport interface DifyMessageListParams {\n  conversation_id: string;\n  user?: string;\n  first_id?: string;  // 当前页第一条消息 ID\n  limit?: number;\n}\n\n/**\n * Dify 反馈参数\n */\nexport interface DifyFeedbackParams {\n  message_id: string;\n  rating: 'like' | 'dislike' | null;\n  user?: string;\n}\n\n/**\n * Dify 会话管理服务\n *\n * 负责管理 Dify 智能体的会话历史、消息查询、反馈等功能\n *\n * 主要功能：\n * - 获取会话列表\n * - 获取会话消息\n * - 获取单条消息详情\n * - 删除会话\n * - 提交消息反馈（点赞/点踩）\n * - 获取建议问题\n *\n * API 端点参考：\n * - GET  /v1/conversations - 会话列表\n * - GET  /v1/messages - 消息列表\n * - GET  /v1/messages/:id - 消息详情\n * - DELETE /v1/conversations/:id - 删除会话\n * - POST /v1/messages/:id/feedbacks - 提交反馈\n * - GET  /v1/messages/:id/suggested - 建议问题\n */\nexport class DifySessionService {\n  private httpClient: AxiosInstance;\n\n  constructor() {\n    this.httpClient = axios.create({\n      timeout: parseInt(process.env.REQUEST_TIMEOUT || '30000', 10),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n  }\n\n  /**\n   * 获取基础 URL\n   */\n  private getBaseUrl(agent: AgentConfig): string {\n    return agent.endpoint.replace(/\\/$/, '');\n  }\n\n  /**\n   * 构建请求头\n   */\n  private buildHeaders(agent: AgentConfig): Record<string, string> {\n    return {\n      'Authorization': `Bearer ${agent.apiKey}`,\n      'Content-Type': 'application/json',\n    };\n  }\n\n  /**\n   * 获取会话列表\n   *\n   * @param agent - 智能体配置\n   * @param params - 查询参数\n   * @returns 会话列表\n   */\n  async getConversations(\n    agent: AgentConfig,\n    params?: DifyConversationListParams,\n  ): Promise<{ data: Array<DifyConversation>; has_more: boolean; limit: number }> {\n    try {\n      const baseUrl = this.getBaseUrl(agent);\n      const url = `${baseUrl}/v1/conversations`;\n\n      const response = await this.httpClient.get(url, {\n        headers: this.buildHeaders(agent),\n        params: {\n          user: params?.user || 'default-user',\n          limit: params?.limit || 20,\n          ...(params?.last_id && { last_id: params.last_id }),\n        },\n      });\n\n      logger.info('Dify 会话列表查询成功', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        count: response.data.data?.length || 0,\n        hasMore: response.data.has_more,\n      });\n\n      return {\n        data: response.data.data || [],\n        has_more: response.data.has_more || false,\n        limit: response.data.limit || 20,\n      };\n    } catch (error: any) {\n      logger.error('Dify 会话列表查询失败', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        error: error.message,\n        status: error.response?.status,\n      });\n      throw new Error(`获取会话列表失败: ${error.message}`);\n    }\n  }\n\n  /**\n   * 获取会话消息列表\n   *\n   * @param agent - 智能体配置\n   * @param params - 查询参数\n   * @returns 消息列表\n   */\n  async getConversationMessages(\n    agent: AgentConfig,\n    params: DifyMessageListParams,\n  ): Promise<{ data: Array<DifyMessage>; has_more: boolean; limit: number }> {\n    try {\n      const baseUrl = this.getBaseUrl(agent);\n      const url = `${baseUrl}/v1/messages`;\n\n      const response = await this.httpClient.get(url, {\n        headers: this.buildHeaders(agent),\n        params: {\n          conversation_id: params.conversation_id,\n          user: params.user || 'default-user',\n          limit: params.limit || 20,\n          ...(params.first_id && { first_id: params.first_id }),\n        },\n      });\n\n      logger.info('Dify 会话消息查询成功', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        conversationId: params.conversation_id,\n        count: response.data.data?.length || 0,\n      });\n\n      return {\n        data: response.data.data || [],\n        has_more: response.data.has_more || false,\n        limit: response.data.limit || 20,\n      };\n    } catch (error: any) {\n      logger.error('Dify 会话消息查询失败', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        conversationId: params.conversation_id,\n        error: error.message,\n        status: error.response?.status,\n      });\n      throw new Error(`获取会话消息失败: ${error.message}`);\n    }\n  }\n\n  /**\n   * 获取消息详情\n   *\n   * @param agent - 智能体配置\n   * @param messageId - 消息 ID\n   * @param user - 用户标识\n   * @returns 消息详情\n   */\n  async getMessageDetail(\n    agent: AgentConfig,\n    messageId: string,\n    user?: string,\n  ): Promise<DifyMessageDetail> {\n    try {\n      const baseUrl = this.getBaseUrl(agent);\n      const url = `${baseUrl}/v1/messages/${messageId}`;\n\n      const response = await this.httpClient.get(url, {\n        headers: this.buildHeaders(agent),\n        params: {\n          user: user || 'default-user',\n        },\n      });\n\n      logger.info('Dify 消息详情查询成功', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        messageId,\n      });\n\n      return response.data;\n    } catch (error: any) {\n      logger.error('Dify 消息详情查询失败', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        messageId,\n        error: error.message,\n        status: error.response?.status,\n      });\n      throw new Error(`获取消息详情失败: ${error.message}`);\n    }\n  }\n\n  /**\n   * 删除会话\n   *\n   * @param agent - 智能体配置\n   * @param conversationId - 会话 ID\n   * @param user - 用户标识\n   */\n  async deleteConversation(\n    agent: AgentConfig,\n    conversationId: string,\n    user?: string,\n  ): Promise<void> {\n    try {\n      const baseUrl = this.getBaseUrl(agent);\n      const url = `${baseUrl}/v1/conversations/${conversationId}`;\n\n      await this.httpClient.delete(url, {\n        headers: this.buildHeaders(agent),\n        params: {\n          user: user || 'default-user',\n        },\n      });\n\n      logger.info('Dify 会话删除成功', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        conversationId,\n      });\n    } catch (error: any) {\n      logger.error('Dify 会话删除失败', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        conversationId,\n        error: error.message,\n        status: error.response?.status,\n      });\n      throw new Error(`删除会话失败: ${error.message}`);\n    }\n  }\n\n  /**\n   * 提交消息反馈（点赞/点踩）\n   *\n   * @param agent - 智能体配置\n   * @param params - 反馈参数\n   * @returns 反馈结果\n   */\n  async submitFeedback(\n    agent: AgentConfig,\n    params: DifyFeedbackParams,\n  ): Promise<{ result: string }> {\n    try {\n      const baseUrl = this.getBaseUrl(agent);\n      const url = `${baseUrl}/v1/messages/${params.message_id}/feedbacks`;\n\n      const response = await this.httpClient.post(\n        url,\n        {\n          rating: params.rating,\n          user: params.user || 'default-user',\n        },\n        {\n          headers: this.buildHeaders(agent),\n        },\n      );\n\n      logger.info('Dify 消息反馈提交成功', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        messageId: params.message_id,\n        rating: params.rating,\n      });\n\n      return response.data;\n    } catch (error: any) {\n      logger.error('Dify 消息反馈提交失败', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        messageId: params.message_id,\n        error: error.message,\n        status: error.response?.status,\n      });\n      throw new Error(`提交反馈失败: ${error.message}`);\n    }\n  }\n\n  /**\n   * 获取建议问题\n   *\n   * @param agent - 智能体配置\n   * @param messageId - 消息 ID\n   * @param user - 用户标识\n   * @returns 建议问题列表\n   */\n  async getSuggestedQuestions(\n    agent: AgentConfig,\n    messageId: string,\n    user?: string,\n  ): Promise<Array<string>> {\n    try {\n      const baseUrl = this.getBaseUrl(agent);\n      const url = `${baseUrl}/v1/messages/${messageId}/suggested`;\n\n      const response = await this.httpClient.get(url, {\n        headers: this.buildHeaders(agent),\n        params: {\n          user: user || 'default-user',\n        },\n      });\n\n      logger.info('Dify 建议问题查询成功', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        messageId,\n        count: response.data.data?.length || 0,\n      });\n\n      return response.data.data || [];\n    } catch (error: any) {\n      logger.error('Dify 建议问题查询失败', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        messageId,\n        error: error.message,\n        status: error.response?.status,\n      });\n      // 建议问题失败不抛错，返回空数组\n      return [];\n    }\n  }\n\n  /**\n   * 重命名会话（Dify API 可能不支持，预留接口）\n   *\n   * @param agent - 智能体配置\n   * @param conversationId - 会话 ID\n   * @param name - 新名称\n   * @param user - 用户标识\n   */\n  async renameConversation(\n    agent: AgentConfig,\n    conversationId: string,\n    name: string,\n    user?: string,\n  ): Promise<void> {\n    try {\n      const baseUrl = this.getBaseUrl(agent);\n      const url = `${baseUrl}/v1/conversations/${conversationId}/name`;\n\n      await this.httpClient.post(\n        url,\n        {\n          name,\n          user: user || 'default-user',\n        },\n        {\n          headers: this.buildHeaders(agent),\n        },\n      );\n\n      logger.info('Dify 会话重命名成功', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        conversationId,\n        newName: name,\n      });\n    } catch (error: any) {\n      logger.warn('Dify 会话重命名失败（API 可能不支持）', {\n        component: 'DifySessionService',\n        agentId: agent.id,\n        conversationId,\n        error: error.message,\n        status: error.response?.status,\n      });\n      // 不抛错，因为 Dify API 可能不支持此功能\n    }\n  }\n}\n\n// 导出单例实例\nexport const difySessionService = new DifySessionService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/EthicsFirewallService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/FastGPTSessionService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1380,1383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1380,1383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2875,2878],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2875,2878],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3029,3032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3029,3032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3220,3223],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3220,3223],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4422,4425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4422,4425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4532,4535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4532,4535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4566,4569],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4566,4569],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5485,5488],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5485,5488],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":312,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8945,8948],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8945,8948],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":331,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":331,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10062,10065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10062,10065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":359,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11186,11189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11186,11189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":494,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":494,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15642,15645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15642,15645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":573,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":573,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17816,17819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17816,17819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":621,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":621,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19265,19268],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19265,19268],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":702,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":702,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21919,21922],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21919,21922],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":703,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":703,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21942,21945],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21942,21945],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'agent' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":759,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":759,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":858,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":858,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26302,26305],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26302,26305],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":908,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":908,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27721,27724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27721,27724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":912,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":912,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27799,27802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27799,27802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1012,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1012,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30082,30085],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30082,30085],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport { AgentConfigService } from './AgentConfigService';\nimport logger from '@/utils/logger';\nimport {\n  AgentConfig,\n  ChatMessage,\n  FastGPTChatHistoryDetail,\n  FastGPTChatHistoryMessage,\n  FastGPTChatHistorySummary,\n  SessionListParams,\n  PaginatedResponse,\n  BatchOperationOptions,\n  ExportOptions,\n  SessionEvent,\n  SessionEventType,\n  EventQueryParams,\n} from '@/types';\nimport { getErrorMessage } from '@/utils/helpers';\nimport { AdaptiveTtlPolicy } from '@/utils/adaptiveCache';\nimport { SessionEventService } from './SessionEventService';\n\ninterface RequestDescriptor {\n  method: 'get' | 'post' | 'delete';\n  path: string;\n}\n\ninterface ListParams {\n  page?: number;\n  pageSize?: number;\n}\n\ninterface CacheEntry<T> {\n  expiresAt: number;\n  data: T;\n}\n\nconst FASTGPT_COMPLETIONS_SUFFIX = '/api/v1/chat/completions';\n\nconst buildCacheKey = (agentId: string, segment: string) => `${agentId}::${segment}`;\n\n/**\n * FastGPT 会话与历史记录服务\n */\nexport class FastGPTSessionService {\n  private readonly agentService: AgentConfigService;\n  private readonly httpClient: ReturnType<typeof axios.create>;\n  private readonly historyListCache = new Map<string, CacheEntry<FastGPTChatHistorySummary[]>>();\n  private readonly historyDetailCache = new Map<string, CacheEntry<FastGPTChatHistoryDetail>>();\n  private readonly inFlightRequests = new Map<string, Promise<any>>();\n  private readonly eventService: SessionEventService;\n  private readonly historyListPolicy = new AdaptiveTtlPolicy({\n    initialTtl: 10 * 1000,\n    minTtl: 5 * 1000,\n    maxTtl: 120 * 1000,\n    step: 5 * 1000,\n    sampleSize: 30,\n    adjustIntervalMs: 60 * 1000,\n  });\n  private readonly historyDetailPolicy = new AdaptiveTtlPolicy({\n    initialTtl: 5 * 1000,\n    minTtl: 2 * 1000,\n    maxTtl: 60 * 1000,\n    step: 3 * 1000,\n    sampleSize: 30,\n    adjustIntervalMs: 45 * 1000,\n  });\n  private readonly historyEndpointBases = [\n    '/api/core/chat/history',\n    '/api/v1/core/chat/history',\n    '/api/chat/history',\n    '/api/v1/chat/history',\n  ];\n  private readonly feedbackEndpointBases = [\n    '/api/core/chat/feedback',\n    '/api/v1/core/chat/feedback',\n    '/api/chat/feedback',\n    '/api/v1/chat/feedback',\n  ];\n\n  constructor(agentService: AgentConfigService) {\n    this.agentService = agentService;\n    this.httpClient = axios.create({\n      timeout: parseInt(process.env.REQUEST_TIMEOUT || '30000', 10),\n    });\n    this.eventService = new SessionEventService();\n  }\n\n  /**\n   * 校验并获取 FastGPT 智能体配置\n   *\n   * Args:\n   *   agentId: 智能体唯一标识\n   * Returns:\n   *   AgentConfig: 合法的智能体配置\n   * Raises:\n   *   Error: code = NOT_FOUND | INVALID_PROVIDER | INVALID_APP_ID\n   */\n  private async ensureFastGPTAgent(agentId: string): Promise<AgentConfig> {\n    const agent = await this.agentService.getAgent(agentId);\n    if (!agent) {\n      const err = new Error(`智能体不存在: ${agentId}`) as any;\n      err.code = 'NOT_FOUND';\n      throw err;\n    }\n    if (agent.provider !== 'fastgpt') {\n      const err = new Error('仅 FastGPT 智能体支持会话历史接口') as any;\n      err.code = 'INVALID_PROVIDER';\n      throw err;\n    }\n    if (!agent.appId || !/^[a-fA-F0-9]{24}$/.test(agent.appId)) {\n      const err = new Error('FastGPT 智能体缺少有效的 appId 配置') as any;\n      err.code = 'INVALID_APP_ID';\n      throw err;\n    }\n    return agent;\n  }\n\n  /**\n   * 计算 FastGPT 基础 URL\n   *\n   * 修复URL重复问题：\n   * 输入: http://171.43.138.237:3000/v1/api/v1/chat/completions\n   * 输出: http://171.43.138.237:3000\n   */\n  private getBaseUrl(agent: AgentConfig): string {\n    if (!agent.endpoint) {\n      throw new Error('FastGPT 智能体缺少 endpoint 配置');\n    }\n\n    // 清理空格和末尾斜杠\n    let cleaned = agent.endpoint.replace(/[`\\s]+/g, '').replace(/\\/$/, '');\n\n    // 移除 /chat/completions 后缀\n    if (cleaned.endsWith(FASTGPT_COMPLETIONS_SUFFIX)) {\n      cleaned = cleaned.slice(0, -FASTGPT_COMPLETIONS_SUFFIX.length);\n    }\n\n    // 🔧 关键修复：统一移除末尾的API路径，避免重复拼接\n    // 支持多种格式：/v1/api/v1, /api/v1, /v1\n    cleaned = cleaned\n      .replace(/\\/v1\\/api\\/v1\\/?$/, '')  // 移除 /v1/api/v1 或 /v1/api/v1/\n      .replace(/\\/api\\/v1\\/?$/, '')      // 移除 /api/v1 或 /api/v1/\n      .replace(/\\/v1\\/?$/, '');          // 移除 /v1 或 /v1/\n\n    return cleaned;\n  }\n\n  /**\n   * 统一请求入口，支持多路径尝试与 /v1 回退\n   *\n   * Args:\n   *   agent: 智能体配置\n   *   attempts: 请求尝试序列（方法+路径）\n   *   options: 请求参数与 body\n   * Returns:\n   *   AxiosResponse<T>\n   * Raises:\n   *   Error: 最终请求失败错误\n   */\n  private async requestWithFallback<T = any>(\n    agent: AgentConfig,\n    attempts: RequestDescriptor[],\n    options: {\n      params?: Record<string, any>;\n      data?: Record<string, any>;\n    } = {},\n  ) {\n    const baseUrl = this.getBaseUrl(agent);\n    const headers = {\n      Authorization: `Bearer ${agent.apiKey}`,\n      'Content-Type': 'application/json',\n    };\n\n    let lastError: unknown;\n    for (const attempt of attempts) {\n      // 路径净化，移除反引号与空白\n      const cleanPath = attempt.path.replace(/[`\\s]+/g, '');\n      const url = `${baseUrl}${cleanPath}`;\n\n      try {\n        if (attempt.method === 'get') {\n          return await this.httpClient.get<T>(url, {\n            params: options.params || {},\n            headers,\n          });\n        }\n        if (attempt.method === 'delete') {\n          return await this.httpClient.delete<T>(url, {\n            params: options.params || {},\n            headers,\n          });\n        }\n        return await this.httpClient.post<T>(url, options.data, {\n          params: options.params || {},\n          headers,\n        });\n      } catch (error: any) {\n        lastError = error;\n        // 若 404，尝试 /v1 回退\n        const status = error?.response?.status;\n        if (status === 404) {\n          const v1Url = `${baseUrl}/v1${cleanPath.startsWith('/') ? cleanPath : `/${cleanPath}`}`;\n          try {\n            if (attempt.method === 'get') {\n              return await this.httpClient.get<T>(v1Url, {\n                params: options.params || {},\n                headers,\n              });\n            }\n            if (attempt.method === 'delete') {\n              return await this.httpClient.delete<T>(v1Url, {\n                params: options.params || {},\n                headers,\n              });\n            }\n            return await this.httpClient.post<T>(v1Url, options.data, {\n              params: options.params || {},\n              headers,\n            });\n          } catch (v1Error) {\n            lastError = v1Error;\n          }\n        }\n      }\n    }\n\n    throw lastError instanceof Error ? lastError : new Error(`FastGPT 接口调用失败: ${getErrorMessage(lastError)}`);\n  }\n\n  private buildEndpointAttempts(\n    bases: string[],\n    suffixes: string[],\n    method: RequestDescriptor['method'],\n  ): RequestDescriptor[] {\n    const attempts: RequestDescriptor[] = [];\n    const seen = new Set<string>();\n\n    for (const base of bases) {\n      for (const rawSuffix of suffixes) {\n        const suffix = rawSuffix.replace(/^\\/+/g, '');\n        const path = `${base}/${suffix}`.replace(/\\/+/g, '/');\n        const key = `${method}:${path}`;\n        if (!seen.has(key)) {\n          attempts.push({ method, path });\n          seen.add(key);\n        }\n      }\n    }\n\n    return attempts;\n  }\n\n  private async getWithCache<T>(\n    cache: Map<string, CacheEntry<T>>,\n    key: string,\n    policy: AdaptiveTtlPolicy,\n    fetcher: () => Promise<T>,\n  ): Promise<T> {\n    const now = Date.now();\n    const cached = cache.get(key);\n    if (cached && cached.expiresAt > now) {\n      policy.recordHit();\n      return cached.data;\n    }\n\n    const inflightKey = `inflight::${key}`;\n    if (this.inFlightRequests.has(inflightKey)) {\n      return this.inFlightRequests.get(inflightKey) as Promise<T>;\n    }\n\n    policy.recordMiss();\n    const promise = fetcher()\n      .then((result) => {\n        cache.set(key, { data: result, expiresAt: Date.now() + policy.getTtl() });\n        this.inFlightRequests.delete(inflightKey);\n        return result;\n      })\n      .catch((error) => {\n        this.inFlightRequests.delete(inflightKey);\n        cache.delete(key);\n        throw error;\n      });\n\n    this.inFlightRequests.set(inflightKey, promise);\n    return promise;\n  }\n\n  private invalidateHistoryCaches(agentId: string, chatId?: string): void {\n    const listPrefix = buildCacheKey(agentId, 'list');\n    for (const key of Array.from(this.historyListCache.keys())) {\n      if (key.startsWith(listPrefix)) {\n        this.historyListCache.delete(key);\n      }\n    }\n    this.historyListPolicy.notifyInvalidation();\n\n    if (chatId) {\n      this.historyDetailCache.delete(buildCacheKey(agentId, `detail:${chatId}`));\n      this.historyDetailPolicy.notifyInvalidation();\n      return;\n    }\n\n    const detailPrefix = buildCacheKey(agentId, 'detail');\n    for (const key of Array.from(this.historyDetailCache.keys())) {\n      if (key.startsWith(detailPrefix)) {\n        this.historyDetailCache.delete(key);\n      }\n    }\n    this.historyDetailPolicy.notifyInvalidation();\n  }\n\n  private normalizeHistorySummary(item: any): FastGPTChatHistorySummary {\n    const chatId = item?.chatId || item?.id || item?._id || item?.historyId || item?.history_id || '';\n    const title = item?.title || item?.name || item?.latestQuestion || item?.latest_question || '未命名对话';\n    const createdAt = item?.createTime || item?.create_time || item?.createdAt || item?.created_at || item?.time || new Date().toISOString();\n    const updatedAt =\n      item?.updateTime || item?.update_time || item?.updatedAt || item?.updated_at || item?.lastUpdateTime || item?.last_update_time || createdAt;\n\n    return {\n      chatId: String(chatId),\n      appId: item?.appId || item?.app_id,\n      title: String(title),\n      createdAt: typeof createdAt === 'number' ? new Date(createdAt).toISOString() : String(createdAt),\n      updatedAt: typeof updatedAt === 'number' ? new Date(updatedAt).toISOString() : String(updatedAt),\n      messageCount: Number(item?.messageCount || item?.msgCount || item?.totalMessages || item?.total || 0),\n      tags: Array.isArray(item?.tags) ? item.tags : undefined,\n      raw: item,\n    };\n  }\n\n  private normalizeHistoryMessage(entry: any): FastGPTChatHistoryMessage {\n    const dataId = entry?.dataId || entry?.data_id || entry?._id || entry?.id;\n    const roleRaw = entry?.role || entry?.obj || entry?.type;\n    const role = typeof roleRaw === 'string' ? roleRaw.toLowerCase() : '';\n\n    let normalizedRole: 'user' | 'assistant' | 'system';\n    if (role.includes('system')) {\n      normalizedRole = 'system';\n    } else if (role.includes('assistant') || role.includes('ai') || role.includes('bot')) {\n      normalizedRole = 'assistant';\n    } else {\n      normalizedRole = 'user';\n    }\n\n    const value = entry?.value ?? entry?.content ?? entry?.answer ?? entry?.text ?? '';\n    const content = Array.isArray(value) ? value.map((v) => (typeof v === 'string' ? v : JSON.stringify(v))).join('\\n') : String(value ?? '');\n    const feedback = entry?.userGoodFeedback ? 'good' : entry?.userBadFeedback ? 'bad' : null;\n\n    return {\n      id: dataId ? String(dataId) : undefined,\n      dataId: dataId ? String(dataId) : undefined,\n      role: normalizedRole,\n      content,\n      feedback,\n      raw: entry,\n    };\n  }\n\n  private normalizeHistoryDetail(payload: any): FastGPTChatHistoryDetail {\n    const data = payload?.data ?? payload;\n    const list = data?.list || data?.messages || data?.history || data?.chatHistoryList || data?.detail || [];\n    const title = data?.title || data?.historyName || data?.history_title;\n\n    const messages: FastGPTChatHistoryMessage[] = Array.isArray(list)\n      ? list.map((item) => this.normalizeHistoryMessage(item))\n      : [];\n\n    const chatId = data?.chatId || data?.historyId || data?.id || data?.chat_id || data?.history_id;\n\n    return {\n      chatId: chatId ? String(chatId) : '',\n      appId: data?.appId || data?.app_id,\n      title: title ? String(title) : undefined,\n      messages,\n      sessionInfo: {\n        userId: data?.userId || data?.user_id || null,\n      },\n      metadata: {\n        total: data?.total,\n        hasMore: data?.hasMore,\n        raw: data,\n      },\n    };\n  }\n\n  async listHistories(agentId: string, pagination?: ListParams): Promise<FastGPTChatHistorySummary[]> {\n    const agent = await this.ensureFastGPTAgent(agentId);\n    const params = {\n      appId: agent.appId,\n      page: pagination?.page,\n      pageSize: pagination?.pageSize,\n    };\n\n    const attempts = this.buildEndpointAttempts(\n      this.historyEndpointBases,\n      ['list', 'getHistoryList', 'getHistories'],\n      'get',\n    );\n\n    const cacheKey = buildCacheKey(\n      agentId,\n      `list:${params.page || 1}:${params.pageSize || 'default'}`,\n    );\n\n    return this.getWithCache(this.historyListCache, cacheKey, this.historyListPolicy, async () => {\n      const response = await this.requestWithFallback(agent, attempts, { params });\n      const payload = response.data;\n\n      if (payload?.code && payload.code !== 200) {\n        throw new Error(payload?.message || 'FastGPT 获取会话列表失败');\n      }\n\n      const rawList = payload?.data?.list || payload?.data || payload?.historyList || payload?.list || [];\n      return Array.isArray(rawList) ? rawList.map((item) => this.normalizeHistorySummary(item)) : [];\n    });\n  }\n\n  async getHistoryDetail(agentId: string, chatId: string): Promise<FastGPTChatHistoryDetail> {\n    const agent = await this.ensureFastGPTAgent(agentId);\n\n    const params = {\n      appId: agent.appId,\n      chatId,\n    };\n\n    const attempts = this.buildEndpointAttempts(\n      this.historyEndpointBases,\n      ['detail', 'getHistory', 'messages'],\n      'get',\n    );\n\n    const cacheKey = buildCacheKey(agentId, `detail:${chatId}`);\n\n    return this.getWithCache(this.historyDetailCache, cacheKey, this.historyDetailPolicy, async () => {\n      const response = await this.requestWithFallback(agent, attempts, { params });\n      const payload = response.data;\n\n      if (payload?.code && payload.code !== 200) {\n        throw new Error(payload?.message || 'FastGPT 获取会话详情失败');\n      }\n\n      return this.normalizeHistoryDetail(payload?.data ? payload : payload);\n    });\n  }\n\n  async deleteHistory(agentId: string, chatId: string): Promise<void> {\n    const agent = await this.ensureFastGPTAgent(agentId);\n    const data = { appId: agent.appId, chatId };\n\n    const attempts = this.buildEndpointAttempts(\n      this.historyEndpointBases,\n      ['delete', 'removeHistory', 'delHistory'],\n      'post',\n    );\n\n    const response = await this.requestWithFallback(agent, attempts, { data });\n    const payload = response.data;\n    if (payload?.code && payload.code !== 200) {\n      throw new Error(payload?.message || 'FastGPT 删除历史记录失败');\n    }\n\n    this.invalidateHistoryCaches(agentId, chatId);\n  }\n\n  async clearHistories(agentId: string): Promise<void> {\n    const agent = await this.ensureFastGPTAgent(agentId);\n    const data = { appId: agent.appId };\n\n    const attempts = [\n      ...this.buildEndpointAttempts(this.historyEndpointBases, ['clear', 'clearHistories'], 'post'),\n      ...this.buildEndpointAttempts(this.historyEndpointBases, ['clear'], 'delete'),\n    ];\n\n    const response = await this.requestWithFallback(agent, attempts, { data });\n    const payload = response.data;\n    if (payload?.code && payload.code !== 200) {\n      throw new Error(payload?.message || 'FastGPT 清空历史记录失败');\n    }\n\n    this.invalidateHistoryCaches(agentId);\n  }\n\n  async updateUserFeedback(\n    agentId: string,\n    payload: {\n      chatId: string;\n      dataId: string;\n      userGoodFeedback?: string;\n      userBadFeedback?: string;\n    },\n  ): Promise<void> {\n    const agent = await this.ensureFastGPTAgent(agentId);\n\n    const data: Record<string, any> = {\n      appId: agent.appId,\n      chatId: payload.chatId,\n      dataId: payload.dataId,\n    };\n\n    if (payload.userGoodFeedback) {\n      data.userGoodFeedback = payload.userGoodFeedback;\n    }\n    if (payload.userBadFeedback) {\n      data.userBadFeedback = payload.userBadFeedback;\n    }\n\n    const attempts = this.buildEndpointAttempts(\n      this.feedbackEndpointBases,\n      ['updateUserFeedback'],\n      'post',\n    );\n\n    const response = await this.requestWithFallback(agent, attempts, { data });\n    const respPayload = response.data;\n    if (respPayload?.code && respPayload.code !== 200) {\n      throw new Error(respPayload?.message || 'FastGPT 更新反馈失败');\n    }\n  }\n\n  prepareRetryPayload(\n    detail: FastGPTChatHistoryDetail,\n    targetDataId: string,\n  ): { messages: ChatMessage[]; responseChatItemId?: string } | null {\n    if (!detail || !Array.isArray(detail.messages)) {\n      return null;\n    }\n\n    const index = detail.messages.findIndex((msg) => msg.dataId === targetDataId || msg.id === targetDataId);\n    if (index === -1) {\n      return null;\n    }\n\n    const assistantEntry = detail.messages[index];\n    const previousUser = [...detail.messages]\n      .slice(0, index)\n      .reverse()\n      .find((msg) => msg.role === 'user');\n\n    if (!previousUser) {\n      return null;\n    }\n\n    const messages: ChatMessage[] = [\n      {\n        role: 'user',\n        content: previousUser.content,\n      },\n    ];\n\n    const responseChatItemIdRaw = assistantEntry?.dataId ?? assistantEntry?.id;\n    const responseChatItemId = responseChatItemIdRaw ? String(responseChatItemIdRaw) : undefined;\n\n    const result: { messages: ChatMessage[]; responseChatItemId?: string } = { messages };\n    if (responseChatItemId) {\n      result.responseChatItemId = responseChatItemId;\n    }\n\n    return result;\n  }\n\n  // ==================== 增强功能方法 ====================\n\n  /**\n   * 增强版会话列表查询 - 支持分页、过滤、排序\n   */\n  async listHistoriesEnhanced(\n    agentId: string,\n    params?: SessionListParams,\n  ): Promise<PaginatedResponse<FastGPTChatHistorySummary>> {\n    const agent = await this.ensureFastGPTAgent(agentId);\n\n    // 构建查询参数\n    const queryParams: Record<string, any> = {\n      appId: agent.appId,\n      page: params?.page || 1,\n      pageSize: params?.pageSize || 20,\n    };\n\n    // 添加过滤条件\n    if (params?.startDate) {\n      queryParams.startDate = params.startDate;\n    }\n    if (params?.endDate) {\n      queryParams.endDate = params.endDate;\n    }\n    if (params?.tags && params.tags.length > 0) {\n      queryParams.tags = params.tags.join(',');\n    }\n    if (params?.minMessageCount) {\n      queryParams.minMessageCount = params.minMessageCount;\n    }\n    if (params?.maxMessageCount) {\n      queryParams.maxMessageCount = params.maxMessageCount;\n    }\n    if (params?.searchKeyword) {\n      queryParams.searchKeyword = params.searchKeyword;\n    }\n    if (params?.sortBy) {\n      queryParams.sortBy = params.sortBy;\n    }\n    if (params?.sortOrder) {\n      queryParams.sortOrder = params.sortOrder;\n    }\n\n    const attempts = this.buildEndpointAttempts(\n      this.historyEndpointBases,\n      ['listEnhanced', 'getHistoryListEnhanced', 'getHistoriesEnhanced', 'list'],\n      'get',\n    );\n\n    try {\n      const response = await this.requestWithFallback(agent, attempts, { params: queryParams });\n      const payload = response.data;\n\n      if (payload?.code && payload.code !== 200) {\n        throw new Error(payload?.message || 'FastGPT 获取会话列表失败');\n      }\n\n      const rawData = payload?.data;\n      const sessions = Array.isArray(rawData?.list || rawData)\n        ? (rawData.list || rawData).map((item: any) => this.normalizeHistorySummary(item))\n        : [];\n\n      // 如果远程API不支持增强功能，则使用本地过滤和排序\n      if (!params || Object.keys(params).length === 0 ||\n          (params.page === undefined && params.pageSize === undefined)) {\n        return this.applyLocalFilteringAndPagination(sessions, params);\n      }\n\n      return {\n        data: sessions,\n        total: rawData?.total || sessions.length,\n        page: params?.page || 1,\n        pageSize: params?.pageSize || 20,\n        totalPages: Math.ceil((rawData?.total || sessions.length) / (params?.pageSize || 20)),\n        hasNext: (params?.page || 1) * (params?.pageSize || 20) < (rawData?.total || sessions.length),\n        hasPrev: (params?.page || 1) > 1,\n      };\n    } catch (error) {\n      // 如果增强API不可用，回退到基础API并应用本地处理\n      logger.warn('增强版会话API不可用，使用基础API + 本地处理', { error });\n      const allSessions = await this.listHistories(agentId, { page: 1, pageSize: 1000 });\n      return this.applyLocalFilteringAndPagination(allSessions, params);\n    }\n  }\n\n  /**\n   * 本地过滤和分页处理\n   */\n  private applyLocalFilteringAndPagination(\n    sessions: FastGPTChatHistorySummary[],\n    params?: SessionListParams,\n  ): PaginatedResponse<FastGPTChatHistorySummary> {\n    let filteredSessions = [...sessions];\n\n    // 日期范围过滤\n    if (params?.startDate) {\n      const startDate = new Date(params.startDate);\n      filteredSessions = filteredSessions.filter(session =>\n        new Date(session.createdAt) >= startDate,\n      );\n    }\n    if (params?.endDate) {\n      const endDate = new Date(params.endDate);\n      filteredSessions = filteredSessions.filter(session =>\n        new Date(session.updatedAt) <= endDate,\n      );\n    }\n\n    // 标签过滤\n    if (params?.tags && params.tags.length > 0) {\n      filteredSessions = filteredSessions.filter(session =>\n        session.tags && params.tags!.some(tag => session.tags!.includes(tag)),\n      );\n    }\n\n    // 消息数量过滤\n    if (params?.minMessageCount) {\n      filteredSessions = filteredSessions.filter(session =>\n        (session.messageCount || 0) >= params.minMessageCount!,\n      );\n    }\n    if (params?.maxMessageCount) {\n      filteredSessions = filteredSessions.filter(session =>\n        (session.messageCount || 0) <= params.maxMessageCount!,\n      );\n    }\n\n    // 关键词搜索\n    if (params?.searchKeyword) {\n      const keyword = params.searchKeyword.toLowerCase();\n      filteredSessions = filteredSessions.filter(session =>\n        session.title.toLowerCase().includes(keyword),\n      );\n    }\n\n    // 排序\n    const sortBy = params?.sortBy || 'updatedAt';\n    const sortOrder = params?.sortOrder || 'desc';\n\n    filteredSessions.sort((a, b) => {\n      let aValue: any;\n      let bValue: any;\n\n      switch (sortBy) {\n        case 'createdAt':\n          aValue = new Date(a.createdAt).getTime();\n          bValue = new Date(b.createdAt).getTime();\n          break;\n        case 'updatedAt':\n          aValue = new Date(a.updatedAt).getTime();\n          bValue = new Date(b.updatedAt).getTime();\n          break;\n        case 'messageCount':\n          aValue = a.messageCount || 0;\n          bValue = b.messageCount || 0;\n          break;\n        case 'title':\n          aValue = a.title.toLowerCase();\n          bValue = b.title.toLowerCase();\n          break;\n        default:\n          aValue = new Date(a.updatedAt).getTime();\n          bValue = new Date(b.updatedAt).getTime();\n      }\n\n      if (sortOrder === 'asc') {\n        return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;\n      } else {\n        return aValue < bValue ? 1 : aValue > bValue ? -1 : 0;\n      }\n    });\n\n    // 分页\n    const page = params?.page || 1;\n    const pageSize = params?.pageSize || 20;\n    const startIndex = (page - 1) * pageSize;\n    const endIndex = startIndex + pageSize;\n    const paginatedData = filteredSessions.slice(startIndex, endIndex);\n\n    return {\n      data: paginatedData,\n      total: filteredSessions.length,\n      page,\n      pageSize,\n      totalPages: Math.ceil(filteredSessions.length / pageSize),\n      hasNext: endIndex < filteredSessions.length,\n      hasPrev: page > 1,\n    };\n  }\n\n  /**\n   * 批量操作会话\n   */\n  async batchOperation(\n    agentId: string,\n    options: BatchOperationOptions,\n  ): Promise<{ success: number; failed: number; errors: string[] }> {\n    const agent = await this.ensureFastGPTAgent(agentId);\n    const results = { success: 0, failed: 0, errors: [] as string[] };\n\n    for (const sessionId of options.sessionIds) {\n      try {\n        switch (options.operation) {\n          case 'delete':\n            await this.deleteHistory(agentId, sessionId);\n            // 记录删除事件\n            await this.recordEvent(agentId, sessionId, 'deleted', {\n              reason: 'batch_operation',\n            });\n            break;\n\n          case 'archive':\n            // 归档操作 - 可以通过添加特定标签实现\n            await this.addTagsToSession(agentId, sessionId, ['archived']);\n            await this.recordEvent(agentId, sessionId, 'archived', {\n              reason: 'batch_operation',\n            });\n            break;\n\n          case 'addTags':\n            if (options.tags && options.tags.length > 0) {\n              await this.addTagsToSession(agentId, sessionId, options.tags);\n              await this.recordEvent(agentId, sessionId, 'tags_updated', {\n                tags: options.tags,\n                operation: 'add',\n              });\n            }\n            break;\n\n          case 'removeTags':\n            if (options.tags && options.tags.length > 0) {\n              await this.removeTagsFromSession(agentId, sessionId, options.tags);\n              await this.recordEvent(agentId, sessionId, 'tags_updated', {\n                tags: options.tags,\n                operation: 'remove',\n              });\n            }\n            break;\n\n          default:\n            throw new Error(`不支持的批量操作: ${options.operation}`);\n        }\n\n        results.success++;\n      } catch (error) {\n        results.failed++;\n        const errorMsg = `会话 ${sessionId} 操作失败: ${getErrorMessage(error)}`;\n        results.errors.push(errorMsg);\n        logger.error(errorMsg);\n      }\n    }\n\n    // 清除缓存\n    this.invalidateHistoryCaches(agentId);\n\n    return results;\n  }\n\n  /**\n   * 为会话添加标签\n   */\n  private async addTagsToSession(\n    agentId: string,\n    sessionId: string,\n    tags: string[],\n  ): Promise<void> {\n    // 这里需要根据FastGPT的具体API来实现\n    // 由于当前API可能不直接支持标签操作，可以使用updateUserFeedback的变体\n    // 或者通过其他API端点来实现\n    logger.debug('为会话添加标签', { sessionId, tags });\n    // 实际实现需要调用相应的FastGPT API\n  }\n\n  /**\n   * 从会话移除标签\n   */\n  private async removeTagsFromSession(\n    agentId: string,\n    sessionId: string,\n    tags: string[],\n  ): Promise<void> {\n    logger.debug('从会话移除标签', { sessionId, tags });\n    // 实际实现需要调用相应的FastGPT API\n  }\n\n  /**\n   * 导出会话数据\n   */\n  async exportSessions(\n    agentId: string,\n    options: ExportOptions,\n  ): Promise<{ filename: string; data: string | Buffer }> {\n    // 获取符合条件的会话\n    const result = await this.listHistoriesEnhanced(agentId, options.filters);\n    const sessions = result.data;\n\n    let exportData: any;\n    let filename: string;\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n    switch (options.format) {\n      case 'json':\n        exportData = await this.exportToJson(sessions, options);\n        filename = `sessions_${timestamp}.json`;\n        break;\n\n      case 'csv':\n        exportData = await this.exportToCsv(sessions, options);\n        filename = `sessions_${timestamp}.csv`;\n        break;\n\n      case 'excel':\n        exportData = await this.exportToExcel(sessions, options);\n        filename = `sessions_${timestamp}.xlsx`;\n        break;\n\n      default:\n        throw new Error(`不支持的导出格式: ${options.format}`);\n    }\n\n    // 记录导出事件\n    await this.recordEvent(agentId, 'batch_export', 'exported', {\n      format: options.format,\n      sessionCount: sessions.length,\n      includeMessages: options.includeMessages,\n      includeMetadata: options.includeMetadata,\n    });\n\n    return { filename, data: exportData };\n  }\n\n  /**\n   * 导出为JSON格式\n   */\n  private async exportToJson(\n    sessions: FastGPTChatHistorySummary[],\n    options: ExportOptions,\n  ): Promise<string> {\n    const exportData = {\n      metadata: {\n        exportedAt: new Date().toISOString(),\n        totalSessions: sessions.length,\n        includeMessages: options.includeMessages || false,\n        includeMetadata: options.includeMetadata || false,\n        filters: options.filters,\n      },\n      sessions: [] as any[],\n    };\n\n    for (const session of sessions) {\n      const sessionData: any = {\n        chatId: session.chatId,\n        title: session.title,\n        createdAt: session.createdAt,\n        updatedAt: session.updatedAt,\n        messageCount: session.messageCount,\n        tags: session.tags,\n      };\n\n      // 包含元数据\n      if (options.includeMetadata && session.raw) {\n        sessionData.raw = session.raw;\n      }\n\n      // 包含消息内容\n      if (options.includeMessages) {\n        try {\n          // 这里需要获取会话详情，但需要知道agentId\n          // 暂时跳过，实际实现时需要传入agentId\n          logger.debug('获取会话的详细消息', { chatId: session.chatId });\n        } catch (error) {\n          logger.warn('获取会话消息失败', { chatId: session.chatId, error });\n        }\n      }\n\n      exportData.sessions.push(sessionData);\n    }\n\n    return JSON.stringify(exportData, null, 2);\n  }\n\n  /**\n   * 导出为CSV格式\n   */\n  private async exportToCsv(\n    sessions: FastGPTChatHistorySummary[],\n    options: ExportOptions,\n  ): Promise<string> {\n    const headers = [\n      'Chat ID',\n      'Title',\n      'Created At',\n      'Updated At',\n      'Message Count',\n      'Tags',\n    ];\n\n    if (options.includeMetadata) {\n      headers.push('Raw Data');\n    }\n\n    const csvRows = [headers.join(',')];\n\n    for (const session of sessions) {\n      const row = [\n        `\"${session.chatId}\"`,\n        `\"${this.escapeCsv(session.title)}\"`,\n        session.createdAt,\n        session.updatedAt,\n        session.messageCount || 0,\n        `\"${(session.tags || []).join(';')}\"`,\n      ];\n\n      if (options.includeMetadata && session.raw) {\n        row.push(`\"${this.escapeCsv(JSON.stringify(session.raw))}\"`);\n      }\n\n      csvRows.push(row.join(','));\n    }\n\n    return csvRows.join('\\n');\n  }\n\n  /**\n   * 导出为Excel格式\n   */\n  private async exportToExcel(\n    sessions: FastGPTChatHistorySummary[],\n    options: ExportOptions,\n  ): Promise<Buffer> {\n    // 这里需要使用xlsx库来生成Excel文件\n    // 由于当前环境可能没有安装，先返回CSV格式的Buffer\n    const csvData = await this.exportToCsv(sessions, options);\n    return Buffer.from(csvData, 'utf-8');\n  }\n\n  /**\n   * 转义CSV字段\n   */\n  private escapeCsv(field: string): string {\n    return field.replace(/\"/g, '\"\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n  }\n\n  /**\n   * 记录会话事件\n   */\n  async recordEvent(\n    agentId: string,\n    sessionId: string,\n    eventType: SessionEventType,\n    metadata?: any,\n    context?: {\n      userId?: string;\n      userAgent?: string;\n      ipAddress?: string;\n    },\n  ): Promise<void> {\n    try {\n      await this.eventService.recordEvent(\n        agentId,\n        sessionId,\n        eventType,\n        metadata,\n        context,\n      );\n    } catch (error) {\n      logger.error('记录会话事件失败', { error });\n      // 事件记录失败不应该影响主要功能\n    }\n  }\n\n  /**\n   * 查询会话事件\n   */\n  async queryEvents(\n    agentId: string,\n    params: EventQueryParams,\n  ): Promise<PaginatedResponse<SessionEvent>> {\n    try {\n      return await this.eventService.queryEvents(agentId, params);\n    } catch (error) {\n      logger.error('查询会话事件失败', { error });\n      // 返回空结果而不是抛出错误\n      return {\n        data: [],\n        total: 0,\n        page: params.page || 1,\n        pageSize: params.pageSize || 20,\n        totalPages: 0,\n        hasNext: false,\n        hasPrev: false,\n      };\n    }\n  }\n\n  /**\n   * 获取会话统计信息\n   */\n  async getSessionStats(agentId: string, dateRange?: { start: string; end: string }): Promise<{\n    totalSessions: number;\n    totalMessages: number;\n    averageMessagesPerSession: number;\n    topTags: Array<{ tag: string; count: number }>;\n    recentActivity: Array<{ date: string; sessions: number; messages: number }>;\n  }> {\n    const params: SessionListParams = {};\n    if (dateRange) {\n      params.startDate = dateRange.start;\n      params.endDate = dateRange.end;\n    }\n\n    const result = await this.listHistoriesEnhanced(agentId, {\n      ...params,\n      pageSize: 1000,\n    });\n\n    const sessions = result.data;\n    const totalSessions = sessions.length;\n    const totalMessages = sessions.reduce((sum, session) => sum + (session.messageCount || 0), 0);\n    const averageMessagesPerSession = totalSessions > 0 ? totalMessages / totalSessions : 0;\n\n    // 统计标签使用情况\n    const tagCounts = new Map<string, number>();\n    sessions.forEach(session => {\n      if (session.tags) {\n        session.tags.forEach(tag => {\n          tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);\n        });\n      }\n    });\n\n    const topTags = Array.from(tagCounts.entries())\n      .map(([tag, count]) => ({ tag, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    // 按日期统计最近活动\n    const activityMap = new Map<string, { sessions: number; messages: number }>();\n    sessions.forEach(session => {\n      const date = (session.updatedAt || '').split('T')[0] || '';\n      const current = activityMap.get(date) || { sessions: 0, messages: 0 };\n      current.sessions++;\n      current.messages += (session.messageCount || 0);\n      activityMap.set(date, current);\n    });\n\n    const recentActivity = Array.from(activityMap.entries())\n      .map(([date, data]) => ({ date, ...data }))\n      .sort((a, b) => b.date.localeCompare(a.date))\n      .slice(0, 30);\n\n    return {\n      totalSessions,\n      totalMessages,\n      averageMessagesPerSession: Math.round(averageMessagesPerSession * 100) / 100,\n      topTags,\n      recentActivity,\n    };\n  }\n}\n\nexport type { FastGPTChatHistorySummary };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/GeoService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/MonitoringService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CircuitBreakerMetrics' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RateLimitMetrics' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RequestMetrics' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1197,1200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1197,1200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1428,1431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1428,1431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2742,2745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2742,2745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2939,2942],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2939,2942],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":408,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":408,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9759,9762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9759,9762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":517,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":517,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12529,12532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12529,12532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":539,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":539,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13067,13070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13067,13070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":547,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":547,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13228,13231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13228,13231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":603,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":603,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14322,14325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14322,14325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":614,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":614,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14509,14512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14509,14512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":703,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":703,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16721,16724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16721,16724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":704,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":704,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16756,16759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16756,16759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":735,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":735,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17318,17321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17318,17321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":746,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":746,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17514,17517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17514,17517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'rateLimitHealth' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":758,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":758,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":792,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":792,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18874,18877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18874,18877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":853,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":853,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20137,20140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20137,20140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":854,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":854,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20164,20167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20164,20167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 监控和告警系统\n * 实时性能指标收集、异常检测和SLA指标计算\n */\n\nimport * as os from 'os';\nimport { CircuitBreakerMetrics } from './CircuitBreakerService';\nimport { RateLimitMetrics } from './RateLimitService';\nimport { RequestMetrics } from './RetryService';\nimport logger from '@/utils/logger';\n\nexport interface PerformanceMetrics {\n  timestamp: Date;\n  cpu: {\n    usage: number;\n    loadAverage: number[];\n  };\n  memory: {\n    used: number;\n    free: number;\n    total: number;\n    usagePercentage: number;\n  };\n  requests: {\n    total: number;\n    successful: number;\n    failed: number;\n    averageResponseTime: number;\n    requestsPerSecond: number;\n  };\n  errors: {\n    total: number;\n    rate: number;\n    topErrors: Array<{ error: string; count: number; lastOccurred: Date }>;\n  };\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  description: string;\n  enabled: boolean;\n  threshold: number;\n  operator: '>' | '<' | '=' | '>=' | '<=';\n  metric: string;\n  duration: number; // 持续时间（秒）\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  channels: AlertChannel[];\n  cooldown: number; // 冷却时间（秒）\n}\n\nexport interface AlertChannel {\n  type: 'console' | 'webhook' | 'email' | 'slack';\n  config: any;\n  enabled: boolean;\n}\n\nexport interface Alert {\n  id: string;\n  ruleId: string;\n  ruleName: string;\n  message: string;\n  severity: AlertRule['severity'];\n  timestamp: Date;\n  resolved: boolean;\n  resolvedAt?: Date;\n  metrics: any;\n}\n\nexport interface SLAMetrics {\n  availability: number;        // 可用性 (0-100)\n  responseTime: {\n    p50: number;\n    p95: number;\n    p99: number;\n    average: number;\n  };\n  errorRate: number;          // 错误率 (0-100)\n  throughput: number;         // 吞吐量 (请求/秒)\n  uptime: number;             // 运行时间百分比\n  lastUpdated: Date;\n}\n\nexport interface SystemHealth {\n  status: 'healthy' | 'warning' | 'critical' | 'down';\n  score: number;              // 健康分数 (0-100)\n  components: {\n    api: boolean;\n    database: boolean;\n    circuitBreakers: boolean;\n    rateLimiters: boolean;\n    externalServices: boolean;\n  };\n  alerts: number;\n  lastCheck: Date;\n}\n\n/**\n * 性能监控器\n */\nexport class PerformanceMonitor {\n  private metrics: PerformanceMetrics[] = [];\n  private responseTimes: number[] = [];\n  private errorCounts: Map<string, number> = new Map();\n  private requestCounts = { total: 0, successful: 0, failed: 0 };\n  private lastMetricsTime = Date.now();\n  private maxMetricsHistory = 1000;\n  private metricsInterval?: NodeJS.Timeout;\n\n  constructor() {\n    this.start();\n  }\n\n  /**\n   * 启动性能监控\n   */\n  start(): void {\n    if (this.metricsInterval) {\n      logger.warn('性能监控器已在运行');\n      return;\n    }\n\n    // 每分钟收集一次指标\n    this.metricsInterval = setInterval(() => {\n      this.collectMetrics();\n    }, 60000) as any;\n\n    logger.info('性能监控器启动');\n  }\n\n  /**\n   * 停止性能监控\n   */\n  stop(): void {\n    if (this.metricsInterval) {\n      clearInterval(this.metricsInterval);\n      this.metricsInterval = undefined as any;\n      logger.info('性能监控器已停止');\n    }\n  }\n\n  /**\n   * 收集系统指标\n   */\n  private collectMetrics(): void {\n    const now = Date.now();\n    const memUsage = process.memoryUsage();\n    const cpuUsage = process.cpuUsage();\n\n    const metrics: PerformanceMetrics = {\n      timestamp: new Date(),\n      cpu: {\n        usage: (cpuUsage.user + cpuUsage.system) / 1000000, // 转换为秒\n        loadAverage: os.loadavg(),\n      },\n      memory: {\n        used: memUsage.heapUsed,\n        free: memUsage.heapTotal - memUsage.heapUsed,\n        total: memUsage.heapTotal,\n        usagePercentage: (memUsage.heapUsed / memUsage.heapTotal) * 100,\n      },\n      requests: {\n        total: this.requestCounts.total,\n        successful: this.requestCounts.successful,\n        failed: this.requestCounts.failed,\n        averageResponseTime: this.calculateAverageResponseTime(),\n        requestsPerSecond: this.calculateRequestsPerSecond(now),\n      },\n      errors: {\n        total: Array.from(this.errorCounts.values()).reduce((sum, count) => sum + count, 0),\n        rate: this.calculateErrorRate(),\n        topErrors: this.getTopErrors(),\n      },\n    };\n\n    this.metrics.push(metrics);\n    this.responseTimes = []; // 重置响应时间\n    this.requestCounts = { total: 0, successful: 0, failed: 0 };\n    this.lastMetricsTime = now;\n\n    // 限制历史记录数量\n    if (this.metrics.length > this.maxMetricsHistory) {\n      this.metrics.shift();\n    }\n\n    // 检查阈值告警\n    this.checkThresholdAlerts(metrics);\n  }\n\n  /**\n   * 记录请求\n   */\n  recordRequest(responseTime: number, success: boolean, error?: string): void {\n    this.responseTimes.push(responseTime);\n    this.requestCounts.total++;\n\n    if (success) {\n      this.requestCounts.successful++;\n    } else {\n      this.requestCounts.failed++;\n      if (error) {\n        const count = this.errorCounts.get(error) || 0;\n        this.errorCounts.set(error, count + 1);\n      }\n    }\n  }\n\n  /**\n   * 计算平均响应时间\n   */\n  private calculateAverageResponseTime(): number {\n    if (this.responseTimes.length === 0) {\n      return 0;\n    }\n    return this.responseTimes.reduce((sum, time) => sum + time, 0) / this.responseTimes.length;\n  }\n\n  /**\n   * 计算每秒请求数\n   */\n  private calculateRequestsPerSecond(now: number): number {\n    const timeDiff = (now - this.lastMetricsTime) / 1000;\n    return timeDiff > 0 ? this.requestCounts.total / timeDiff : 0;\n  }\n\n  /**\n   * 计算错误率\n   */\n  private calculateErrorRate(): number {\n    if (this.requestCounts.total === 0) {\n      return 0;\n    }\n    return (this.requestCounts.failed / this.requestCounts.total) * 100;\n  }\n\n  /**\n   * 获取Top错误\n   */\n  private getTopErrors(): Array<{ error: string; count: number; lastOccurred: Date }> {\n    const sortedErrors = Array.from(this.errorCounts.entries())\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10);\n\n    return sortedErrors.map(([error, count]) => ({\n      error,\n      count,\n      lastOccurred: new Date(),\n    }));\n  }\n\n  /**\n   * 检查阈值告警\n   */\n  private checkThresholdAlerts(metrics: PerformanceMetrics): void {\n    // CPU使用率告警\n    if (metrics.cpu.usage > 80) {\n      logger.warn('CPU使用率过高', { usage: `${metrics.cpu.usage.toFixed(2)}%` });\n    }\n\n    // 内存使用率告警\n    if (metrics.memory.usagePercentage > 85) {\n      logger.warn('内存使用率过高', { usage: `${metrics.memory.usagePercentage.toFixed(2)}%` });\n    }\n\n    // 错误率告警\n    if (metrics.errors.rate > 10) {\n      logger.warn('错误率过高', { rate: `${metrics.errors.rate.toFixed(2)}%` });\n    }\n\n    // 响应时间告警\n    if (metrics.requests.averageResponseTime > 5000) {\n      logger.warn('平均响应时间过长', { responseTime: `${metrics.requests.averageResponseTime}ms` });\n    }\n  }\n\n  /**\n   * 获取最新指标\n   */\n  getLatestMetrics(): PerformanceMetrics | null {\n    return this.metrics[this.metrics.length - 1] || null;\n  }\n\n  /**\n   * 获取指标历史\n   */\n  getMetricsHistory(minutes?: number): PerformanceMetrics[] {\n    if (!minutes) {\n      return this.metrics;\n    }\n\n    const cutoffTime = new Date(Date.now() - minutes * 60 * 1000);\n    return this.metrics.filter(metric => metric.timestamp >= cutoffTime);\n  }\n}\n\n/**\n * 告警管理器\n */\nexport class AlertManager {\n  private alerts: Map<string, Alert> = new Map();\n  private rules: Map<string, AlertRule> = new Map();\n  private lastAlertTimes: Map<string, Date> = new Map();\n\n  constructor() {\n    this.initializeDefaultRules();\n    logger.info('告警管理器启动');\n  }\n\n  /**\n   * 初始化默认告警规则\n   */\n  private initializeDefaultRules(): void {\n    const defaultRules: AlertRule[] = [\n      {\n        id: 'high_cpu_usage',\n        name: 'CPU使用率过高',\n        description: 'CPU使用率超过80%',\n        enabled: true,\n        threshold: 80,\n        operator: '>',\n        metric: 'cpu.usage',\n        duration: 300, // 5分钟\n        severity: 'high',\n        channels: [{ type: 'console', config: {}, enabled: true }],\n        cooldown: 900, // 15分钟冷却\n      },\n      {\n        id: 'high_memory_usage',\n        name: '内存使用率过高',\n        description: '内存使用率超过85%',\n        enabled: true,\n        threshold: 85,\n        operator: '>',\n        metric: 'memory.usagePercentage',\n        duration: 300,\n        severity: 'high',\n        channels: [{ type: 'console', config: {}, enabled: true }],\n        cooldown: 900,\n      },\n      {\n        id: 'high_error_rate',\n        name: '错误率过高',\n        description: '错误率超过10%',\n        enabled: true,\n        threshold: 10,\n        operator: '>',\n        metric: 'errors.rate',\n        duration: 180, // 3分钟\n        severity: 'medium',\n        channels: [{ type: 'console', config: {}, enabled: true }],\n        cooldown: 600,\n      },\n      {\n        id: 'slow_response_time',\n        name: '响应时间过长',\n        description: '平均响应时间超过5秒',\n        enabled: true,\n        threshold: 5000,\n        operator: '>',\n        metric: 'requests.averageResponseTime',\n        duration: 300,\n        severity: 'medium',\n        channels: [{ type: 'console', config: {}, enabled: true }],\n        cooldown: 600,\n      },\n    ];\n\n    defaultRules.forEach(rule => this.addRule(rule));\n  }\n\n  /**\n   * 添加告警规则\n   */\n  addRule(rule: AlertRule): void {\n    this.rules.set(rule.id, rule);\n    logger.info('添加告警规则', { ruleName: rule.name });\n  }\n\n  /**\n   * 检查告警条件\n   */\n  checkAlerts(metrics: PerformanceMetrics): void {\n    this.rules.forEach(rule => {\n      if (!rule.enabled) {\n        return;\n      }\n\n      const metricValue = this.getMetricValue(metrics, rule.metric);\n      if (metricValue === undefined) {\n        return;\n      }\n\n      const triggered = this.evaluateCondition(metricValue, rule.threshold, rule.operator);\n\n      if (triggered) {\n        this.handleAlertTriggered(rule, metricValue);\n      } else {\n        this.handleAlertResolved(rule);\n      }\n    });\n  }\n\n  /**\n   * 获取指标值\n   */\n  private getMetricValue(metrics: PerformanceMetrics, metricPath: string): number | undefined {\n    const paths = metricPath.split('.');\n    let value: any = metrics;\n\n    for (const path of paths) {\n      value = value?.[path];\n    }\n\n    return typeof value === 'number' ? value : undefined;\n  }\n\n  /**\n   * 评估条件\n   */\n  private evaluateCondition(value: number, threshold: number, operator: string): boolean {\n    switch (operator) {\n      case '>': return value > threshold;\n      case '<': return value < threshold;\n      case '=': return value === threshold;\n      case '>=': return value >= threshold;\n      case '<=': return value <= threshold;\n      default: return false;\n    }\n  }\n\n  /**\n   * 处理告警触发\n   */\n  private handleAlertTriggered(rule: AlertRule, metricValue: number): void {\n    const now = new Date();\n    const lastAlertTime = this.lastAlertTimes.get(rule.id);\n\n    // 检查冷却时间\n    if (lastAlertTime && (now.getTime() - lastAlertTime.getTime()) < rule.cooldown * 1000) {\n      return;\n    }\n\n    const alertId = `${rule.id}_${now.getTime()}`;\n    const alert: Alert = {\n      id: alertId,\n      ruleId: rule.id,\n      ruleName: rule.name,\n      message: `${rule.description}: 当前值 ${metricValue}, 阈值 ${rule.threshold}`,\n      severity: rule.severity,\n      timestamp: now,\n      resolved: false,\n      metrics: { metricValue, threshold: rule.threshold },\n    };\n\n    this.alerts.set(alertId, alert);\n    this.lastAlertTimes.set(rule.id, now);\n\n    // 发送告警通知\n    this.sendAlert(alert, rule);\n\n    logger.warn('告警触发', { ruleName: rule.name,\n      message: alert.message,\n      severity: rule.severity,\n      metricValue,\n      threshold: rule.threshold,\n    });\n  }\n\n  /**\n   * 处理告警解决\n   */\n  private handleAlertResolved(rule: AlertRule): void {\n    // 查找未解决的告警\n    const unresolvedAlerts = Array.from(this.alerts.values())\n      .filter(alert => alert.ruleId === rule.id && !alert.resolved);\n\n    unresolvedAlerts.forEach(alert => {\n      alert.resolved = true;\n      alert.resolvedAt = new Date();\n\n      logger.info('告警已解决', { ruleName: rule.name,\n        alertId: alert.id,\n        duration: alert.resolvedAt.getTime() - alert.timestamp.getTime(),\n      });\n    });\n  }\n\n  /**\n   * 发送告警通知\n   */\n  private sendAlert(alert: Alert, rule: AlertRule): void {\n    rule.channels.forEach(channel => {\n      if (!channel.enabled) {\n        return;\n      }\n\n      switch (channel.type) {\n        case 'console':\n          logger.error(`🚨 ${alert.ruleName} [${alert.severity.toUpperCase()}]`, { message: alert.message });\n          break;\n        case 'webhook':\n          this.sendWebhookAlert(channel.config, alert);\n          break;\n        case 'email':\n          this.sendEmailAlert(channel.config, alert);\n          break;\n        case 'slack':\n          this.sendSlackAlert(channel.config, alert);\n          break;\n      }\n    });\n  }\n\n  /**\n   * 发送Webhook告警\n   */\n  private async sendWebhookAlert(config: any, alert: Alert): Promise<void> {\n    try {\n      const response = await fetch(config.url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          alert,\n          timestamp: new Date().toISOString(),\n        }),\n      });\n\n      if (!response.ok) {\n        logger.error('Webhook告警发送失败', { status: response.statusText });\n      }\n    } catch (error) {\n      logger.error('Webhook告警发送异常', { error });\n    }\n  }\n\n  /**\n   * 发送邮件告警\n   */\n  private sendEmailAlert(config: any, alert: Alert): void {\n    // 这里应该实现邮件发送逻辑\n    logger.info('邮件告警功能待实现', { alert, config });\n  }\n\n  /**\n   * 发送Slack告警\n   */\n  private sendSlackAlert(config: any, alert: Alert): void {\n    // 这里应该实现Slack通知逻辑\n    logger.info('Slack告警功能待实现', { alert, config });\n  }\n\n  /**\n   * 获取活跃告警\n   */\n  getActiveAlerts(): Alert[] {\n    return Array.from(this.alerts.values()).filter(alert => !alert.resolved);\n  }\n\n  /**\n   * 获取所有告警\n   */\n  getAllAlerts(): Alert[] {\n    return Array.from(this.alerts.values());\n  }\n}\n\n/**\n * SLA监控器\n */\nexport class SLAMonitor {\n  private slaMetrics: SLAMetrics;\n  private uptimeStartTime = Date.now();\n  private totalRequests = 0;\n  private successfulRequests = 0;\n  private responseTimes: number[] = [];\n  private slaInterval?: NodeJS.Timeout;\n\n  constructor() {\n    this.slaMetrics = {\n      availability: 100,\n      responseTime: { p50: 0, p95: 0, p99: 0, average: 0 },\n      errorRate: 0,\n      throughput: 0,\n      uptime: 100,\n      lastUpdated: new Date(),\n    };\n\n    this.start();\n  }\n\n  /**\n   * 启动SLA监控\n   */\n  start(): void {\n    if (this.slaInterval) {\n      logger.warn('SLA监控器已在运行');\n      return;\n    }\n\n    // 每分钟更新SLA指标\n    this.slaInterval = setInterval(() => {\n      this.updateSLAMetrics();\n    }, 60000) as any;\n\n    logger.info('SLA监控器启动');\n  }\n\n  /**\n   * 停止SLA监控\n   */\n  stop(): void {\n    if (this.slaInterval) {\n      clearInterval(this.slaInterval);\n      this.slaInterval = undefined as any;\n      logger.info('SLA监控器已停止');\n    }\n  }\n\n  /**\n   * 记录请求\n   */\n  recordRequest(responseTime: number, success: boolean): void {\n    this.totalRequests++;\n    this.responseTimes.push(responseTime);\n\n    if (success) {\n      this.successfulRequests++;\n    }\n\n    // 限制响应时间历史\n    if (this.responseTimes.length > 10000) {\n      this.responseTimes = this.responseTimes.slice(-5000);\n    }\n  }\n\n  /**\n   * 更新SLA指标\n   */\n  private updateSLAMetrics(): void {\n    const now = Date.now();\n    const uptimePercentage = ((now - this.uptimeStartTime) / now) * 100;\n\n    // 计算可用性\n    const availability = this.totalRequests > 0 ? (this.successfulRequests / this.totalRequests) * 100 : 100;\n\n    // 计算错误率\n    const errorRate = this.totalRequests > 0 ? ((this.totalRequests - this.successfulRequests) / this.totalRequests) * 100 : 0;\n\n    // 计算响应时间指标\n    const sortedTimes = [...this.responseTimes].sort((a, b) => a - b);\n    const responseTime = {\n      p50: this.getPercentile(sortedTimes, 50),\n      p95: this.getPercentile(sortedTimes, 95),\n      p99: this.getPercentile(sortedTimes, 99),\n      average: this.responseTimes.length > 0\n        ? this.responseTimes.reduce((sum, time) => sum + time, 0) / this.responseTimes.length\n        : 0,\n    };\n\n    // 计算吞吐量（每分钟请求数）\n    const throughput = this.totalRequests / ((now - this.uptimeStartTime) / 60000);\n\n    this.slaMetrics = {\n      availability,\n      responseTime,\n      errorRate,\n      throughput,\n      uptime: uptimePercentage,\n      lastUpdated: new Date(),\n    };\n  }\n\n  /**\n   * 计算百分位数\n   */\n  private getPercentile(sortedArray: number[], percentile: number): number {\n    if (sortedArray.length === 0) {\n      return 0;\n    }\n    const index = Math.ceil((percentile / 100) * sortedArray.length) - 1;\n    const value = sortedArray[Math.max(0, index)];\n    return value ?? 0;\n  }\n\n  /**\n   * 获取SLA指标\n   */\n  getSLAMetrics(): SLAMetrics {\n    return { ...this.slaMetrics };\n  }\n}\n\n/**\n * 系统健康检查器\n */\nexport class SystemHealthChecker {\n  private healthStatus: SystemHealth;\n  private healthInterval?: NodeJS.Timeout;\n\n  constructor(\n    private performanceMonitor: PerformanceMonitor,\n    private alertManager: AlertManager,\n    private circuitBreakerManager: any,\n    private rateLimitService: any,\n  ) {\n    this.healthStatus = {\n      status: 'healthy',\n      score: 100,\n      components: {\n        api: true,\n        database: true,\n        circuitBreakers: true,\n        rateLimiters: true,\n        externalServices: true,\n      },\n      alerts: 0,\n      lastCheck: new Date(),\n    };\n\n    this.start();\n  }\n\n  /**\n   * 启动健康检查\n   */\n  start(): void {\n    if (this.healthInterval) {\n      logger.warn('系统健康检查器已在运行');\n      return;\n    }\n\n    // 每分钟检查一次健康状态\n    this.healthInterval = setInterval(() => {\n      this.checkSystemHealth();\n    }, 60000) as any;\n\n    logger.info('系统健康检查器启动');\n  }\n\n  /**\n   * 停止健康检查\n   */\n  stop(): void {\n    if (this.healthInterval) {\n      clearInterval(this.healthInterval);\n      this.healthInterval = undefined as any;\n      logger.info('系统健康检查器已停止');\n    }\n  }\n\n  /**\n   * 检查系统健康状态\n   */\n  private checkSystemHealth(): void {\n    const metrics = this.performanceMonitor.getLatestMetrics();\n    const activeAlerts = this.alertManager.getActiveAlerts();\n    const circuitBreakerHealth = this.circuitBreakerManager.getHealthStatus();\n    const rateLimitHealth = this.rateLimitService.getAllMetrics();\n\n    let score = 100;\n    let status: SystemHealth['status'] = 'healthy';\n    const components = { ...this.healthStatus.components };\n\n    // 检查CPU使用率\n    if (metrics?.cpu.usage && metrics.cpu.usage > 90) {\n      score -= 20;\n      status = 'critical';\n    } else if (metrics?.cpu.usage && metrics.cpu.usage > 80) {\n      score -= 10;\n      status = 'warning';\n    }\n\n    // 检查内存使用率\n    if (metrics?.memory.usagePercentage && metrics.memory.usagePercentage > 95) {\n      score -= 20;\n      status = 'critical';\n    } else if (metrics?.memory.usagePercentage && metrics.memory.usagePercentage > 85) {\n      score -= 10;\n      status = 'warning';\n    }\n\n    // 检查错误率\n    if (metrics?.errors.rate && metrics.errors.rate > 20) {\n      score -= 25;\n      status = 'critical';\n    } else if (metrics?.errors.rate && metrics.errors.rate > 10) {\n      score -= 15;\n      status = 'warning';\n    }\n\n    // 检查熔断器状态\n    const unhealthyCircuitBreakers = circuitBreakerHealth.filter((cb: any) => !cb.healthy);\n    if (unhealthyCircuitBreakers.length > 0) {\n      score -= 15 * unhealthyCircuitBreakers.length;\n      components.circuitBreakers = false;\n      status = 'critical';\n    }\n\n    // 检查告警数量\n    if (activeAlerts.length > 10) {\n      score -= 20;\n      status = 'critical';\n    } else if (activeAlerts.length > 5) {\n      score -= 10;\n      status = 'warning';\n    }\n\n    // 确保分数在合理范围内\n    score = Math.max(0, Math.min(100, score));\n\n    // 确定最终状态\n    if (score < 50) {\n      status = 'critical';\n    } else if (score < 80) {\n      status = 'warning';\n    }\n\n    this.healthStatus = {\n      status,\n      score,\n      components,\n      alerts: activeAlerts.length,\n      lastCheck: new Date(),\n    };\n\n    if (status !== 'healthy') {\n      logger.warn('系统健康状态', { status,\n        score,\n        components,\n        activeAlerts: activeAlerts.length,\n      });\n    }\n  }\n\n  /**\n   * 获取健康状态\n   */\n  getHealthStatus(): SystemHealth {\n    return { ...this.healthStatus };\n  }\n}\n\n/**\n * 监控服务主类\n */\nexport class MonitoringService {\n  private performanceMonitor: PerformanceMonitor;\n  private alertManager: AlertManager;\n  private slaMonitor: SLAMonitor;\n  private systemHealthChecker: SystemHealthChecker;\n\n  constructor(\n    circuitBreakerManager: any,\n    rateLimitService: any,\n  ) {\n    this.performanceMonitor = new PerformanceMonitor();\n    this.alertManager = new AlertManager();\n    this.slaMonitor = new SLAMonitor();\n    this.systemHealthChecker = new SystemHealthChecker(\n      this.performanceMonitor,\n      this.alertManager,\n      circuitBreakerManager,\n      rateLimitService,\n    );\n\n    logger.info('监控服务启动完成');\n  }\n\n  /**\n   * 记录请求指标\n   */\n  recordRequest(responseTime: number, success: boolean, error?: string): void {\n    this.performanceMonitor.recordRequest(responseTime, success, error);\n    this.slaMonitor.recordRequest(responseTime, success);\n  }\n\n  /**\n   * 获取性能指标\n   */\n  getPerformanceMetrics(): PerformanceMetrics | null {\n    return this.performanceMonitor.getLatestMetrics();\n  }\n\n  /**\n   * 获取SLA指标\n   */\n  getSLAMetrics(): SLAMetrics {\n    return this.slaMonitor.getSLAMetrics();\n  }\n\n  /**\n   * 获取系统健康状态\n   */\n  getSystemHealth(): SystemHealth {\n    return this.systemHealthChecker.getHealthStatus();\n  }\n\n  /**\n   * 获取活跃告警\n   */\n  getActiveAlerts(): Alert[] {\n    return this.alertManager.getActiveAlerts();\n  }\n\n  /**\n   * 添加自定义告警规则\n   */\n  addAlertRule(rule: AlertRule): void {\n    this.alertManager.addRule(rule);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/ObservabilityDispatcher.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[478,481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[478,481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport type { AppConfig, LoggingExporterConfig } from '@/utils/appConfig';\nimport { loadAppConfig, resolveLoggingExportersFromEnv } from '@/utils/appConfig';\nimport logger from '@/utils/logger';\n\nexport interface ObservabilityEvent {\n  timestamp: string;\n  channel: 'normal' | 'stream';\n  level: 'INFO' | 'WARN' | 'ERROR';\n  agentId: string;\n  provider?: string;\n  endpoint?: string;\n  chatId?: string;\n  eventType?: string;\n  payload: Record<string, any> | null;\n}\n\ninterface RuntimeExporter extends LoggingExporterConfig {\n  batchSize: number;\n  flushIntervalMs: number;\n}\n\nconst DEFAULT_BATCH_SIZE = 20;\nconst DEFAULT_FLUSH_INTERVAL = 2000;\n\nexport class ObservabilityDispatcher {\n  private static instance: ObservabilityDispatcher | null = null;\n\n  static getInstance(): ObservabilityDispatcher {\n    if (!ObservabilityDispatcher.instance) {\n      ObservabilityDispatcher.instance = new ObservabilityDispatcher(loadAppConfig());\n    }\n    return ObservabilityDispatcher.instance;\n  }\n\n  private readonly exporters: RuntimeExporter[] = [];\n  private readonly queue: ObservabilityEvent[] = [];\n  private flushing = false;\n  private flushTimer: ReturnType<typeof setTimeout> | null = null;\n  private readonly minBatchSize: number;\n\n  private constructor(config: AppConfig) {\n    const configExporters = (config.logging?.exporters ?? []).concat(resolveLoggingExportersFromEnv());\n    this.exporters = configExporters\n      .filter((exp) => exp && exp.enabled !== false && exp.type)\n      .map((exp) => ({\n        ...exp,\n        batchSize: Math.max(1, exp.batchSize ?? DEFAULT_BATCH_SIZE),\n        flushIntervalMs: Math.max(250, exp.flushIntervalMs ?? DEFAULT_FLUSH_INTERVAL),\n      }));\n    this.minBatchSize = this.exporters.length > 0\n      ? Math.min(...this.exporters.map((exp) => exp.batchSize))\n      : DEFAULT_BATCH_SIZE;\n  }\n\n  isEnabled(): boolean {\n    return this.exporters.length > 0;\n  }\n\n  enqueue(event: ObservabilityEvent): void {\n    if (!this.isEnabled()) {\n      return;\n    }\n    this.queue.push(event);\n    if (this.queue.length >= this.minBatchSize) {\n      void this.flush();\n      return;\n    }\n    this.scheduleFlush();\n  }\n\n  private scheduleFlush(): void {\n    if (this.flushTimer || !this.isEnabled()) {\n      return;\n    }\n    const interval = Math.min(...this.exporters.map((exp) => exp.flushIntervalMs));\n    this.flushTimer = setTimeout(() => {\n      this.flushTimer = null;\n      void this.flush();\n    }, interval);\n  }\n\n  private async flush(): Promise<void> {\n    if (this.flushing || !this.queue.length || !this.isEnabled()) {\n      return;\n    }\n    this.flushing = true;\n    const batch = this.queue.splice(0, this.queue.length);\n    await Promise.all(\n      this.exporters.map(async (exporter) => {\n        const chunks = chunk(batch, exporter.batchSize);\n        for (const slice of chunks) {\n          try {\n            await this.sendToExporter(exporter, slice);\n          } catch (error) {\n            logger.warn('[ObservabilityDispatcher] Export failed', { exporterType: exporter.type, error });\n          }\n        }\n      }),\n    );\n    this.flushing = false;\n    if (this.queue.length) {\n      this.scheduleFlush();\n    }\n  }\n\n  private async sendToExporter(exporter: RuntimeExporter, events: ObservabilityEvent[]): Promise<void> {\n    if (!events.length) {\n      return;\n    }\n    if (!exporter.endpoint) {\n      return;\n    }\n\n    switch (exporter.type) {\n      case 'elasticsearch':\n        await this.sendToElastic(exporter, events);\n        break;\n      case 'clickhouse':\n        await this.sendToClickHouse(exporter, events);\n        break;\n      default:\n        await this.sendToHttp(exporter, events);\n    }\n  }\n\n  private async sendToHttp(exporter: RuntimeExporter, events: ObservabilityEvent[]): Promise<void> {\n    const config: Parameters<typeof axios.post>[2] | undefined = exporter.headers\n      ? { headers: exporter.headers }\n      : undefined;\n    await axios.post(exporter.endpoint!, { events }, config);\n  }\n\n  private async sendToElastic(exporter: RuntimeExporter, events: ObservabilityEvent[]): Promise<void> {\n    const index = exporter.index || 'fastgpt-events';\n    const bulkBody = events\n      .map((event) => {\n        const action = { index: { _index: index } };\n        return `${JSON.stringify(action)}\\n${JSON.stringify(event)}`;\n      })\n      .join('\\n') + '\\n';\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/x-ndjson',\n      ...(exporter.headers ?? {}),\n    };\n    if (exporter.apiKey) {\n      headers.Authorization = `ApiKey ${exporter.apiKey}`;\n    }\n    const config: Parameters<typeof axios.post>[2] = { headers };\n    if (exporter.username || exporter.password) {\n      config.auth = { username: exporter.username ?? '', password: exporter.password ?? '' };\n    }\n\n    await axios.post(`${exporter.endpoint!.replace(/\\/+$/, '')}/_bulk`, bulkBody, config);\n  }\n\n  private async sendToClickHouse(exporter: RuntimeExporter, events: ObservabilityEvent[]): Promise<void> {\n    const table = exporter.table || 'fastgpt_events';\n    const payload = events.map((event) => JSON.stringify(event)).join('\\n');\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      ...(exporter.headers ?? {}),\n    };\n    const config: Parameters<typeof axios.post>[2] = { headers };\n    if (exporter.username || exporter.password) {\n      config.auth = { username: exporter.username ?? '', password: exporter.password ?? '' };\n    }\n    await axios.post(\n      `${exporter.endpoint}?query=${encodeURIComponent(`INSERT INTO ${table} FORMAT JSONEachRow`)}`,\n      payload,\n      config,\n    );\n  }\n}\n\nfunction chunk<T>(items: T[], size: number): T[][] {\n  const result: T[][] = [];\n  for (let i = 0; i < items.length; i += size) {\n    result.push(items.slice(i, i + size));\n  }\n  return result;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/PasswordService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/ProductPreviewService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[460,463],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[460,463],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2678,2681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2678,2681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4390,4393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4390,4393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4429,4432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4429,4432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4827,4830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4827,4830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4865,4868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4865,4868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport { ProductPreviewRequest, ProductPreviewResult } from '@/types';\n\n// 定义豆包 / OpenAI 风格图片生成接口可能返回的数据结构（兼容多种字段命名）\ninterface ProductPreviewApiResponse {\n  requestId?: string;\n  RequestId?: string;\n  request_id?: string;\n  traceId?: string;\n  TraceId?: string;\n  status?: string;\n  Status?: string;\n  // OpenAI / Doubao 风格\n  data?: Array<{\n    url?: string;\n    b64_json?: string;\n  }>;\n  created?: number;\n  usage?: Record<string, any>;\n  // 兼容其他服务字段\n  result?: {\n    url?: string;\n    imageUrl?: string;\n    imageBase64?: string;\n    image_base64?: string;\n  };\n  output?: {\n    image_url?: string;\n    results?: Array<{\n      url?: string;\n      data?: string;\n    }>;\n  };\n  imageUrl?: string;\n  imageBase64?: string;\n  image_base64?: string;\n}\n\nconst normalizeDataUrl = (image: string): string => {\n  if (!image) {\n    return image;\n  }\n  if (image.startsWith('data:')) {\n    return image;\n  }\n  return `data:image/png;base64,${image}`;\n};\n\nexport class ProductPreviewService {\n  private endpoint: string;\n  private apiKey: string | undefined;\n  private model: string | undefined;\n  private size: string | undefined;\n  private stream: boolean;\n\n  constructor() {\n    // 默认使用 Ark Doubao v3 端点，可通过 DOUBAO_IMAGE_API_URL 覆盖\n    this.endpoint = process.env.DOUBAO_IMAGE_API_URL || 'https://ark.cn-beijing.volces.com/api/v3/images/generations';\n    this.apiKey = process.env.DOUBAO_API_KEY;\n    this.model = process.env.DOUBAO_IMAGE_MODEL || 'doubao-seedream-4-0-250828';\n    this.size = process.env.DOUBAO_IMAGE_SIZE || '1024x1024';\n    this.stream = String(process.env.DOUBAO_IMAGE_STREAM || 'false').toLowerCase() === 'true';\n  }\n\n  /**\n   * 生成产品场景融合预览图（豆包 SeeDream）\n   *\n   * 该方法调用豆包图片生成接口，基于提供的产品图、场景图及目标框位进行融合，返回预览结果。\n   *\n   * 参数说明:\n   * - payload: ProductPreviewRequest 输入请求，包含产品图、场景图、目标框位、个性化提示等信息\n   *\n   * 返回值:\n   * - Promise<ProductPreviewResult>: 返回包含请求标识、跟踪ID、状态、原始返回以及预览图URL或Base64的结构化结果\n   *\n   * 可能抛出的异常:\n   * - Error: 当未配置接口地址或网络/鉴权错误导致请求失败时抛出\n   */\n  async generatePreview(payload: ProductPreviewRequest): Promise<ProductPreviewResult> {\n    if (!this.endpoint) {\n      throw new Error('未配置豆包图片生成接口地址（DOUBAO_IMAGE_API_URL）');\n    }\n\n    const promptSegments = [payload.productQuery];\n    if (payload.personalization) {\n      promptSegments.push(payload.personalization);\n    }\n    // 将目标框位也加入提示，便于在不支持 target_box 的端点上获得更接近的结果\n    const box = payload.boundingBox;\n    const prompt = `${promptSegments.join('，')}。将产品融合到参考场景图的指定框位（x=${box.x.toFixed(3)}, y=${box.y.toFixed(3)}, w=${box.width.toFixed(3)}, h=${box.height.toFixed(3)}），生成高清预览图。`;\n\n    // Ark Doubao / OpenAI 风格 images.generations 请求体\n    const requestBody: Record<string, any> = {\n      model: this.model,\n      prompt,\n      size: this.size,\n      stream: this.stream,\n      response_format: 'url',\n      watermark: true,\n    };\n\n    // 豆包 Ark v3 支持 image 数组与顺序生成选项\n    const images: string[] = [];\n    if (payload.sceneImage) {\n      images.push(normalizeDataUrl(payload.sceneImage));\n    }\n    if (payload.productImage) {\n      images.push(normalizeDataUrl(payload.productImage));\n    }\n    if (images.length > 0) {\n      requestBody.image = images;\n      requestBody.sequential_image_generation = 'auto';\n      requestBody.sequential_image_generation_options = { max_images: 3 };\n    }\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n\n    if (this.apiKey) {\n      headers.Authorization = `Bearer ${this.apiKey}`;\n    }\n\n    // 明确声明响应体类型，避免在strict模式下被推断为{}\n    const { data } = await axios.post<ProductPreviewApiResponse>(this.endpoint, requestBody, {\n      headers,\n      timeout: 60000,\n    });\n\n    const result: ProductPreviewResult = {};\n\n    // 安全地添加可选属性\n    const requestId = data?.requestId || data?.RequestId || data?.request_id;\n    if (requestId !== undefined) {\n      result.requestId = requestId;\n    }\n\n    const traceId = data?.traceId || data?.TraceId;\n    if (traceId !== undefined) {\n      result.traceId = traceId;\n    }\n\n    const status = data?.status || data?.Status;\n    if (status !== undefined) {\n      result.status = status;\n    }\n\n    result.raw = data as unknown as Record<string, unknown>;\n\n    const urlCandidate =\n      // Doubao/OpenAI 风格\n      data?.data?.[0]?.url ||\n      // 兼容其他服务\n      data?.result?.url ||\n      data?.result?.imageUrl ||\n      data?.output?.results?.[0]?.url ||\n      (data as any)?.data?.imageUrl ||\n      (data as any)?.imageUrl ||\n      data?.output?.image_url;\n\n    if (typeof urlCandidate === 'string') {\n      result.previewImage = urlCandidate;\n    } else {\n      const base64Candidate =\n        // Doubao/OpenAI 风格\n        data?.data?.[0]?.b64_json ||\n        // 兼容其他服务\n        data?.result?.imageBase64 ||\n        data?.result?.image_base64 ||\n        data?.output?.results?.[0]?.data ||\n        (data as any)?.imageBase64 ||\n        (data as any)?.image_base64;\n      if (typeof base64Candidate === 'string' && base64Candidate.length > 50) {\n        result.previewImage = normalizeDataUrl(base64Candidate);\n      }\n    }\n\n    if (result.previewImage && !result.imageUrl) {\n      result.imageUrl = result.previewImage;\n    }\n\n    return result;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/ProtectionService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CircuitState' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":67},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[962,965],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[962,965],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1190,1193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1190,1193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1208,1211],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1208,1211],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1222,1225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1222,1225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1241,1244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1241,1244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2269,2272],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2269,2272],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'header' is defined but never used. Allowed unused args must match /^_/u.","line":183,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":183,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'header' is defined but never used. Allowed unused args must match /^_/u.","line":184,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":184,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'types' is defined but never used. Allowed unused args must match /^_/u.","line":185,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":185,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'charsets' is defined but never used. Allowed unused args must match /^_/u.","line":186,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":186,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'encodings' is defined but never used. Allowed unused args must match /^_/u.","line":187,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":187,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'languages' is defined but never used. Allowed unused args must match /^_/u.","line":188,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":188,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'type' is defined but never used. Allowed unused args must match /^_/u.","line":189,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":189,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'name' is defined but never used. Allowed unused args must match /^_/u.","line":190,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":190,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'name' is defined but never used. Allowed unused args must match /^_/u.","line":191,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":191,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":203,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5717,5720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5717,5720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5772,5775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5772,5775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":206,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":206,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5804,5807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5804,5807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6000,6003],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6000,6003],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6030,6033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6030,6033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":237,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6605,6608],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6605,6608],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6730,6733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6730,6733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":252,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7127,7130],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7127,7130],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7408,7411],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7408,7411],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":286,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8041,8044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8041,8044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":287,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8091,8094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8091,8094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":407,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":407,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11019,11022],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11019,11022],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metric' is defined but never used. Allowed unused args must match /^_/u.","line":409,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":409,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":409,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11102,11105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11102,11105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":30,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 保护服务集成管理器\n * 统一管理熔断器、限流器、重试机制和监控\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { CircuitBreakerManager, CircuitBreakerConfig, CircuitState } from './CircuitBreakerService';\nimport { MultiDimensionRateLimiter, RateLimitConfig } from './RateLimitService';\nimport { RetryService, RetryConfig, FallbackConfig, RequestDeduplicationConfig } from './RetryService';\nimport { MonitoringService } from './MonitoringService';\nimport logger from '@/utils/logger';\n\nexport interface ProtectionConfig {\n  circuitBreaker: CircuitBreakerConfig;\n  rateLimit: RateLimitConfig;\n  retry: RetryConfig;\n  fallback: FallbackConfig;\n  deduplication: RequestDeduplicationConfig;\n  monitoring: {\n    enabled: boolean;\n    metricsInterval: number;\n    healthCheckInterval: number;\n    slaUpdateInterval: number;\n  };\n  alerts: {\n    consoleEnabled: boolean;\n    webhookEnabled: boolean;\n    webhookUrl?: string;\n    emailEnabled: boolean;\n    emailConfig?: any;\n  };\n}\n\nexport interface ProtectedRequestContext {\n  requestId: string;\n  agentId: string;\n  userId?: string;\n  ip: string;\n  userAgent?: string;\n  timestamp: Date;\n}\n\nexport interface ProtectionMetrics {\n  circuitBreaker: any;\n  rateLimit: any;\n  retry: any;\n  monitoring: any;\n  overall: {\n    totalRequests: number;\n    successfulRequests: number;\n    failedRequests: number;\n    averageResponseTime: number;\n    systemHealth: string;\n  };\n}\n\n/**\n * 保护服务主类\n */\nexport class ProtectionService {\n  public circuitBreakerManager: CircuitBreakerManager;\n  public multiDimensionRateLimiter: MultiDimensionRateLimiter;\n  private retryService: RetryService;\n  public monitoringService: MonitoringService;\n  private config: ProtectionConfig;\n\n  constructor(config?: Partial<ProtectionConfig>) {\n    this.config = this.mergeWithDefaultConfig(config);\n\n    // 初始化各组件\n    this.circuitBreakerManager = CircuitBreakerManager.getInstance();\n    this.multiDimensionRateLimiter = new MultiDimensionRateLimiter({\n      ip: {\n        windowMs: 60000, // 1分钟\n        maxRequests: parseInt(process.env.RATE_LIMIT_POINTS || '100'),\n        keyGenerator: (req: Request) => req.ip || 'unknown',\n      },\n      user: {\n        windowMs: 60000, // 1分钟\n        maxRequests: 50,\n        keyGenerator: (req: Request) => (req as any).user?.id || 'anonymous',\n      },\n      endpoint: {\n        windowMs: 60000, // 1分钟\n        maxRequests: 200,\n        keyGenerator: (req: Request) => `${req.method}:${req.path}`,\n      },\n    });\n\n    this.retryService = new RetryService(\n      this.config.retry,\n      this.config.fallback,\n      this.config.deduplication,\n    );\n\n    this.monitoringService = new MonitoringService(\n      this.circuitBreakerManager,\n      this.multiDimensionRateLimiter,\n    );\n\n    logger.info('保护服务初始化完成', {\n      circuitBreaker: this.config.circuitBreaker,\n      rateLimit: this.config.rateLimit,\n      retry: this.config.retry,\n      monitoring: this.config.monitoring.enabled,\n    });\n  }\n\n  /**\n   * 执行受保护的API请求\n   */\n  async executeProtectedRequest<T>(\n    context: ProtectedRequestContext,\n    operation: () => Promise<T>,\n  ): Promise<T> {\n    const startTime = Date.now();\n    let success = false;\n    let error: Error | undefined;\n\n    try {\n      // 1. 检查限流\n      const rateLimitResult = this.checkRateLimit(context);\n      if (!rateLimitResult.allowed) {\n        throw new Error(`请求被限流: ${rateLimitResult.reason}`);\n      }\n\n      // 2. 获取熔断器并执行操作\n      const circuitBreaker = this.circuitBreakerManager.getCircuitBreaker(\n        `agent_${context.agentId}`,\n        this.config.circuitBreaker,\n        {\n          onFailure: (err, metrics) => {\n            logger.warn('熔断器触发', {\n              agentId: context.agentId,\n              error: err.message,\n              state: metrics.state,\n              failureCount: metrics.failureCount,\n            });\n          },\n          onSuccess: (responseTime, metrics) => {\n            logger.debug('熔断器请求成功', {\n              agentId: context.agentId,\n              responseTime,\n              state: metrics.state,\n            });\n          },\n        },\n      );\n\n      // 3. 执行带重试的操作\n      const result = await this.retryService.executeWithRetryAndDeduplication(\n        `${context.agentId}_${context.requestId}`,\n        () => circuitBreaker.execute(operation),\n        `agent_${context.agentId}`,\n      );\n\n      success = true;\n      if (result.data === undefined) {\n        throw new Error('重试服务返回了undefined数据');\n      }\n      return result.data;\n\n    } catch (err) {\n      error = err as Error;\n      throw error;\n    } finally {\n      // 4. 记录监控指标\n      const responseTime = Date.now() - startTime;\n      this.monitoringService.recordRequest(responseTime, success, error?.message);\n    }\n  }\n\n  /**\n   * 检查限流\n   */\n  private checkRateLimit(context: ProtectedRequestContext): { allowed: boolean; reason?: string } {\n    // 模拟请求对象用于限流检查\n    const mockReq = {\n      ip: context.ip,\n      method: 'POST',\n      path: '/api/chat/completions',\n      user: context.userId ? { id: context.userId } : undefined,\n      get: (header: string) => '',\n      header: (header: string) => '',\n      accepts: (types: string[]) => false,\n      acceptsCharsets: (charsets: string[]) => false,\n      acceptsEncodings: (encodings: string[]) => false,\n      acceptsLanguages: (languages: string[]) => false,\n      is: (type: string) => false,\n      param: (name: string) => undefined,\n      query: (name: string) => undefined,\n      cookies: {},\n      signedCookies: {},\n      body: {},\n      files: {},\n      protocol: 'http',\n      secure: false,\n      xhr: false,\n      subdomains: [],\n      originalUrl: '/api/chat/completions',\n      baseUrl: '',\n      url: '/api/chat/completions',\n      app: undefined as any,\n      headers: {},\n      connection: undefined as any,\n      socket: undefined as any,\n      complete: true,\n      httpVersion: '1.1',\n      httpVersionMajor: 1,\n      httpVersionMinor: 1,\n      trailers: {},\n      rawTrailers: [],\n      upgrade: false,\n      res: undefined as any,\n      next: undefined as any,\n    } as unknown as Request;\n\n    const checkResult = this.multiDimensionRateLimiter.isAllowed(mockReq);\n\n    if (!checkResult.allowed) {\n      const failedResult = checkResult.results.find(r => !r.allowed);\n      return {\n        allowed: false,\n        reason: failedResult ? `维度限制触发: ${failedResult.remaining}/${failedResult.resetTime}` : '未知限流原因',\n      };\n    }\n\n    return { allowed: true };\n  }\n\n  /**\n   * 创建受保护的中间件\n   */\n  createProtectionMiddleware() {\n    return (req: Request, res: Response, next: NextFunction): void => {\n      // 添加保护服务到请求对象\n      (req as any).protectionService = this;\n\n      // 生成请求上下文\n      const userAgent = req.get('User-Agent');\n      const userId = (req as any).user?.id;\n      const context: ProtectedRequestContext = {\n        requestId: this.generateRequestId(),\n        agentId: req.body?.agentId || req.params?.agentId || 'unknown',\n        ip: req.ip || req.connection.remoteAddress || 'unknown',\n        timestamp: new Date(),\n        ...(userId && { userId }),\n        ...(userAgent && { userAgent }),\n      };\n\n      // 添加上下文到请求对象\n      (req as any).protectionContext = context;\n\n      next();\n    };\n  }\n\n  /**\n   * 创建受保护的聊天端点处理器\n   */\n  createProtectedChatHandler(chatHandler: (req: Request, res: Response) => Promise<void>) {\n    return async (req: Request, res: Response): Promise<void> => {\n      const context = (req as any).protectionContext as ProtectedRequestContext;\n\n      if (!context) {\n        res.status(500).json({\n          code: 'PROTECTION_CONTEXT_MISSING',\n          message: '保护上下文缺失',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      try {\n        await this.executeProtectedRequest(context, async () => {\n          return chatHandler(req, res);\n        });\n      } catch (error) {\n        logger.error('受保护请求失败', {\n          requestId: context.requestId,\n          agentId: context.agentId,\n          error: (error as Error).message,\n        });\n\n        // 如果是降级响应，返回成功状态\n        if ((error as any).fallbackUsed) {\n          res.json((error as any).data);\n          return;\n        }\n\n        // 返回错误响应\n        const statusCode = this.getErrorStatusCode(error as Error);\n        res.status(statusCode).json({\n          code: this.getErrorCode(error as Error),\n          message: (error as Error).message,\n          requestId: context.requestId,\n          timestamp: new Date().toISOString(),\n        });\n      }\n    };\n  }\n\n  /**\n   * 获取错误状态码\n   */\n  private getErrorStatusCode(error: Error): number {\n    const message = error.message.toLowerCase();\n\n    if (message.includes('熔断器')) {\n      return 503;\n    }\n    if (message.includes('限流')) {\n      return 429;\n    }\n    if (message.includes('超时')) {\n      return 408;\n    }\n    if (message.includes('网络')) {\n      return 502;\n    }\n    if (message.includes('不可用')) {\n      return 503;\n    }\n\n    return 500;\n  }\n\n  /**\n   * 获取错误代码\n   */\n  private getErrorCode(error: Error): string {\n    const message = error.message.toLowerCase();\n\n    if (message.includes('熔断器')) {\n      return 'CIRCUIT_BREAKER_OPEN';\n    }\n    if (message.includes('限流')) {\n      return 'RATE_LIMIT_EXCEEDED';\n    }\n    if (message.includes('超时')) {\n      return 'REQUEST_TIMEOUT';\n    }\n    if (message.includes('网络')) {\n      return 'NETWORK_ERROR';\n    }\n    if (message.includes('不可用')) {\n      return 'SERVICE_UNAVAILABLE';\n    }\n\n    return 'INTERNAL_ERROR';\n  }\n\n  /**\n   * 生成请求ID\n   */\n  private generateRequestId(): string {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * 获取保护指标\n   */\n  getProtectionMetrics(): ProtectionMetrics {\n    return {\n      circuitBreaker: this.circuitBreakerManager.getAllCircuitBreakers(),\n      rateLimit: this.multiDimensionRateLimiter.getAllMetrics(),\n      retry: this.retryService.getDeduplicationMetrics(),\n      monitoring: {\n        performance: this.monitoringService.getPerformanceMetrics(),\n        sla: this.monitoringService.getSLAMetrics(),\n        health: this.monitoringService.getSystemHealth(),\n        alerts: this.monitoringService.getActiveAlerts(),\n      },\n      overall: {\n        totalRequests: 0, // 从监控服务获取\n        successfulRequests: 0,\n        failedRequests: 0,\n        averageResponseTime: 0,\n        systemHealth: this.monitoringService.getSystemHealth().status,\n      },\n    };\n  }\n\n  /**\n   * 手动重置熔断器\n   */\n  resetCircuitBreaker(agentId: string): void {\n    const circuitBreaker = this.circuitBreakerManager.getCircuitBreaker(`agent_${agentId}`);\n    circuitBreaker?.reset();\n  }\n\n  /**\n   * 强制打开熔断器\n   */\n  forceOpenCircuitBreaker(agentId: string): void {\n    const circuitBreaker = this.circuitBreakerManager.getCircuitBreaker(`agent_${agentId}`);\n    circuitBreaker?.forceOpen();\n  }\n\n  /**\n   * 重置所有保护机制\n   */\n  resetAllProtections(): void {\n    this.circuitBreakerManager.resetAll();\n    const allMetrics = this.multiDimensionRateLimiter.getAllMetrics();\n    if (Array.isArray(allMetrics)) {\n      allMetrics.forEach((metrics: any) => {\n        if (Array.isArray(metrics)) {\n          metrics.forEach((metric: any) => {\n            // 重置限流器指标（如果提供方法）\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * 销毁保护服务\n   */\n  destroy(): void {\n    this.multiDimensionRateLimiter.destroy();\n    this.retryService.destroy();\n  }\n\n  /**\n   * 合并默认配置\n   */\n  private mergeWithDefaultConfig(config?: Partial<ProtectionConfig>): ProtectionConfig {\n    const defaultConfig: ProtectionConfig = {\n      circuitBreaker: {\n        failureThreshold: parseInt(process.env.CIRCUIT_BREAKER_FAILURE_THRESHOLD || '5'),\n        successThreshold: parseInt(process.env.CIRCUIT_BREAKER_SUCCESS_THRESHOLD || '3'),\n        timeout: parseInt(process.env.CIRCUIT_BREAKER_TIMEOUT || '10000'),\n        resetTimeout: parseInt(process.env.CIRCUIT_BREAKER_RESET_TIMEOUT || '30000'),\n        monitoringEnabled: true,\n      },\n      rateLimit: {\n        windowMs: 60000,\n        maxRequests: parseInt(process.env.RATE_LIMIT_POINTS || '100'),\n        enableCacheProtection: true,\n        enableBurstProtection: true,\n        burstLimit: 20,\n      },\n      retry: {\n        maxRetries: parseInt(process.env.RETRY_MAX_RETRIES || '3'),\n        baseDelay: parseInt(process.env.RETRY_BASE_DELAY || '1000'),\n        maxDelay: parseInt(process.env.RETRY_MAX_DELAY || '10000'),\n        backoffFactor: parseFloat(process.env.RETRY_BACKOFF_FACTOR || '2'),\n        enableJitter: process.env.RETRY_ENABLE_JITTER === 'true',\n        retryableErrors: ['ECONNRESET', 'ETIMEDOUT', 'ECONNREFUSED', 'NETWORK_ERROR'],\n        retryableStatusCodes: [408, 429, 500, 502, 503, 504],\n      },\n      fallback: {\n        enabled: process.env.FALLBACK_ENABLED === 'true',\n        fallbackResponse: {\n          error: '服务暂时不可用，请稍后重试',\n          fallback: true,\n          timestamp: new Date().toISOString(),\n        },\n        cacheFallbackResponse: true,\n        maxCacheSize: parseInt(process.env.FALLBACK_MAX_CACHE_SIZE || '100'),\n        cacheTTL: parseInt(process.env.FALLBACK_CACHE_TTL || '300000'),\n      },\n      deduplication: {\n        enabled: true,\n        deduplicationWindow: 30000,\n        maxConcurrentRequests: 100,\n      },\n      monitoring: {\n        enabled: process.env.MONITORING_ENABLED === 'true',\n        metricsInterval: parseInt(process.env.MONITORING_METRICS_INTERVAL || '60000'),\n        healthCheckInterval: parseInt(process.env.MONITORING_HEALTH_CHECK_INTERVAL || '60000'),\n        slaUpdateInterval: parseInt(process.env.MONITORING_SLA_UPDATE_INTERVAL || '60000'),\n      },\n      alerts: {\n        consoleEnabled: process.env.ALERT_CONSOLE_ENABLED === 'true',\n        webhookEnabled: process.env.ALERT_WEBHOOK_ENABLED === 'true',\n        ...(process.env.ALERT_WEBHOOK_URL && { webhookUrl: process.env.ALERT_WEBHOOK_URL }),\n        emailEnabled: process.env.ALERT_EMAIL_ENABLED === 'true',\n        emailConfig: {\n          smtpHost: process.env.ALERT_EMAIL_SMTP_HOST,\n          smtpPort: parseInt(process.env.ALERT_EMAIL_SMTP_PORT || '587'),\n          username: process.env.ALERT_EMAIL_USERNAME,\n          password: process.env.ALERT_EMAIL_PASSWORD,\n        },\n      },\n    };\n\n    return {\n      ...defaultConfig,\n      ...config,\n      // 深度合并嵌套对象\n      circuitBreaker: { ...defaultConfig.circuitBreaker, ...config?.circuitBreaker },\n      rateLimit: { ...defaultConfig.rateLimit, ...config?.rateLimit },\n      retry: { ...defaultConfig.retry, ...config?.retry },\n      fallback: { ...defaultConfig.fallback, ...config?.fallback },\n      deduplication: { ...defaultConfig.deduplication, ...config?.deduplication },\n      monitoring: { ...defaultConfig.monitoring, ...config?.monitoring },\n      alerts: { ...defaultConfig.alerts, ...config?.alerts },\n    };\n  }\n\n  // 公共访问方法\n  public getMonitoringService() {\n    return this.monitoringService;\n  }\n\n  public getPerformanceMetrics() {\n    return this.monitoringService.getPerformanceMetrics();\n  }\n\n  public getActiveAlerts() {\n    return this.monitoringService.getActiveAlerts();\n  }\n\n  public getSystemHealth() {\n    return this.monitoringService.getSystemHealth();\n  }\n\n  public getAllCircuitBreakers() {\n    return this.circuitBreakerManager.getAllCircuitBreakers();\n  }\n\n  public getAllRateLimitMetrics() {\n    return this.multiDimensionRateLimiter.getAllMetrics();\n  }\n}\n\n/**\n * 全局保护服务实例\n */\nlet globalProtectionService: ProtectionService;\n\n/**\n * 获取全局保护服务实例\n */\nexport function getProtectionService(): ProtectionService {\n  if (!globalProtectionService) {\n    globalProtectionService = new ProtectionService();\n  }\n  return globalProtectionService;\n}\n\n/**\n * 初始化保护服务\n */\nexport function initializeProtectionService(config?: Partial<ProtectionConfig>): ProtectionService {\n  globalProtectionService = new ProtectionService(config);\n  return globalProtectionService;\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/RateLimitService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":268,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":268,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6579,6582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6579,6582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'key' is defined but never used. Allowed unused args must match /^_/u.","line":342,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":342,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 增强版限流服务\n * 实现滑动窗口限流、多维度限流策略和缓存穿透保护\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport logger from '@/utils/logger';\n\nexport interface RateLimitConfig {\n  windowMs: number;        // 时间窗口（毫秒）\n  maxRequests: number;     // 最大请求数\n  keyGenerator?: (req: Request) => string;  // 自定义key生成器\n  skipSuccessfulRequests?: boolean;        // 是否跳过成功请求\n  skipFailedRequests?: boolean;            // 是否跳过失败请求\n  enableCacheProtection?: boolean;         // 是否启用缓存穿透保护\n  enableBurstProtection?: boolean;         // 是否启用突发保护\n  burstLimit?: number;                     // 突发限制\n}\n\nexport interface RateLimitResult {\n  allowed: boolean;      // 是否允许请求\n  remaining: number;     // 剩余请求数\n  resetTime: Date;       // 重置时间\n  totalHits: number;     // 总命中数\n  retryAfter?: number;   // 重试等待时间（秒）\n}\n\nexport interface SlidingWindowRecord {\n  timestamp: number;\n  count: number;\n}\n\nexport interface RateLimitMetrics {\n  key: string;\n  totalRequests: number;\n  blockedRequests: number;\n  currentRate: number;        // 当前速率（请求/秒）\n  peakRate: number;          // 峰值速率\n  averageResponseTime: number;\n  lastRequestTime: Date;\n  windowRecords: SlidingWindowRecord[];\n}\n\n/**\n * 滑动窗口限流器\n */\nexport class SlidingWindowRateLimiter {\n  private windows: Map<string, RateLimitMetrics> = new Map();\n  private cleanupInterval: NodeJS.Timeout;\n\n  constructor(\n    private readonly config: RateLimitConfig,\n    private readonly name: string = 'default',\n  ) {\n    // 定期清理过期数据\n    this.cleanupInterval = setInterval(() => {\n      this.cleanup();\n    }, this.config.windowMs);\n\n    logger.info('滑动窗口限流器初始化完成', { name: this.name,\n      windowMs: this.config.windowMs,\n      maxRequests: this.config.maxRequests,\n    });\n  }\n\n  /**\n   * 检查请求是否被允许\n   */\n  checkLimit(key: string): RateLimitResult {\n    const now = Date.now();\n    const windowStart = now - this.config.windowMs;\n\n    // 获取或创建窗口记录\n    let metrics = this.windows.get(key);\n    if (!metrics) {\n      metrics = this.createInitialMetrics(key);\n      this.windows.set(key, metrics);\n    }\n\n    // 清理过期记录\n    metrics.windowRecords = metrics.windowRecords.filter(\n      record => record.timestamp > windowStart,\n    );\n\n    // 计算当前窗口内的请求数\n    const currentCount = metrics.windowRecords.reduce(\n      (sum, record) => sum + record.count, 0,\n    );\n\n    // 更新请求统计\n    metrics.totalRequests++;\n    metrics.lastRequestTime = new Date();\n\n    // 计算当前速率\n    const timeDiff = (now - (metrics.windowRecords[0]?.timestamp || now)) / 1000 || 1;\n    metrics.currentRate = currentCount / timeDiff;\n    metrics.peakRate = Math.max(metrics.peakRate, metrics.currentRate);\n\n    // 检查是否超过限制\n    const allowed = currentCount < this.config.maxRequests;\n    const remaining = Math.max(0, this.config.maxRequests - currentCount);\n\n    if (allowed) {\n      // 记录当前请求\n      const existingRecord = metrics.windowRecords.find(\n        record => Math.abs(record.timestamp - now) < 1000, // 1秒内的请求合并\n      );\n\n      if (existingRecord) {\n        existingRecord.count++;\n      } else {\n        metrics.windowRecords.push({ timestamp: now, count: 1 });\n      }\n    } else {\n      metrics.blockedRequests++;\n    }\n\n    const resetTime = new Date(now + this.config.windowMs);\n    const retryAfter = allowed ? undefined : Math.ceil(this.config.windowMs / 1000);\n\n    const result: RateLimitResult = {\n      allowed,\n      remaining,\n      resetTime,\n      totalHits: metrics.totalRequests,\n    };\n\n    if (!allowed && retryAfter !== undefined) {\n      result.retryAfter = retryAfter;\n    }\n\n    return result;\n  }\n\n  /**\n   * 创建初始指标\n   */\n  private createInitialMetrics(key: string): RateLimitMetrics {\n    return {\n      key,\n      totalRequests: 0,\n      blockedRequests: 0,\n      currentRate: 0,\n      peakRate: 0,\n      averageResponseTime: 0,\n      lastRequestTime: new Date(),\n      windowRecords: [],\n    };\n  }\n\n  /**\n   * 清理过期数据\n   */\n  private cleanup(): void {\n    const now = Date.now();\n    const windowStart = now - this.config.windowMs;\n    let cleanedCount = 0;\n\n    this.windows.forEach((metrics, key) => {\n      const originalLength = metrics.windowRecords.length;\n      metrics.windowRecords = metrics.windowRecords.filter(\n        record => record.timestamp > windowStart,\n      );\n\n      if (metrics.windowRecords.length === 0 && originalLength > 0) {\n        // 如果窗口为空且有过期记录，删除整个条目\n        this.windows.delete(key);\n        cleanedCount++;\n      }\n    });\n\n    if (cleanedCount > 0) {\n      logger.debug('限流器清理过期条目', { name: this.name, count: cleanedCount });\n    }\n  }\n\n  /**\n   * 获取指标\n   */\n  getMetrics(key?: string): RateLimitMetrics[] {\n    if (key) {\n      const metrics = this.windows.get(key);\n      return metrics ? [metrics] : [];\n    }\n\n    return Array.from(this.windows.values());\n  }\n\n  /**\n   * 重置指定key的限制\n   */\n  reset(key: string): void {\n    this.windows.delete(key);\n  }\n\n  /**\n   * 清理所有数据\n   */\n  clear(): void {\n    this.windows.clear();\n  }\n\n  /**\n   * 销毁限流器\n   */\n  destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n    this.windows.clear();\n  }\n}\n\n/**\n * 多维度限流器\n */\nexport class MultiDimensionRateLimiter {\n  private limiters: Map<string, SlidingWindowRateLimiter> = new Map();\n\n  constructor(private configs: { [dimension: string]: RateLimitConfig }) {\n    // 初始化各维度的限流器\n    Object.entries(configs).forEach(([dimension, config]) => {\n      const limiter = new SlidingWindowRateLimiter(config, `${dimension}-limiter`);\n      this.limiters.set(dimension, limiter);\n    });\n  }\n\n  /**\n   * 检查多维度限制\n   */\n  checkLimits(req: Request): { dimension: string; result: RateLimitResult }[] {\n    const results: { dimension: string; result: RateLimitResult }[] = [];\n\n    Object.entries(this.configs).forEach(([dimension, config]) => {\n      const key = config.keyGenerator ? config.keyGenerator(req) : this.getDefaultKey(req, dimension);\n      const limiter = this.limiters.get(dimension);\n\n      if (limiter) {\n        const result = limiter.checkLimit(key);\n        results.push({ dimension, result });\n      }\n    });\n\n    return results;\n  }\n\n  /**\n   * 检查是否允许请求（所有维度都必须通过）\n   */\n  isAllowed(req: Request): { allowed: boolean; results: RateLimitResult[] } {\n    const results = this.checkLimits(req);\n    const allowed = results.every(r => r.result.allowed);\n\n    return {\n      allowed,\n      results: results.map(r => r.result),\n    };\n  }\n\n  /**\n   * 获取默认key\n   */\n  private getDefaultKey(req: Request, dimension: string): string {\n    switch (dimension) {\n      case 'ip':\n        return req.ip || req.connection.remoteAddress || 'unknown';\n      case 'user':\n        return (req as any).user?.id || 'anonymous';\n      case 'endpoint':\n        return `${req.method}:${req.route?.path || req.path}`;\n      case 'global':\n        return 'global';\n      default:\n        return `${dimension}:${req.ip || 'unknown'}`;\n    }\n  }\n\n  /**\n   * 获取所有维度的指标\n   */\n  getAllMetrics(): { dimension: string; metrics: RateLimitMetrics[] }[] {\n    return Array.from(this.limiters.entries()).map(([dimension, limiter]) => ({\n      dimension,\n      metrics: limiter.getMetrics(),\n    }));\n  }\n\n  /**\n   * 销毁所有限流器\n   */\n  destroy(): void {\n    this.limiters.forEach(limiter => limiter.destroy());\n    this.limiters.clear();\n  }\n}\n\n/**\n * 缓存穿透保护器\n */\nexport class CacheBreachProtector {\n  private cache: Map<string, { timestamp: number; blocked: boolean }> = new Map();\n  private readonly suspiciousThreshold: number;\n  private readonly blockDuration: number;\n\n  constructor(suspiciousThreshold = 100, blockDuration = 300000) { // 5分钟\n    this.suspiciousThreshold = suspiciousThreshold;\n    this.blockDuration = blockDuration;\n  }\n\n  /**\n   * 检查是否被缓存穿透保护\n   */\n  checkProtection(key: string): { blocked: boolean; suspicious: boolean } {\n    const now = Date.now();\n    const cached = this.cache.get(key);\n\n    if (!cached) {\n      this.cache.set(key, { timestamp: now, blocked: false });\n      return { blocked: false, suspicious: false };\n    }\n\n    // 检查是否在阻止期内\n    if (cached.blocked && (now - cached.timestamp) < this.blockDuration) {\n      return { blocked: true, suspicious: true };\n    }\n\n    // 检查是否达到可疑阈值\n    const timeDiff = now - cached.timestamp;\n    if (timeDiff < 60000 && this.getRecentRequests(key) > this.suspiciousThreshold) {\n      // 标记为可疑并阻止\n      cached.blocked = true;\n      cached.timestamp = now;\n      return { blocked: true, suspicious: true };\n    }\n\n    return { blocked: false, suspicious: false };\n  }\n\n  /**\n   * 获取最近请求数（简单实现）\n   */\n  private getRecentRequests(key: string): number {\n    // 这里可以实现更复杂的逻辑，比如滑动窗口计数\n    return Math.floor(Math.random() * 150); // 模拟实现\n  }\n\n  /**\n   * 清理缓存\n   */\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, value] of this.cache.entries()) {\n      if (now - value.timestamp > this.blockDuration * 2) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\n/**\n * Express中间件\n */\nexport function createRateLimitMiddleware(config: RateLimitConfig) {\n  const limiter = new SlidingWindowRateLimiter(config);\n\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      // 生成限流key\n      const key = config.keyGenerator ? config.keyGenerator(req) : req.ip || 'unknown';\n\n      // 检查限制\n      const result = limiter.checkLimit(key);\n\n      // 设置响应头\n      res.set({\n        'X-RateLimit-Limit': config.maxRequests.toString(),\n        'X-RateLimit-Remaining': result.remaining.toString(),\n        'X-RateLimit-Reset': result.resetTime.toISOString(),\n      });\n\n      if (!result.allowed) {\n        // 请求被限制\n        res.set({\n          'Retry-After': (result.retryAfter || 60).toString(),\n        });\n\n        res.status(429).json({\n          code: 'RATE_LIMIT_EXCEEDED',\n          message: '请求过于频繁，请稍后再试',\n          retryAfter: result.retryAfter || 60,\n          resetTime: result.resetTime.toISOString(),\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      next();\n    } catch (error) {\n      logger.error('限流中间件错误', { error });\n      // 出错时允许请求通过，避免影响正常服务\n      next();\n    }\n  };\n}\n\n/**\n * 创建多维度限流中间件\n */\nexport function createMultiDimensionRateLimitMiddleware(\n  configs: { [dimension: string]: RateLimitConfig },\n) {\n  const multiLimiter = new MultiDimensionRateLimiter(configs);\n  const cacheProtector = new CacheBreachProtector();\n\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      // 缓存穿透保护\n      const key = req.ip || 'unknown';\n      const protection = cacheProtector.checkProtection(key);\n\n      if (protection.blocked) {\n        res.status(429).json({\n          code: 'CACHE_BREACH_PROTECTION',\n          message: '检测到异常请求模式，暂时限制访问',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      // 多维度限流检查\n      const checkResult = multiLimiter.isAllowed(req);\n\n      if (!checkResult.allowed) {\n        // 找到第一个超限的维度\n        const failedResult = checkResult.results.find(r => !r.allowed);\n        if (failedResult) {\n          res.set({\n            'X-RateLimit-Limit': configs.ip?.maxRequests.toString() || '100',\n            'X-RateLimit-Remaining': failedResult.remaining.toString(),\n            'X-RateLimit-Reset': failedResult.resetTime.toISOString(),\n            'Retry-After': (failedResult.retryAfter || 60).toString(),\n          });\n\n          res.status(429).json({\n            code: 'RATE_LIMIT_EXCEEDED',\n            message: '请求过于频繁，请稍后再试',\n            retryAfter: failedResult.retryAfter || 60,\n            resetTime: failedResult.resetTime.toISOString(),\n            timestamp: new Date().toISOString(),\n          });\n          return;\n        }\n      }\n\n      next();\n    } catch (error) {\n      logger.error('多维度限流中间件错误', { error });\n      next();\n    }\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/RetryService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[670,673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[670,673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1033,1036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1033,1036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1816,1819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1816,1819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3862,3865],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3862,3865],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5281,5284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5281,5284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":372,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":372,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8999,9002],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8999,9002],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":378,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":378,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9164,9167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9164,9167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":378,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":378,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9199,9202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9199,9202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 请求重试和降级策略服务\n * 实现智能重试机制、优雅降级和请求去重\n */\n\nimport logger from '@/utils/logger';\n\nexport interface RetryConfig {\n  maxRetries: number;                    // 最大重试次数\n  baseDelay: number;                     // 基础延迟时间（毫秒）\n  maxDelay: number;                      // 最大延迟时间（毫秒）\n  backoffFactor: number;                 // 退避因子\n  retryableErrors?: string[];            // 可重试的错误类型\n  retryableStatusCodes?: number[];       // 可重试的HTTP状态码\n  enableJitter: boolean;                 // 是否启用抖动\n  onRetry?: (attempt: number, error: Error, delay: number) => void; // 重试回调\n}\n\nexport interface FallbackConfig {\n  enabled: boolean;                      // 是否启用降级\n  fallbackResponse?: any;                // 降级响应\n  fallbackProvider?: string;             // 降级提供商\n  cacheFallbackResponse: boolean;        // 是否缓存降级响应\n  maxCacheSize: number;                  // 最大缓存大小\n  cacheTTL: number;                      // 缓存TTL（毫秒）\n}\n\nexport interface RequestDeduplicationConfig {\n  enabled: boolean;                      // 是否启用去重\n  keyGenerator?: (request: any) => string; // 自定义key生成器\n  deduplicationWindow: number;           // 去重窗口时间（毫秒）\n  maxConcurrentRequests: number;         // 最大并发请求数\n}\n\nexport interface RetryResult<T> {\n  success: boolean;\n  data?: T;\n  error?: Error;\n  attempts: number;\n  totalDelay: number;\n  fallbackUsed: boolean;\n}\n\nexport interface RequestMetrics {\n  requestId: string;\n  attempts: number;\n  totalDuration: number;\n  error?: Error;\n  fallbackUsed: boolean;\n  timestamp: Date;\n}\n\n/**\n * 重试策略枚举\n */\nexport enum RetryStrategy {\n  FIXED = 'fixed',           // 固定延迟\n  LINEAR = 'linear',         // 线性退避\n  EXPONENTIAL = 'exponential', // 指数退避\n  EXPONENTIAL_WITH_JITTER = 'exponential_with_jitter' // 带抖动的指数退避\n}\n\n/**\n * 请求去重器\n */\nexport class RequestDeduplicator {\n  private pendingRequests: Map<string, Promise<any>> = new Map();\n  private requestMetrics: Map<string, RequestMetrics> = new Map();\n  private cleanupInterval: NodeJS.Timeout;\n\n  constructor(private config: RequestDeduplicationConfig) {\n    // 定期清理过期的去重记录\n    this.cleanupInterval = setInterval(() => {\n      this.cleanup();\n    }, this.config.deduplicationWindow);\n\n    logger.info('请求去重器初始化完成', {\n      enabled: this.config.enabled,\n      deduplicationWindow: this.config.deduplicationWindow,\n      maxConcurrentRequests: this.config.maxConcurrentRequests,\n    });\n  }\n\n  /**\n   * 执行去重请求\n   */\n  async execute<T>(\n    key: string,\n    operation: () => Promise<T>,\n  ): Promise<T> {\n    if (!this.config.enabled) {\n      return operation();\n    }\n\n    // 检查是否已有相同请求在进行\n    const existingRequest = this.pendingRequests.get(key);\n    if (existingRequest) {\n      logger.debug('请求去重，复用现有请求', { key });\n      return existingRequest;\n    }\n\n    // 检查并发请求数量\n    if (this.pendingRequests.size >= this.config.maxConcurrentRequests) {\n      throw new Error('并发请求数超过限制');\n    }\n\n    // 执行新请求\n    const requestPromise = this.executeWithMetrics(key, operation);\n    this.pendingRequests.set(key, requestPromise);\n\n    try {\n      const result = await requestPromise;\n      return result;\n    } finally {\n      this.pendingRequests.delete(key);\n    }\n  }\n\n  /**\n   * 执行请求并记录指标\n   */\n  private async executeWithMetrics<T>(\n    key: string,\n    operation: () => Promise<T>,\n  ): Promise<T> {\n    const startTime = Date.now();\n    const metrics: RequestMetrics = {\n      requestId: key,\n      attempts: 1,\n      totalDuration: 0,\n      fallbackUsed: false,\n      timestamp: new Date(),\n    };\n\n    try {\n      const result = await operation();\n      metrics.totalDuration = Date.now() - startTime;\n      this.requestMetrics.set(key, metrics);\n      return result;\n    } catch (error) {\n      metrics.error = error as Error;\n      metrics.totalDuration = Date.now() - startTime;\n      this.requestMetrics.set(key, metrics);\n      throw error;\n    }\n  }\n\n  /**\n   * 生成请求key\n   */\n  generateRequestKey(request: any): string {\n    if (this.config.keyGenerator) {\n      return this.config.keyGenerator(request);\n    }\n\n    // 默认key生成策略\n    const keyParts = [\n      request.method || 'GET',\n      request.url || request.endpoint || '',\n      JSON.stringify(request.data || request.body || {}),\n      JSON.stringify(request.params || request.query || {}),\n    ];\n\n    return Buffer.from(keyParts.join('|')).toString('base64');\n  }\n\n  /**\n   * 清理过期记录\n   */\n  private cleanup(): void {\n    const now = Date.now();\n    const cutoffTime = now - this.config.deduplicationWindow;\n\n    // 清理请求指标\n    let cleanedMetrics = 0;\n    for (const [key, metrics] of this.requestMetrics.entries()) {\n      if (metrics.timestamp.getTime() < cutoffTime) {\n        this.requestMetrics.delete(key);\n        cleanedMetrics++;\n      }\n    }\n\n    if (cleanedMetrics > 0) {\n      logger.debug('清理过期的请求指标', { count: cleanedMetrics });\n    }\n  }\n\n  /**\n   * 获取请求指标\n   */\n  getMetrics(): RequestMetrics[] {\n    return Array.from(this.requestMetrics.values());\n  }\n\n  /**\n   * 清理所有数据\n   */\n  clear(): void {\n    this.pendingRequests.clear();\n    this.requestMetrics.clear();\n  }\n\n  /**\n   * 销毁去重器\n   */\n  destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n    this.clear();\n  }\n}\n\n/**\n * 重试服务\n */\nexport class RetryService {\n  private deduplicator: RequestDeduplicator;\n  private fallbackCache: Map<string, { data: any; timestamp: number }> = new Map();\n\n  constructor(\n    private retryConfig: RetryConfig,\n    private fallbackConfig: FallbackConfig,\n    deduplicationConfig?: RequestDeduplicationConfig,\n  ) {\n    this.deduplicator = new RequestDeduplicator(\n      deduplicationConfig || {\n        enabled: true,\n        deduplicationWindow: 30000, // 30秒\n        maxConcurrentRequests: 1000,  // 最大支持1000并发\n      },\n    );\n\n    // 设置默认的可重试错误和状态码\n    if (!this.retryConfig.retryableErrors) {\n      this.retryConfig.retryableErrors = [\n        'ECONNRESET',\n        'ETIMEDOUT',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'EAI_AGAIN',\n        'NETWORK_ERROR',\n        'TIMEOUT_ERROR',\n      ];\n    }\n\n    if (!this.retryConfig.retryableStatusCodes) {\n      this.retryConfig.retryableStatusCodes = [408, 429, 500, 502, 503, 504];\n    }\n\n    logger.info('重试服务初始化完成', {\n      maxRetries: this.retryConfig.maxRetries,\n      baseDelay: this.retryConfig.baseDelay,\n      fallbackEnabled: this.fallbackConfig.enabled,\n    });\n  }\n\n  /**\n   * 执行带重试的操作\n   */\n  async executeWithRetry<T>(\n    operation: () => Promise<T>,\n    context?: string,\n  ): Promise<RetryResult<T>> {\n    let lastError: Error | undefined;\n    let totalDelay = 0;\n    const startTime = Date.now();\n\n    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {\n      try {\n        const result = await operation();\n\n        // 成功时记录指标\n        const duration = Date.now() - startTime;\n        logger.debug('请求成功', {\n          context,\n          attempt: attempt + 1,\n          duration,\n          totalDelay,\n        });\n\n        return {\n          success: true,\n          data: result,\n          attempts: attempt + 1,\n          totalDelay,\n          fallbackUsed: false,\n        };\n      } catch (error) {\n        lastError = error as Error;\n\n        // 检查是否应该重试\n        if (attempt === this.retryConfig.maxRetries || !this.shouldRetry(lastError)) {\n          break;\n        }\n\n        // 计算延迟时间\n        const delay = this.calculateDelay(attempt);\n        totalDelay += delay;\n\n        // 调用重试回调\n        this.retryConfig.onRetry?.(attempt + 1, lastError, delay);\n\n        logger.warn('请求失败，准备重试', {\n          context,\n          attempt: attempt + 1,\n          maxRetries: this.retryConfig.maxRetries + 1,\n          error: lastError.message,\n          delay,\n          nextRetryIn: new Date(Date.now() + delay).toISOString(),\n        });\n\n        // 等待后重试\n        await this.sleep(delay);\n      }\n    }\n\n    // 所有重试都失败，尝试降级处理\n    if (this.fallbackConfig.enabled) {\n      const fallbackResult = await this.executeFallback<T>(lastError!);\n      return {\n        success: true,\n        data: fallbackResult,\n        attempts: this.retryConfig.maxRetries + 1,\n        totalDelay,\n        fallbackUsed: true,\n      };\n    }\n\n    // 重试失败且无降级处理\n    const duration = Date.now() - startTime;\n    logger.error('请求最终失败', {\n      context,\n      totalAttempts: this.retryConfig.maxRetries + 1,\n      duration,\n      totalDelay,\n      finalError: lastError?.message,\n    });\n\n    const result: RetryResult<T> = {\n      success: false,\n      attempts: this.retryConfig.maxRetries + 1,\n      totalDelay,\n      fallbackUsed: false,\n    };\n\n    if (lastError) {\n      result.error = lastError;\n    }\n\n    return result;\n  }\n\n  /**\n   * 执行带去重的重试操作\n   */\n  async executeWithRetryAndDeduplication<T>(\n    requestKey: string,\n    operation: () => Promise<T>,\n    context?: string,\n  ): Promise<RetryResult<T>> {\n    return this.deduplicator.execute(requestKey, async () => {\n      return this.executeWithRetry(operation, context);\n    });\n  }\n\n  /**\n   * 判断是否应该重试\n   */\n  private shouldRetry(error: Error): boolean {\n    // 检查错误类型\n    const errorCode = (error as any).code;\n    if (errorCode && this.retryConfig.retryableErrors?.includes(errorCode)) {\n      return true;\n    }\n\n    // 检查HTTP状态码\n    const statusCode = (error as any).response?.status || (error as any).status;\n    if (statusCode && this.retryConfig.retryableStatusCodes?.includes(statusCode)) {\n      return true;\n    }\n\n    // 检查错误消息\n    const errorMessage = error.message.toLowerCase();\n    const retryablePatterns = [\n      'timeout',\n      'network',\n      'connection',\n      'socket',\n      'econnreset',\n      'etimedout',\n    ];\n\n    return retryablePatterns.some(pattern => errorMessage.includes(pattern));\n  }\n\n  /**\n   * 计算延迟时间\n   */\n  private calculateDelay(attempt: number): number {\n    let delay: number;\n\n    // 基础延迟计算\n    switch (this.retryConfig.backoffFactor) {\n      case 1: // 固定延迟\n        delay = this.retryConfig.baseDelay;\n        break;\n      case 2: // 线性退避\n        delay = this.retryConfig.baseDelay * (attempt + 1);\n        break;\n      default: // 指数退避\n        delay = this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffFactor, attempt);\n        break;\n    }\n\n    // 限制最大延迟\n    delay = Math.min(delay, this.retryConfig.maxDelay);\n\n    // 添加抖动\n    if (this.retryConfig.enableJitter) {\n      const jitter = delay * 0.1 * Math.random(); // 10% 的抖动\n      delay += jitter;\n    }\n\n    return Math.floor(delay);\n  }\n\n  /**\n   * 执行降级处理\n   */\n  private async executeFallback<T>(error: Error): Promise<T> {\n    logger.warn('执行降级处理', {\n      error: error.message,\n      fallbackProvider: this.fallbackConfig.fallbackProvider,\n    });\n\n    // 检查缓存\n    if (this.fallbackConfig.cacheFallbackResponse) {\n      const cacheKey = 'fallback_response';\n      const cached = this.fallbackCache.get(cacheKey);\n\n      if (cached && (Date.now() - cached.timestamp) < this.fallbackConfig.cacheTTL) {\n        logger.debug('使用缓存的降级响应');\n        return cached.data;\n      }\n    }\n\n    // 返回降级响应\n    let fallbackResponse: T;\n\n    if (this.fallbackConfig.fallbackResponse) {\n      fallbackResponse = this.fallbackConfig.fallbackResponse;\n    } else {\n      // 默认降级响应\n      fallbackResponse = {\n        error: '服务暂时不可用，请稍后重试',\n        fallback: true,\n        timestamp: new Date().toISOString(),\n      } as T;\n    }\n\n    // 缓存降级响应\n    if (this.fallbackConfig.cacheFallbackResponse) {\n      const cacheKey = 'fallback_response';\n\n      // 检查缓存大小\n      if (this.fallbackCache.size >= this.fallbackConfig.maxCacheSize) {\n        // 删除最旧的缓存项\n        const keys = Array.from(this.fallbackCache.keys());\n        if (keys.length > 0) {\n          const oldestKey = keys[0];\n          if (oldestKey !== undefined) {\n            this.fallbackCache.delete(oldestKey);\n          }\n        }\n      }\n\n      this.fallbackCache.set(cacheKey, {\n        data: fallbackResponse,\n        timestamp: Date.now(),\n      });\n    }\n\n    return fallbackResponse;\n  }\n\n  /**\n   * 睡眠函数\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * 获取去重指标\n   */\n  getDeduplicationMetrics(): RequestMetrics[] {\n    return this.deduplicator.getMetrics();\n  }\n\n  /**\n   * 清理缓存\n   */\n  clearFallbackCache(): void {\n    this.fallbackCache.clear();\n  }\n\n  /**\n   * 销毁服务\n   */\n  destroy(): void {\n    this.deduplicator.destroy();\n    this.fallbackCache.clear();\n  }\n}\n\n/**\n * 创建默认重试配置\n */\nexport function createDefaultRetryConfig(): RetryConfig {\n  return {\n    maxRetries: 3,\n    baseDelay: 1000,\n    maxDelay: 10000,\n    backoffFactor: 2,\n    enableJitter: true,\n    retryableErrors: [\n      'ECONNRESET',\n      'ETIMEDOUT',\n      'ECONNREFUSED',\n      'ENOTFOUND',\n      'EAI_AGAIN',\n      'NETWORK_ERROR',\n      'TIMEOUT_ERROR',\n    ],\n    retryableStatusCodes: [408, 429, 500, 502, 503, 504],\n  };\n}\n\n/**\n * 创建默认降级配置\n */\nexport function createDefaultFallbackConfig(): FallbackConfig {\n  return {\n    enabled: true,\n    fallbackResponse: {\n      error: '服务暂时不可用，请稍后重试',\n      fallback: true,\n      timestamp: new Date().toISOString(),\n    },\n    cacheFallbackResponse: true,\n    maxCacheSize: 100,\n    cacheTTL: 300000, // 5分钟\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/SessionEventService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[695,698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[695,698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[716,719],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[716,719],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[884,887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[884,887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3120,3123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3120,3123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3143,3146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3143,3146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6890,6893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6890,6893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalLength' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":294,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":294,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":422,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":422,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11321,11324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11321,11324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { randomUUID } from 'crypto';\nimport {\n  SessionEvent,\n  SessionEventType,\n  EventQueryParams,\n  PaginatedResponse,\n} from '@/types';\nimport logger from '@/utils/logger';\n\n/**\n * 会话事件追踪服务\n * 负责记录、存储和查询会话相关的事件\n */\nexport class SessionEventService {\n  private events: Map<string, SessionEvent[]> = new Map();\n  private maxEventsPerAgent = 10000; // 每个智能体最大事件数量\n\n  /**\n   * 清理事件缓存（测试或重置时使用）\n   */\n  clear(agentId?: string): void {\n    if (agentId) {\n      this.events.delete(agentId);\n      return;\n    }\n\n    this.events.clear();\n  }\n\n  /**\n   * 记录会话事件\n   */\n  async recordEvent(\n    agentId: string,\n    sessionId: string,\n    eventType: SessionEventType,\n    metadata?: {\n      oldData?: any;\n      newData?: any;\n      reason?: string;\n      feedbackType?: 'good' | 'bad';\n      feedbackValue?: string;\n      tags?: string[];\n      exportFormat?: string;\n      [key: string]: any;\n    },\n    context?: {\n      userId?: string;\n      userAgent?: string;\n      ipAddress?: string;\n    },\n  ): Promise<SessionEvent> {\n    const event: SessionEvent = {\n      id: randomUUID(),\n      sessionId,\n      agentId,\n      eventType,\n      timestamp: new Date().toISOString(),\n      ...(context?.userId && { userId: context.userId }),\n      ...(metadata && { metadata }),\n      ...(context?.userAgent && { userAgent: context.userAgent }),\n      ...(context?.ipAddress && { ipAddress: context.ipAddress }),\n    };\n\n    // 存储事件（内存存储，实际生产环境应使用数据库）\n    if (!this.events.has(agentId)) {\n      this.events.set(agentId, []);\n    }\n\n    const agentEvents = this.events.get(agentId)!;\n    agentEvents.push(event);\n\n    // 限制事件数量，防止内存溢出\n    if (agentEvents.length > this.maxEventsPerAgent) {\n      const excessCount = agentEvents.length - this.maxEventsPerAgent;\n      agentEvents.splice(0, excessCount);\n    }\n\n    logger.debug('[事件记录]', { agentId, sessionId, eventType });\n\n    return event;\n  }\n\n  /**\n   * 查询会话事件\n   */\n  async queryEvents(\n    agentId: string,\n    params: EventQueryParams,\n  ): Promise<PaginatedResponse<SessionEvent>> {\n    let agentEvents = this.events.get(agentId) || [];\n\n    // 过滤条件\n    if (params.sessionIds && params.sessionIds.length > 0) {\n      agentEvents = agentEvents.filter(event =>\n        params.sessionIds!.includes(event.sessionId),\n      );\n    }\n\n    if (params.eventTypes && params.eventTypes.length > 0) {\n      agentEvents = agentEvents.filter(event =>\n        params.eventTypes!.includes(event.eventType),\n      );\n    }\n\n    if (params.startDate) {\n      const startDate = new Date(params.startDate);\n      agentEvents = agentEvents.filter(event =>\n        new Date(event.timestamp) >= startDate,\n      );\n    }\n\n    if (params.endDate) {\n      const endDate = new Date(params.endDate);\n      agentEvents = agentEvents.filter(event =>\n        new Date(event.timestamp) <= endDate,\n      );\n    }\n\n    if (params.userId) {\n      agentEvents = agentEvents.filter(event =>\n        event.userId === params.userId,\n      );\n    }\n\n    // 排序\n    const sortBy = params.sortBy || 'timestamp';\n    const sortOrder = params.sortOrder || 'desc';\n\n    agentEvents.sort((a, b) => {\n      let aValue: any;\n      let bValue: any;\n\n      switch (sortBy) {\n        case 'timestamp':\n          aValue = new Date(a.timestamp).getTime();\n          bValue = new Date(b.timestamp).getTime();\n          break;\n        default:\n          aValue = new Date(a.timestamp).getTime();\n          bValue = new Date(b.timestamp).getTime();\n      }\n\n      if (sortOrder === 'asc') {\n        return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;\n      } else {\n        return aValue < bValue ? 1 : aValue > bValue ? -1 : 0;\n      }\n    });\n\n    // 分页\n    const page = params.page || 1;\n    const pageSize = params.pageSize || 20;\n    const startIndex = (page - 1) * pageSize;\n    const endIndex = startIndex + pageSize;\n    const paginatedData = agentEvents.slice(startIndex, endIndex);\n\n    return {\n      data: paginatedData,\n      total: agentEvents.length,\n      page,\n      pageSize,\n      totalPages: Math.ceil(agentEvents.length / pageSize),\n      hasNext: endIndex < agentEvents.length,\n      hasPrev: page > 1,\n    };\n  }\n\n  /**\n   * 获取会话的所有事件\n   */\n  async getSessionEvents(\n    agentId: string,\n    sessionId: string,\n  ): Promise<SessionEvent[]> {\n    const agentEvents = this.events.get(agentId) || [];\n    return agentEvents\n      .filter(event => event.sessionId === sessionId)\n      .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n  }\n\n  /**\n   * 获取事件统计信息\n   */\n  async getEventStats(\n    agentId: string,\n    dateRange?: { start: string; end: string },\n  ): Promise<{\n    totalEvents: number;\n    eventTypeStats: Array<{ type: SessionEventType; count: number }>;\n    dailyActivity: Array<{ date: string; count: number }>;\n    topSessions: Array<{ sessionId: string; eventCount: number }>;\n    userActivity: Array<{ userId?: string; eventCount: number }>;\n  }> {\n    let agentEvents = this.events.get(agentId) || [];\n\n    // 日期范围过滤\n    if (dateRange) {\n      const startDate = new Date(dateRange.start);\n      const endDate = new Date(dateRange.end);\n\n      agentEvents = agentEvents.filter(event => {\n        const eventDate = new Date(event.timestamp);\n        return eventDate >= startDate && eventDate <= endDate;\n      });\n    }\n\n    // 事件类型统计\n    const eventTypeStats = new Map<SessionEventType, number>();\n    agentEvents.forEach(event => {\n      eventTypeStats.set(event.eventType, (eventTypeStats.get(event.eventType) || 0) + 1);\n    });\n\n    // 每日活动统计\n    const dailyActivity = new Map<string, number>();\n    agentEvents.forEach(event => {\n      const date = event.timestamp.split('T')[0];\n      if (date) {\n        dailyActivity.set(date, (dailyActivity.get(date) || 0) + 1);\n      }\n    });\n\n    // 会话活动统计\n    const sessionActivity = new Map<string, number>();\n    agentEvents.forEach(event => {\n      sessionActivity.set(event.sessionId, (sessionActivity.get(event.sessionId) || 0) + 1);\n    });\n\n    // 用户活动统计\n    const userActivity = new Map<string | undefined, number>();\n    agentEvents.forEach(event => {\n      userActivity.set(event.userId, (userActivity.get(event.userId) || 0) + 1);\n    });\n\n    return {\n      totalEvents: agentEvents.length,\n      eventTypeStats: Array.from(eventTypeStats.entries())\n        .map(([type, count]) => ({ type, count }))\n        .sort((a, b) => b.count - a.count),\n      dailyActivity: Array.from(dailyActivity.entries())\n        .map(([date, count]) => ({ date, count }))\n        .sort((a, b) => b.date.localeCompare(a.date))\n        .slice(0, 30),\n      topSessions: Array.from(sessionActivity.entries())\n        .map(([sessionId, eventCount]) => ({ sessionId, eventCount }))\n        .sort((a, b) => b.eventCount - a.eventCount)\n        .slice(0, 10),\n      userActivity: Array.from(userActivity.entries())\n        .map(([userId, eventCount]) => {\n          const userActivityData: any = { eventCount };\n          if (userId) {\n            userActivityData.userId = userId;\n          }\n          return userActivityData;\n        })\n        .sort((a, b) => b.eventCount - a.eventCount)\n        .slice(0, 10),\n    };\n  }\n\n  /**\n   * 清理旧事件（防止内存溢出）\n   */\n  async cleanupOldEvents(agentId: string, olderThanDays: number = 30): Promise<number> {\n    const agentEvents = this.events.get(agentId) || [];\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n\n    const originalCount = agentEvents.length;\n    const filteredEvents = agentEvents.filter((event: SessionEvent) =>\n      new Date(event.timestamp) >= cutoffDate,\n    );\n\n    this.events.set(agentId, filteredEvents);\n    const deletedCount = originalCount - filteredEvents.length;\n\n    if (deletedCount > 0) {\n      logger.debug('清理旧事件', { agentId, deletedCount });\n    }\n\n    return deletedCount;\n  }\n\n  /**\n   * 批量删除事件\n   */\n  async deleteEvents(\n    agentId: string,\n    eventIds: string[],\n  ): Promise<{ success: number; failed: number; errors: string[] }> {\n    const agentEvents = this.events.get(agentId) || [];\n    const results = { success: 0, failed: 0, errors: [] as string[] };\n\n    const originalLength = agentEvents.length;\n\n    // 过滤掉要删除的事件\n    const remainingEvents = agentEvents.filter((event: SessionEvent) => {\n      if (eventIds.includes(event.id)) {\n        results.success++;\n        return false;\n      }\n      return true;\n    });\n\n    this.events.set(agentId, remainingEvents);\n    results.failed = eventIds.length - results.success;\n\n    if (results.failed > 0) {\n      results.errors.push(`${results.failed} 个事件未找到`);\n    }\n\n    return results;\n  }\n\n  /**\n   * 导出事件数据\n   */\n  async exportEvents(\n    agentId: string,\n    params: EventQueryParams & { format: 'json' | 'csv' },\n  ): Promise<{ filename: string; data: string }> {\n    const result = await this.queryEvents(agentId, params);\n    const events = result.data;\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n    if (params.format === 'json') {\n      const exportData = {\n        metadata: {\n          exportedAt: new Date().toISOString(),\n          totalEvents: events.length,\n          agentId,\n          filters: params,\n        },\n        events,\n      };\n\n      return {\n        filename: `events_${agentId}_${timestamp}.json`,\n        data: JSON.stringify(exportData, null, 2),\n      };\n    } else {\n      // CSV格式\n      const headers = [\n        'Event ID',\n        'Session ID',\n        'Event Type',\n        'Timestamp',\n        'User ID',\n        'User Agent',\n        'IP Address',\n        'Metadata',\n      ];\n\n      const csvRows = [headers.join(',')];\n\n      events.forEach((event: SessionEvent) => {\n        const row = [\n          `\"${event.id}\"`,\n          `\"${event.sessionId}\"`,\n          `\"${event.eventType}\"`,\n          event.timestamp,\n          event.userId || '',\n          `\"${this.escapeCsv(event.userAgent || '')}\"`,\n          `\"${event.ipAddress || ''}\"`,\n          `\"${this.escapeCsv(JSON.stringify(event.metadata || {}))}\"`,\n        ];\n        csvRows.push(row.join(','));\n      });\n\n      return {\n        filename: `events_${agentId}_${timestamp}.csv`,\n        data: csvRows.join('\\n'),\n      };\n    }\n  }\n\n  /**\n   * 转义CSV字段\n   */\n  private escapeCsv(field: string): string {\n    return field.replace(/\"/g, '\"\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n  }\n\n  /**\n   * 获取实时事件流（用于WebSocket或SSE）\n   */\n  async getEventStream(\n    agentId: string,\n    params: {\n      sessionIds?: string[];\n      eventTypes?: SessionEventType[];\n      since?: string;\n    } = {},\n  ): Promise<AsyncIterable<SessionEvent>> {\n    const since = params.since ? new Date(params.since) : new Date(Date.now() - 60000); // 默认最近1分钟\n\n    // 这里应该实现实时事件流\n    // 当前返回一个模拟的异步可迭代对象\n    const agentEvents = this.events.get(agentId) || [];\n\n    const filteredEvents = agentEvents.filter(event => {\n      const eventDate = new Date(event.timestamp);\n\n      if (eventDate < since) {\n        return false;\n      }\n      if (params.sessionIds && !params.sessionIds.includes(event.sessionId)) {\n        return false;\n      }\n      if (params.eventTypes && !params.eventTypes.includes(event.eventType)) {\n        return false;\n      }\n\n      return true;\n    });\n\n    return {\n      [Symbol.asyncIterator]() {\n        let index = 0;\n        return {\n          async next(): Promise<IteratorResult<SessionEvent, any>> {\n            if (index < filteredEvents.length) {\n              const event = filteredEvents[index++];\n              if (event) {\n                return { value: event, done: false };\n              }\n            }\n            return { value: undefined, done: true };\n          },\n        };\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/TokenService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ValidationError' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Redis from 'ioredis';\nimport jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\nimport { Pool } from 'pg';\nimport { ValidationError, SystemError } from '@/types/errors';\nimport logger from '@/utils/logger';\nimport { getPool } from '@/utils/db';\n\nexport interface TokenPayload {\n  userId: string;\n  username: string;\n  role: 'admin' | 'user';\n  iat: number;\n  exp: number;\n}\n\nexport interface TokenMetadata {\n  createdAt: number;\n  userAgent?: string;\n  ip?: string;\n  lastAccessedAt: number;\n}\n\nexport class TokenService {\n  private redis: Redis;\n  private secret: string;\n  private ttl: number;\n  private refreshTtl: number;\n\n  /**\n   * 延迟获取数据库连接池\n   * 避免在模块导入时调用 getPool()，确保 initDB() 已执行\n   */\n  private get pool(): Pool {\n    return getPool();\n  }\n\n  constructor() {\n    const redisConfig: {\n      host: string;\n      port: number;\n      password?: string;\n      db: number;\n      keyPrefix: string;\n      retryStrategy: (times: number) => number;\n      lazyConnect: boolean;\n    } = {\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379', 10),\n      db: parseInt(process.env.REDIS_DB || '0', 10),\n      keyPrefix: 'token:',\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      lazyConnect: true, // 延迟连接,避免测试环境启动失败\n    };\n\n    // 只在有密码时添加password字段\n    if (process.env.REDIS_PASSWORD) {\n      redisConfig.password = process.env.REDIS_PASSWORD;\n    }\n\n    this.redis = new Redis(redisConfig);\n    this.secret = process.env.JWT_SECRET || this.generateSecret();\n    this.ttl = parseInt(process.env.TOKEN_TTL || '604800', 10); // 7 天\n    this.refreshTtl = parseInt(process.env.REFRESH_TOKEN_TTL || '2592000', 10); // 30 天\n    // ✅ 不再在构造函数中调用 getPool()，改为使用 getter 延迟获取\n\n    // 监听 Redis 连接事件\n    this.redis.on('error', (err) => {\n      logger.error('Redis connection error', { component: 'TokenService', error: err });\n    });\n\n    this.redis.on('connect', () => {\n      logger.info('Redis connected successfully', { component: 'TokenService' });\n    });\n  }\n\n  /**\n   * 确保 Redis 连接已建立\n   */\n  private async ensureRedisConnected(): Promise<void> {\n    if (this.redis.status !== 'ready') {\n      try {\n        await this.redis.connect();\n      } catch (error) {\n        throw new SystemError({\n          message: 'Failed to connect to Redis',\n          code: 'REDIS_CONNECTION_ERROR',\n          originalError: error as Error,\n        });\n      }\n    }\n  }\n\n  /**\n   * 创建访问令牌\n   */\n  async createAccessToken(\n    userId: string,\n    username: string,\n    role: 'admin' | 'user',\n    metadata?: Partial<TokenMetadata>,\n  ): Promise<string> {\n    await this.ensureRedisConnected();\n\n    const now = Math.floor(Date.now() / 1000);\n    const payload: TokenPayload = {\n      userId,\n      username,\n      role,\n      iat: now,\n      exp: now + this.ttl,\n    };\n\n    const token = jwt.sign(payload, this.secret);\n\n    // 存储到 Redis\n    const tokenKey = `access:${userId}:${this.hashToken(token)}`;\n    const tokenMetadata: TokenMetadata = {\n      createdAt: now,\n      lastAccessedAt: now,\n    };\n\n    // 只在有值时添加可选字段\n    if (metadata?.userAgent) {\n      tokenMetadata.userAgent = metadata.userAgent;\n    }\n    if (metadata?.ip) {\n      tokenMetadata.ip = metadata.ip;\n    }\n\n    await this.redis.setex(tokenKey, this.ttl, JSON.stringify(tokenMetadata));\n\n    logger.info('Access token created', {\n      component: 'TokenService',\n      userId,\n      username,\n      role,\n    });\n\n    return token;\n  }\n\n  /**\n   * 创建刷新令牌\n   */\n  async createRefreshToken(userId: string): Promise<string> {\n    await this.ensureRedisConnected();\n\n    const token = this.generateRandomToken();\n    const refreshKey = `refresh:${userId}:${this.hashToken(token)}`;\n\n    await this.redis.setex(refreshKey, this.refreshTtl, Date.now().toString());\n\n    logger.info('Refresh token created', { component: 'TokenService', userId });\n\n    return token;\n  }\n\n  /**\n   * 验证访问令牌\n   */\n  async verifyAccessToken(token: string): Promise<TokenPayload | null> {\n    await this.ensureRedisConnected();\n\n    try {\n      // JWT 验证\n      const payload = jwt.verify(token, this.secret) as TokenPayload;\n\n      // Redis 检查(支持主动撤销)\n      const tokenKey = `access:${payload.userId}:${this.hashToken(token)}`;\n      const exists = await this.redis.exists(tokenKey);\n\n      if (!exists) {\n        logger.warn('Token not found in Redis', {\n          component: 'TokenService',\n          userId: payload.userId,\n        });\n        return null;\n      }\n\n      // 更新最后访问时间\n      await this.updateLastAccessed(tokenKey);\n\n      return payload;\n    } catch (error) {\n      if (error instanceof jwt.JsonWebTokenError) {\n        logger.warn('Invalid JWT token', {\n          component: 'TokenService',\n          error: (error as Error).message,\n        });\n      } else if (error instanceof jwt.TokenExpiredError) {\n        logger.info('Token expired', {\n          component: 'TokenService',\n          expiredAt: (error).expiredAt,\n        });\n      } else {\n        logger.error('Token verification error', {\n          component: 'TokenService',\n          error,\n        });\n      }\n      return null;\n    }\n  }\n\n  /**\n   * 刷新访问令牌\n   */\n  async refreshAccessToken(\n    refreshToken: string,\n    userId: string,\n  ): Promise<{ accessToken: string; newRefreshToken: string } | null> {\n    await this.ensureRedisConnected();\n\n    const refreshKey = `refresh:${userId}:${this.hashToken(refreshToken)}`;\n    const exists = await this.redis.exists(refreshKey);\n\n    if (!exists) {\n      logger.warn('Refresh token not found', { component: 'TokenService', userId });\n      return null;\n    }\n\n    // 获取用户信息\n    const userInfo = await this.getUserInfo(userId);\n    if (!userInfo) {\n      logger.error('User not found during token refresh', {\n        component: 'TokenService',\n        userId,\n      });\n      return null;\n    }\n\n    // 创建新令牌对\n    const accessToken = await this.createAccessToken(userId, userInfo.username, userInfo.role);\n    const newRefreshToken = await this.createRefreshToken(userId);\n\n    // 撤销旧的刷新令牌\n    await this.redis.del(refreshKey);\n\n    logger.info('Tokens refreshed', { component: 'TokenService', userId });\n\n    return { accessToken, newRefreshToken };\n  }\n\n  /**\n   * 撤销用户所有令牌\n   */\n  async revokeAllTokens(userId: string): Promise<void> {\n    await this.ensureRedisConnected();\n\n    const pattern = `*:${userId}:*`;\n    const keys = await this.redis.keys(pattern);\n\n    if (keys.length > 0) {\n      await this.redis.del(...keys);\n      logger.info('All tokens revoked', {\n        component: 'TokenService',\n        userId,\n        count: keys.length,\n      });\n    }\n  }\n\n  /**\n   * 撤销单个令牌\n   */\n  async revokeToken(token: string, userId: string): Promise<void> {\n    await this.ensureRedisConnected();\n\n    const tokenKey = `access:${userId}:${this.hashToken(token)}`;\n    await this.redis.del(tokenKey);\n    logger.info('Token revoked', { component: 'TokenService', userId });\n  }\n\n  /**\n   * 获取活跃令牌列表\n   */\n  async getActiveTokens(userId: string): Promise<TokenMetadata[]> {\n    await this.ensureRedisConnected();\n\n    const pattern = `access:${userId}:*`;\n    const keys = await this.redis.keys(pattern);\n\n    const tokens: TokenMetadata[] = [];\n    for (const key of keys) {\n      const data = await this.redis.get(key);\n      if (data) {\n        tokens.push(JSON.parse(data) as TokenMetadata);\n      }\n    }\n\n    return tokens;\n  }\n\n  /**\n   * 辅助方法 - Token 散列\n   */\n  private hashToken(token: string): string {\n    return crypto.createHash('sha256').update(token).digest('hex');\n  }\n\n  /**\n   * 辅助方法 - 生成随机 Token\n   */\n  private generateRandomToken(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  /**\n   * 辅助方法 - 生成 JWT Secret\n   */\n  private generateSecret(): string {\n    const secret = crypto.randomBytes(64).toString('hex');\n    logger.warn('Using generated JWT secret. Set JWT_SECRET in production!', {\n      component: 'TokenService',\n    });\n    return secret;\n  }\n\n  /**\n   * 辅助方法 - 更新最后访问时间\n   */\n  private async updateLastAccessed(tokenKey: string): Promise<void> {\n    const data = await this.redis.get(tokenKey);\n    if (data) {\n      const metadata: TokenMetadata = JSON.parse(data);\n      metadata.lastAccessedAt = Math.floor(Date.now() / 1000);\n      const ttl = await this.redis.ttl(tokenKey);\n      if (ttl > 0) {\n        await this.redis.setex(tokenKey, ttl, JSON.stringify(metadata));\n      }\n    }\n  }\n\n  /**\n   * 辅助方法 - 从数据库获取用户信息\n   */\n  private async getUserInfo(\n    userId: string,\n  ): Promise<{ username: string; role: 'admin' | 'user' } | null> {\n    try {\n      const result = await this.pool.query(\n        'SELECT username, role FROM users WHERE id = $1',\n        [userId],\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const user = result.rows[0];\n      return {\n        username: user.username as string,\n        role: user.role as 'admin' | 'user',\n      };\n    } catch (error) {\n      logger.error('Failed to fetch user info from database', {\n        component: 'TokenService',\n        userId,\n        error,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * 清理过期令牌(定时任务)\n   */\n  async cleanupExpiredTokens(): Promise<number> {\n    await this.ensureRedisConnected();\n\n    const pattern = '*:*:*';\n    const keys = await this.redis.keys(pattern);\n\n    let cleaned = 0;\n    for (const key of keys) {\n      const ttl = await this.redis.ttl(key);\n      if (ttl < 0) {\n        await this.redis.del(key);\n        cleaned++;\n      }\n    }\n\n    if (cleaned > 0) {\n      logger.info('Cleaned up expired tokens', { component: 'TokenService', count: cleaned });\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * 关闭连接\n   */\n  async close(): Promise<void> {\n    await this.redis.quit();\n    logger.info('TokenService Redis connection closed', { component: 'TokenService' });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/analyticsInstance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/services/authInstance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/types/audit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/types/dynamic.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JsonValue' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UnknownValue' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 动态数据类型系统 - 根源性类型安全解决方案\n *\n * 📢 重构说明：所有核心类型现在从 @llmchat/shared-types 包导入\n * 🎯 目标：统一前后端类型定义，避免重复和不一致\n */\n\nimport type {\n  JsonArray,\n  JsonObject,\n  JsonValue,\n  UnknownValue,\n} from '@llmchat/shared-types';\n\n// 重新导出共享类型，保持向后兼容\nexport {\n  JsonObject,\n  JsonArray,\n  JsonValue,\n  UnknownValue,\n  DataPayload,\n  ApiRequestPayload,\n  ApiSuccessResponse,\n  ApiResponsePayload,\n  ExternalServiceResponse,\n  PaginationParams,\n  DateRangeParams,\n  SearchFilterParams,\n  QueryParams,\n  FastGPTEventPayload,\n  FastGPTReasoningData,\n  ReasoningStepUpdate,\n  ParsedReasoningUpdate,\n  FastGPTStreamEventType,\n  FastGPTEventMetadata,\n  FastGPTEvent,\n  DynamicTypeGuard,\n  DynamicDataConverter,\n  SafeAccess,\n} from '@llmchat/shared-types';\n\n// ============================================================================\n// 后端特有的扩展类型\n// ============================================================================\n\n/**\n * 后端API错误详情\n */\nexport interface ApiErrorDetails {\n  originalError?: string;\n  stack?: string;\n  context?: JsonObject;\n  errorId?: string;\n  component?: string;\n  operation?: string;\n  timestamp?: string;\n  userId?: string;\n  sessionId?: string;\n  requestId?: string;\n}\n\n/**\n * 后端API响应\n */\nexport interface ApiError {\n  code: string;\n  message: string;\n  category?: string;\n  severity?: string;\n  details?: JsonObject;\n  timestamp: string;\n  userId?: string;\n  requestId?: string;\n}\n\n/**\n * 错误严重性级别\n */\nexport type ErrorSeverity = 'low' | 'medium' | 'high' | 'critical';\n\n/**\n * 错误分类\n */\nexport type ErrorCategory =\n  | 'validation'\n  | 'authentication'\n  | 'authorization'\n  | 'permission'\n  | 'not_found'\n  | 'rate_limit'\n  | 'internal_server_error'\n  | 'service_unavailable'\n  | 'timeout'\n  | 'external_service';\n\n/**\n * 扩展的请求上下文\n */\nexport interface RequestContext {\n  requestId?: string;\n  userId?: string;\n  sessionId?: string;\n  userAgent?: string;\n  ip?: string;\n  method?: string;\n  url?: string;\n  timestamp?: number;\n  traceId?: string;\n}\n\n/**\n * 性能监控数据\n */\nexport interface PerformanceContext {\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n  memoryUsage?: {\n    rss: number;\n    heapUsed: number;\n    heapTotal: number;\n  };\n  cpuUsage?: number;\n}\n\n/**\n * 日志级别\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal';\n\n/**\n * 结构化日志数据\n */\nexport interface StructuredLog {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  requestId?: string;\n  userId?: string;\n  component?: string;\n  operation?: string;\n  context?: JsonObject;\n  error?: {\n    name: string;\n    message: string;\n    stack?: string;\n    code?: string;\n  };\n  performance?: PerformanceContext;\n}\n\n// ============================================================================\n// 向后兼容的类型别名\n// ============================================================================\n\n// 保持向后兼容性的别名\nexport type ConfigParameters = Record<string,\n  | string\n  | number\n  | boolean\n  | string[]\n  | number[]\n  | JsonObject\n  | JsonArray\n  | null\n>;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/types/errors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cause' is defined but never used. Allowed unused args must match /^_/u.","line":38,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'url' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1024,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1024,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'method' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1024,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":1024,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'statusCode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1024,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":1024,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'severity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1024,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":1024,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1024,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":1024,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requestId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1024,"column":58,"nodeType":"Identifier","messageId":"unusedVar","endLine":1024,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'field' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1062,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1062,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1062,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":1062,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'severity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1062,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":1062,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1062,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":1062,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requestId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1062,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":1062,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'severity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1091,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1091,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1091,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":1091,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requestId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1091,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":1091,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resource' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1128,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1128,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'action' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1128,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":1128,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'severity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1128,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":1128,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1128,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":1128,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requestId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1128,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":1128,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'component' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1168,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":1168,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'operation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1168,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":1168,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'severity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1168,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":1168,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1168,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":1168,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requestId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1168,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":1168,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalError' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1168,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":1168,"endColumn":77},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'comp' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1208,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":1208,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'oper' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1208,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":1208,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sev' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1208,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":1208,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uid' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1208,"column":68,"nodeType":"Identifier","messageId":"unusedVar","endLine":1208,"endColumn":71},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'rid' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1208,"column":84,"nodeType":"Identifier","messageId":"unusedVar","endLine":1208,"endColumn":87},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'origErr' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1208,"column":104,"nodeType":"Identifier","messageId":"unusedVar","endLine":1208,"endColumn":111},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1219,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1219,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28273,28276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28273,28276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 统一的错误处理类型系统\n *\n * 这个文件定义了项目中所有错误处理相关的类型，包括：\n * - 错误基类和具体错误类型\n * - 错误处理结果类型\n * - 安全的类型转换工具\n * - 错误边界处理\n */\n\nimport { JsonValue } from './dynamic';\n\n// ============================================================================\n// 错误基类和具体错误类型\n// ============================================================================\n\n/**\n * 基础错误类，所有自定义错误都应该继承此类\n */\nexport abstract class BaseError extends Error {\n  public readonly id: string;\n  public readonly code: string;\n  public readonly category: ErrorCategory;\n  public readonly severity: ErrorSeverity;\n  public readonly context?: JsonValue;\n  public readonly timestamp: string;\n  public readonly userId?: string;\n  public readonly requestId?: string;\n\n  constructor({\n    message,\n    code,\n    category,\n    severity = 'medium',\n    context,\n    userId,\n    requestId,\n    cause,\n  }: {\n    message: string;\n    code: string;\n    category: ErrorCategory;\n    severity?: ErrorSeverity;\n    context?: JsonValue;\n    userId?: string;\n    requestId?: string;\n    cause?: Error;\n  }) {\n    super(message);\n\n    // 生成唯一错误ID\n    this.id = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    this.name = this.constructor.name;\n    this.code = code;\n    this.category = category;\n    this.severity = severity;\n    if (context !== undefined) {\n      this.context = context;\n    }\n    this.timestamp = new Date().toISOString();\n    if (userId !== undefined) {\n      this.userId = userId;\n    }\n    if (requestId !== undefined) {\n      this.requestId = requestId;\n    }\n\n    // 确保错误堆栈正确显示\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  /**\n   * 转换为API错误响应格式\n   */\n  toApiError(): ApiError {\n    const result: ApiError = {\n      code: this.code,\n      message: this.message,\n      category: this.category,\n      severity: this.severity,\n      timestamp: this.timestamp,\n    };\n\n    if (this.context !== undefined) {\n      result.details = this.context;\n    }\n    if (this.userId !== undefined) {\n      result.userId = this.userId;\n    }\n    if (this.requestId !== undefined) {\n      result.requestId = this.requestId;\n    }\n\n    return result;\n  }\n\n  /**\n   * 获取用户友好的错误消息\n   */\n  getUserMessage(): string {\n    // 根据错误严重性和类别返回用户友好的消息\n    if (this.severity === 'critical') {\n      return '系统遇到严重错误，请稍后重试';\n    }\n\n    switch (this.category) {\n      case 'validation':\n        return '输入数据不正确，请检查后重试';\n      case 'authentication':\n        return '身份验证失败，请重新登录';\n      case 'authorization':\n        return '权限不足，无法执行此操作';\n      case 'network':\n        return '网络连接失败，请检查网络后重试';\n      case 'external_service':\n        return '外部服务暂时不可用，请稍后重试';\n      case 'resource':\n        return '资源不足或不存在，请稍后重试';\n      case 'business_logic':\n        return '操作无法完成，请检查输入条件';\n      case 'system':\n        return '系统内部错误，请稍后重试';\n      default:\n        return '发生未知错误，请稍后重试';\n    }\n  }\n\n  /**\n   * 序列化错误对象（用于日志记录）\n   */\n  toLogObject(): Record<string, unknown> {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      category: this.category,\n      severity: this.severity,\n      stack: this.stack,\n      context: this.context,\n      timestamp: this.timestamp,\n      userId: this.userId,\n      requestId: this.requestId,\n    };\n  }\n}\n\n/**\n * 错误类别枚举\n */\nexport type ErrorCategory =\n  | 'validation'       // 验证错误\n  | 'authentication'   // 身份验证错误\n  | 'authorization'    // 权限错误\n  | 'network'          // 网络错误\n  | 'external_service' // 外部服务错误\n  | 'resource'         // 资源错误\n  | 'business_logic'   // 业务逻辑错误\n  | 'system';          // 系统错误\n\n/**\n * 错误严重性级别\n */\nexport type ErrorSeverity = 'low' | 'medium' | 'high' | 'critical';\n\n/**\n * API错误响应接口\n */\nexport interface ApiError {\n  code: string;\n  message: string;\n  category?: ErrorCategory;\n  severity?: ErrorSeverity;\n  details?: JsonValue;\n  timestamp: string;\n  userId?: string;\n  requestId?: string;\n}\n\n// ============================================================================\n// 具体错误类定义\n// ============================================================================\n\n/**\n * 验证错误\n */\nexport class ValidationError extends BaseError {\n  constructor({\n    message,\n    code = 'VALIDATION_ERROR',\n    field,\n    value,\n    context,\n    severity = 'low',\n    userId,\n    requestId,\n  }: {\n    message: string;\n    code?: string;\n    field?: string;\n    value?: unknown;\n    context?: JsonValue;\n    severity?: ErrorSeverity;\n    userId?: string;\n    requestId?: string;\n  }) {\n    const superParams: {\n      message: string;\n      code: string;\n      category: ErrorCategory;\n      severity?: ErrorSeverity;\n      context?: JsonValue;\n      userId?: string;\n      requestId?: string;\n    } = {\n      message,\n      code,\n      category: 'validation',\n    };\n\n    if (severity !== undefined) {\n      superParams.severity = severity;\n    }\n    if (userId !== undefined) {\n      superParams.userId = userId;\n    }\n    if (requestId !== undefined) {\n      superParams.requestId = requestId;\n    }\n\n    if (field || value) {\n      const baseContext = context && typeof context === 'object' && !Array.isArray(context) ? context : {};\n      superParams.context = { field, value, ...baseContext } as JsonValue;\n    } else if (context) {\n      superParams.context = context;\n    }\n\n    super(superParams);\n  }\n}\n\n/**\n * 身份验证错误\n */\nexport class AuthenticationError extends BaseError {\n  constructor({\n    message = '身份验证失败',\n    code = 'AUTHENTICATION_ERROR',\n    severity = 'medium',\n    ...baseOptions\n  }: {\n    message?: string;\n    code?: string;\n    severity?: ErrorSeverity;\n  } & Omit<ConstructorParameters<typeof BaseError>[0], 'message' | 'code' | 'category' | 'severity'>) {\n    super({\n      message,\n      code,\n      category: 'authentication',\n      severity,\n      ...baseOptions,\n    });\n  }\n}\n\n/**\n * 权限错误\n */\nexport class AuthorizationError extends BaseError {\n  constructor({\n    message = '权限不足',\n    code = 'AUTHORIZATION_ERROR',\n    resource,\n    action,\n    context,\n    severity = 'medium',\n    userId,\n    requestId,\n  }: {\n    message?: string;\n    code?: string;\n    resource?: string;\n    action?: string;\n    context?: JsonValue;\n    severity?: ErrorSeverity;\n    userId?: string;\n    requestId?: string;\n  }) {\n    const superParams: {\n      message: string;\n      code: string;\n      category: ErrorCategory;\n      severity?: ErrorSeverity;\n      context?: JsonValue;\n      userId?: string;\n      requestId?: string;\n    } = {\n      message,\n      code,\n      category: 'authorization',\n    };\n\n    if (severity !== undefined) {\n      superParams.severity = severity;\n    }\n    if (userId !== undefined) {\n      superParams.userId = userId;\n    }\n    if (requestId !== undefined) {\n      superParams.requestId = requestId;\n    }\n\n    if (resource || action) {\n      const baseContext = context && typeof context === 'object' && !Array.isArray(context) ? context : {};\n      superParams.context = { resource, action, ...baseContext } as JsonValue;\n    } else if (context) {\n      superParams.context = context;\n    }\n\n    super(superParams);\n  }\n}\n\n/**\n * 网络错误\n */\nexport class NetworkError extends BaseError {\n  constructor({\n    message = '网络连接失败',\n    code = 'NETWORK_ERROR',\n    url,\n    method,\n    statusCode,\n    context,\n    severity = 'medium',\n    userId,\n    requestId,\n  }: {\n    message?: string;\n    code?: string;\n    url?: string;\n    method?: string;\n    statusCode?: number;\n    context?: JsonValue;\n    severity?: ErrorSeverity;\n    userId?: string;\n    requestId?: string;\n  }) {\n    const superParams: {\n      message: string;\n      code: string;\n      category: ErrorCategory;\n      severity?: ErrorSeverity;\n      context?: JsonValue;\n      userId?: string;\n      requestId?: string;\n    } = {\n      message,\n      code,\n      category: 'network',\n    };\n\n    if (severity !== undefined) {\n      superParams.severity = severity;\n    }\n    if (userId !== undefined) {\n      superParams.userId = userId;\n    }\n    if (requestId !== undefined) {\n      superParams.requestId = requestId;\n    }\n\n    if (url || method || statusCode) {\n      const baseContext = context && typeof context === 'object' && !Array.isArray(context) ? context : {};\n      superParams.context = { url, method, statusCode, ...baseContext } as JsonValue;\n    } else if (context) {\n      superParams.context = context;\n    }\n\n    super(superParams);\n  }\n}\n\n/**\n * 外部服务错误\n */\nexport class ExternalServiceError extends BaseError {\n  constructor({\n    message = '外部服务错误',\n    code = 'EXTERNAL_SERVICE_ERROR',\n    service,\n    endpoint,\n    originalError,\n    context,\n    severity = 'high',\n    userId,\n    requestId,\n  }: {\n    message?: string;\n    code?: string;\n    service?: string;\n    endpoint?: string;\n    originalError?: unknown;\n    context?: JsonValue;\n    severity?: ErrorSeverity;\n    userId?: string;\n    requestId?: string;\n  }) {\n    const superParams: {\n      message: string;\n      code: string;\n      category: ErrorCategory;\n      severity?: ErrorSeverity;\n      context?: JsonValue;\n      userId?: string;\n      requestId?: string;\n    } = {\n      message,\n      code,\n      category: 'external_service',\n    };\n\n    if (severity !== undefined) {\n      superParams.severity = severity;\n    }\n    if (userId !== undefined) {\n      superParams.userId = userId;\n    }\n    if (requestId !== undefined) {\n      superParams.requestId = requestId;\n    }\n\n    const baseContext = context && typeof context === 'object' && !Array.isArray(context) ? context : {};\n    superParams.context = {\n      service,\n      endpoint,\n      originalError: originalError instanceof Error ? {\n        message: originalError.message,\n        name: originalError.name,\n        ...(originalError.stack && { stack: originalError.stack }),\n      } : originalError,\n      ...baseContext,\n    } as JsonValue;\n\n    super(superParams);\n  }\n}\n\n/**\n * 资源错误\n */\nexport class ResourceError extends BaseError {\n  constructor({\n    message = '资源错误',\n    code = 'RESOURCE_ERROR',\n    resourceType,\n    resourceId,\n    operation,\n    context,\n    severity = 'medium',\n    userId,\n    requestId,\n  }: {\n    message?: string;\n    code?: string;\n    resourceType?: string;\n    resourceId?: string;\n    operation?: string;\n    context?: JsonValue;\n    severity?: ErrorSeverity;\n    userId?: string;\n    requestId?: string;\n  }) {\n    const superParams: {\n      message: string;\n      code: string;\n      category: ErrorCategory;\n      severity?: ErrorSeverity;\n      context?: JsonValue;\n      userId?: string;\n      requestId?: string;\n    } = {\n      message,\n      code,\n      category: 'resource',\n    };\n\n    if (severity !== undefined) {\n      superParams.severity = severity;\n    }\n    if (userId !== undefined) {\n      superParams.userId = userId;\n    }\n    if (requestId !== undefined) {\n      superParams.requestId = requestId;\n    }\n\n    if (resourceType || resourceId || operation) {\n      const baseContext = context && typeof context === 'object' && !Array.isArray(context) ? context : {};\n      superParams.context = { resourceType, resourceId, operation, ...baseContext } as JsonValue;\n    } else if (context) {\n      superParams.context = context;\n    }\n\n    super(superParams);\n  }\n}\n\n/**\n * 业务逻辑错误\n */\nexport class BusinessLogicError extends BaseError {\n  constructor({\n    message = '业务逻辑错误',\n    code = 'BUSINESS_LOGIC_ERROR',\n    rule,\n    data,\n    context,\n    severity = 'medium',\n    userId,\n    requestId,\n  }: {\n    message?: string;\n    code?: string;\n    rule?: string;\n    data?: unknown;\n    context?: JsonValue;\n    severity?: ErrorSeverity;\n    userId?: string;\n    requestId?: string;\n  }) {\n    const superParams: {\n      message: string;\n      code: string;\n      category: ErrorCategory;\n      severity?: ErrorSeverity;\n      context?: JsonValue;\n      userId?: string;\n      requestId?: string;\n    } = {\n      message,\n      code,\n      category: 'business_logic',\n    };\n\n    if (severity !== undefined) {\n      superParams.severity = severity;\n    }\n    if (userId !== undefined) {\n      superParams.userId = userId;\n    }\n    if (requestId !== undefined) {\n      superParams.requestId = requestId;\n    }\n\n    if (rule || data) {\n      const baseContext = context && typeof context === 'object' && !Array.isArray(context) ? context : {};\n      superParams.context = { rule, data, ...baseContext } as JsonValue;\n    } else if (context) {\n      superParams.context = context;\n    }\n\n    super(superParams);\n  }\n}\n\n/**\n * 系统错误\n */\nexport class SystemError extends BaseError {\n  constructor({\n    message = '系统内部错误',\n    code = 'SYSTEM_ERROR',\n    component,\n    operation,\n    originalError,\n    context,\n    severity = 'high',\n    userId,\n    requestId,\n  }: {\n    message?: string;\n    code?: string;\n    component?: string;\n    operation?: string;\n    originalError?: unknown;\n    context?: JsonValue;\n    severity?: ErrorSeverity;\n    userId?: string;\n    requestId?: string;\n  }) {\n    const superParams: {\n      message: string;\n      code: string;\n      category: ErrorCategory;\n      severity?: ErrorSeverity;\n      context?: JsonValue;\n      userId?: string;\n      requestId?: string;\n    } = {\n      message,\n      code,\n      category: 'system',\n    };\n\n    if (severity !== undefined) {\n      superParams.severity = severity;\n    }\n    if (userId !== undefined) {\n      superParams.userId = userId;\n    }\n    if (requestId !== undefined) {\n      superParams.requestId = requestId;\n    }\n\n    const baseContext = context && typeof context === 'object' && !Array.isArray(context) ? context : {};\n    superParams.context = {\n      component,\n      operation,\n      originalError: originalError instanceof Error ? {\n        message: originalError.message,\n        name: originalError.name,\n        ...(originalError.stack && { stack: originalError.stack }),\n      } : originalError,\n      ...baseContext,\n    } as JsonValue;\n\n    super(superParams);\n  }\n}\n\n// ============================================================================\n// 错误处理结果类型\n// ============================================================================\n\n/**\n * 结果类型，用于安全地处理可能失败的操作\n */\nexport type Result<T, E extends BaseError = BaseError> =\n  | { success: true; data: T }\n  | { success: false; error: E };\n\n/**\n * 创建成功结果\n */\nexport function createSuccess<T>(data: T): Result<T> {\n  return { success: true, data };\n}\n\n/**\n * 创建失败结果\n */\nexport function createFailure<E extends BaseError>(error: E): Result<never, E> {\n  return { success: false, error };\n}\n\n/**\n * 安全地执行可能抛出错误的函数\n */\nexport function safeExecute<T, E extends BaseError = BaseError>(\n  fn: () => T,\n  errorFactory?: (error: unknown) => E,\n): Result<T, E> {\n  try {\n    const data = fn();\n    return createSuccess(data) as Result<T, E>;\n  } catch (unknownError) {\n    if (errorFactory) {\n      return createFailure(errorFactory(unknownError));\n    }\n\n    if (unknownError instanceof BaseError) {\n      return createFailure(unknownError as E);\n    }\n\n    return createFailure(\n      new SystemError({\n        message: '未知错误',\n        originalError: unknownError,\n      }) as E,\n    );\n  }\n}\n\n/**\n * 安全地执行异步函数\n */\nexport async function safeExecuteAsync<T, E extends BaseError = BaseError>(\n  fn: () => Promise<T>,\n  errorFactory?: (error: unknown) => E,\n): Promise<Result<T, E>> {\n  try {\n    const data = await fn();\n    return createSuccess(data) as Result<T, E>;\n  } catch (unknownError) {\n    if (errorFactory) {\n      return createFailure(errorFactory(unknownError));\n    }\n\n    if (unknownError instanceof BaseError) {\n      return createFailure(unknownError as E);\n    }\n\n    return createFailure(\n      new SystemError({\n        message: '未知错误',\n        originalError: unknownError,\n      }) as E,\n    );\n  }\n}\n\n// ============================================================================\n// 安全的类型转换工具\n// ============================================================================\n\n/**\n * 安全的类型守卫工具\n */\nexport class TypeGuard {\n  /**\n   * 检查是否为字符串\n   */\n  static isString(value: unknown): value is string {\n    return typeof value === 'string';\n  }\n\n  /**\n   * 检查是否为数字\n   */\n  static isNumber(value: unknown): value is number {\n    return typeof value === 'number' && !isNaN(value);\n  }\n\n  /**\n   * 检查是否为布尔值\n   */\n  static isBoolean(value: unknown): value is boolean {\n    return typeof value === 'boolean';\n  }\n\n  /**\n   * 检查是否为对象（非null）\n   */\n  static isObject(value: unknown): value is Record<string, unknown> {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n  }\n\n  /**\n   * 检查是否为数组\n   */\n  static isArray<T>(value: unknown, guard?: (item: unknown) => item is T): value is T[] {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n    if (!guard) {\n      return true;\n    }\n    return value.every(guard);\n  }\n\n  /**\n   * 检查是否为函数\n   */\n  static isFunction<TReturn = unknown>(value: unknown): value is (...args: unknown[]) => TReturn {\n    return typeof value === 'function';\n  }\n\n  /**\n   * 检查是否为null或undefined\n   */\n  static isNullOrUndefined(value: unknown): value is null | undefined {\n    return value === null || value === undefined;\n  }\n\n  /**\n   * 检查是否为有效的日期\n   */\n  static isValidDate(value: unknown): value is Date {\n    return value instanceof Date && !isNaN(value.getTime());\n  }\n\n  /**\n   * 检查是否为有效的ISO日期字符串\n   */\n  static isISODateString(value: unknown): value is string {\n    if (!this.isString(value)) {\n      return false;\n    }\n    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/;\n    return isoRegex.test(value) && !isNaN(Date.parse(value));\n  }\n\n  /**\n   * 检查是否为Email格式\n   */\n  static isEmail(value: unknown): value is string {\n    if (!this.isString(value)) {\n      return false;\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(value);\n  }\n\n  /**\n   * 检查是否为URL格式\n   */\n  static isURL(value: unknown): value is string {\n    if (!this.isString(value)) {\n      return false;\n    }\n    try {\n      new URL(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * 检查对象是否具有指定的属性\n   */\n  static hasProperty<K extends string | number | symbol>(\n    obj: unknown,\n    key: K,\n  ): obj is Record<K, unknown> {\n    return this.isObject(obj) && key in obj;\n  }\n\n  /**\n   * 检查对象是否具有所有指定的属性\n   */\n  static hasProperties<T extends Record<string, unknown>>(\n    obj: unknown,\n    keys: (keyof T)[],\n  ): obj is T {\n    if (!this.isObject(obj)) {\n      return false;\n    }\n    return keys.every(key => key in obj);\n  }\n}\n\n/**\n * 安全的类型转换工具\n */\nexport class SafeCast {\n  /**\n   * 安全转换为字符串\n   */\n  static toString(value: unknown, defaultValue: string = ''): string {\n    if (TypeGuard.isString(value)) {\n      return value;\n    }\n    if (TypeGuard.isNumber(value) || TypeGuard.isBoolean(value)) {\n      return String(value);\n    }\n    return defaultValue;\n  }\n\n  /**\n   * 安全转换为数字\n   */\n  static toNumber(value: unknown, defaultValue: number = 0): number {\n    if (TypeGuard.isNumber(value)) {\n      return value;\n    }\n    if (TypeGuard.isString(value)) {\n      const parsed = Number(value);\n      return !isNaN(parsed) ? parsed : defaultValue;\n    }\n    return defaultValue;\n  }\n\n  /**\n   * 安全转换为布尔值\n   */\n  static toBoolean(value: unknown, defaultValue: boolean = false): boolean {\n    if (TypeGuard.isBoolean(value)) {\n      return value;\n    }\n    if (TypeGuard.isString(value)) {\n      return value.toLowerCase() === 'true';\n    }\n    if (TypeGuard.isNumber(value)) {\n      return value !== 0;\n    }\n    return defaultValue;\n  }\n\n  /**\n   * 安全转换为日期\n   */\n  static toDate(value: unknown, defaultValue: Date = new Date()): Date {\n    if (TypeGuard.isValidDate(value)) {\n      return value;\n    }\n    if (TypeGuard.isISODateString(value)) {\n      return new Date(value);\n    }\n    if (TypeGuard.isNumber(value)) {\n      return new Date(value);\n    }\n    return defaultValue;\n  }\n\n  /**\n   * 安全转换为对象\n   */\n  static toObject<T extends Record<string, unknown>>(\n    value: unknown,\n    defaultValue: T = {} as T,\n  ): T {\n    if (TypeGuard.isObject(value)) {\n      return value as T;\n    }\n    return defaultValue;\n  }\n\n  /**\n   * 安全转换为数组\n   */\n  static toArray<T>(\n    value: unknown,\n    guard?: (item: unknown) => item is T,\n    defaultValue: T[] = [],\n  ): T[] {\n    if (TypeGuard.isArray(value, guard)) {\n      return value;\n    }\n    return defaultValue;\n  }\n\n  /**\n   * 安全地从对象中获取属性值\n   */\n  static getProperty<T>(\n    obj: unknown,\n    key: string,\n    guard: (value: unknown) => value is T,\n    defaultValue: T,\n  ): T {\n    if (TypeGuard.hasProperty(obj, key)) {\n      const value = obj[key];\n      if (guard(value)) {\n        return value;\n      }\n    }\n    return defaultValue;\n  }\n}\n\n// ============================================================================\n// 错误处理工具函数\n// ============================================================================\n\n/**\n * 错误处理工厂，根据未知错误创建适当的错误类型\n */\nexport function createErrorFromUnknown(error: unknown, context?: {\n  userId?: string;\n  requestId?: string;\n  component?: string;\n  url?: string;\n  method?: string;\n  statusCode?: number;\n  field?: string;\n  value?: unknown;\n  resource?: string;\n  action?: string;\n  operation?: string;\n  severity?: ErrorSeverity;\n  // 额外的上下文属性，用于控制器和中间件\n  agentId?: string;\n  sessionId?: string;\n  originalError?: string;\n  stack?: string;\n  [key: string]: unknown; // 允许其他自定义属性\n}): BaseError {\n  if (error instanceof BaseError) {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    // 根据错误消息判断错误类型\n    const message = error.message.toLowerCase();\n\n    if (message.includes('network') || message.includes('timeout') || message.includes('fetch')) {\n      const networkParams: {\n        message?: string;\n        code?: string;\n        url?: string;\n        method?: string;\n        statusCode?: number;\n        context?: JsonValue;\n        severity?: ErrorSeverity;\n        userId?: string;\n        requestId?: string;\n      } = {\n        message: error.message,\n      };\n\n      if (context?.url !== undefined) {\n        networkParams.url = context.url;\n      }\n      if (context?.method !== undefined) {\n        networkParams.method = context.method;\n      }\n      if (context?.statusCode !== undefined) {\n        networkParams.statusCode = context.statusCode;\n      }\n      if (context?.severity !== undefined) {\n        networkParams.severity = context.severity;\n      }\n      if (context?.userId !== undefined) {\n        networkParams.userId = context.userId;\n      }\n      if (context?.requestId !== undefined) {\n        networkParams.requestId = context.requestId;\n      }\n\n      const { url, method, statusCode, severity, userId, requestId, ...restContext } = context || {};\n      if (Object.keys(restContext || {}).length > 0) {\n        networkParams.context = restContext as JsonValue;\n      }\n\n      return new NetworkError(networkParams);\n    }\n\n    if (message.includes('validation') || message.includes('invalid')) {\n      const validationParams: {\n        message: string;\n        code?: string;\n        field?: string;\n        value?: unknown;\n        context?: JsonValue;\n        severity?: ErrorSeverity;\n        userId?: string;\n        requestId?: string;\n      } = {\n        message: error.message,\n      };\n\n      if (context?.field !== undefined) {\n        validationParams.field = context.field;\n      }\n      if (context?.value !== undefined) {\n        validationParams.value = context.value;\n      }\n      if (context?.severity !== undefined) {\n        validationParams.severity = context.severity;\n      }\n      if (context?.userId !== undefined) {\n        validationParams.userId = context.userId;\n      }\n      if (context?.requestId !== undefined) {\n        validationParams.requestId = context.requestId;\n      }\n\n      const { field, value, severity, userId, requestId, ...restContext } = context || {};\n      if (Object.keys(restContext || {}).length > 0) {\n        validationParams.context = restContext as JsonValue;\n      }\n\n      return new ValidationError(validationParams);\n    }\n\n    if (message.includes('unauthorized') || message.includes('auth')) {\n      const authParams: {\n        message: string;\n        code?: string;\n        severity?: ErrorSeverity;\n        userId?: string;\n        requestId?: string;\n      } & Omit<ConstructorParameters<typeof AuthenticationError>[0], 'message' | 'code' | 'category' | 'severity'> = {\n        message: error.message,\n      };\n\n      if (context?.severity !== undefined) {\n        authParams.severity = context.severity;\n      }\n      if (context?.userId !== undefined) {\n        authParams.userId = context.userId;\n      }\n      if (context?.requestId !== undefined) {\n        authParams.requestId = context.requestId;\n      }\n\n      const { severity, userId, requestId, ...restContext } = context || {};\n      return new AuthenticationError({\n        ...authParams,\n        ...restContext,\n      });\n    }\n\n    if (message.includes('forbidden') || message.includes('permission')) {\n      const authzParams: {\n        message?: string;\n        code?: string;\n        resource?: string;\n        action?: string;\n        context?: JsonValue;\n        severity?: ErrorSeverity;\n        userId?: string;\n        requestId?: string;\n      } = {\n        message: error.message,\n      };\n\n      if (context?.resource !== undefined) {\n        authzParams.resource = context.resource;\n      }\n      if (context?.action !== undefined) {\n        authzParams.action = context.action;\n      }\n      if (context?.severity !== undefined) {\n        authzParams.severity = context.severity;\n      }\n      if (context?.userId !== undefined) {\n        authzParams.userId = context.userId;\n      }\n      if (context?.requestId !== undefined) {\n        authzParams.requestId = context.requestId;\n      }\n\n      const { resource, action, severity, userId, requestId, ...restContext } = context || {};\n      if (Object.keys(restContext || {}).length > 0) {\n        authzParams.context = restContext as JsonValue;\n      }\n\n      return new AuthorizationError(authzParams);\n    }\n\n    // 默认为系统错误\n    const systemParams: {\n      message?: string;\n      code?: string;\n      component?: string;\n      operation?: string;\n      originalError?: unknown;\n      context?: JsonValue;\n      severity?: ErrorSeverity;\n      userId?: string;\n      requestId?: string;\n    } = {\n      message: error.message,\n      originalError: error,\n    };\n\n    if (context?.component !== undefined) {\n      systemParams.component = context.component;\n    }\n    if (context?.operation !== undefined) {\n      systemParams.operation = context.operation;\n    }\n    if (context?.severity !== undefined) {\n      systemParams.severity = context.severity;\n    }\n    if (context?.userId !== undefined) {\n      systemParams.userId = context.userId;\n    }\n    if (context?.requestId !== undefined) {\n      systemParams.requestId = context.requestId;\n    }\n\n    const { component, operation, severity, userId, requestId, originalError, ...restContext } = context || {};\n    if (Object.keys(restContext || {}).length > 0) {\n      systemParams.context = restContext as JsonValue;\n    }\n\n    return new SystemError(systemParams);\n  }\n\n  // 非Error类型的未知错误\n  const unknownSystemParams: {\n    message?: string;\n    code?: string;\n    component?: string;\n    operation?: string;\n    originalError?: unknown;\n    context?: JsonValue;\n    severity?: ErrorSeverity;\n    userId?: string;\n    requestId?: string;\n  } = {\n    message: '未知错误',\n    originalError: error,\n  };\n\n  if (context?.component !== undefined) {\n    unknownSystemParams.component = context.component;\n  }\n  if (context?.operation !== undefined) {\n    unknownSystemParams.operation = context.operation;\n  }\n  if (context?.severity !== undefined) {\n    unknownSystemParams.severity = context.severity;\n  }\n  if (context?.userId !== undefined) {\n    unknownSystemParams.userId = context.userId;\n  }\n  if (context?.requestId !== undefined) {\n    unknownSystemParams.requestId = context.requestId;\n  }\n\n  const { component: comp, operation: oper, severity: sev, userId: uid, requestId: rid, originalError: origErr, ...restContextUnknown } = context || {};\n  if (Object.keys(restContextUnknown || {}).length > 0) {\n    unknownSystemParams.context = restContextUnknown as JsonValue;\n  }\n\n  return new SystemError(unknownSystemParams);\n}\n\n/**\n * 包装Express路由处理器的错误处理函数\n */\nexport function wrapAsyncHandler<T extends any[], R>(\n  handler: (...args: T) => Promise<R>,\n  options?: {\n    userId?: string;\n    requestId?: string;\n    component?: string;\n  },\n) {\n  return async (...args: T): Promise<R> => {\n    try {\n      return await handler(...args);\n    } catch (error) {\n      const typedError = createErrorFromUnknown(error, options);\n      throw typedError;\n    }\n  };\n}\n\n/**\n * 创建标准的错误响应\n */\nexport function createErrorResponse(error: BaseError): {\n  status: number;\n  body: ApiError;\n} {\n  const statusMap: Record<ErrorCategory, number> = {\n    validation: 400,\n    authentication: 401,\n    authorization: 403,\n    network: 503,\n    external_service: 502,\n    resource: 404,\n    business_logic: 422,\n    system: 500,\n  };\n\n  return {\n    status: statusMap[error.category] || 500,\n    body: error.toApiError(),\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/types/express.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[262,265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[262,265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[281,284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[281,284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[299,302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[299,302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Express类型扩展\n */\nimport { ProtectedRequestContext } from '@/services/ProtectionService';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      requestId?: string;\n      protectionContext?: ProtectedRequestContext;\n      protectionService?: any;\n      audit?: any;\n      user?: any;\n    }\n  }\n}\n\nexport {};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/types/geoip-lite.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/types/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3004,3007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3004,3007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3051,3054],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3051,3054],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5119,5122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5119,5122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":275,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":275,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5486,5489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5486,5489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":288,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5769,5772],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5769,5772],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6036,6039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6036,6039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":315,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6287,6290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6287,6290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":326,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6510,6513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6510,6513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":353,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7031,7034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7031,7034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":434,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8466,8469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8466,8469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":435,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":435,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8485,8488],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8485,8488],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":441,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8641,8644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8641,8644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// 使用shared-types中的JsonValue，避免循环依赖\nimport type { JsonValue, JsonObject } from '@llmchat/shared-types';\n\n// 重新导出 JsonValue 以便其他模块使用\nexport type { JsonValue, JsonObject };\nimport type { ErrorCategory, ErrorSeverity } from './errors';\n\n/**\n * API响应接口\n */\nexport interface ApiResponse<T = JsonValue> {\n  code: number;\n  message: string;\n  data: T;\n  success?: boolean;\n}\n\n/**\n * 智能体配置接口\n */\nexport interface AgentConfig {\n  id: string;\n  name: string;\n  description: string;\n  endpoint: string;\n  apiKey: string;\n  model: string;\n  appId?: string; // FastGPT 应用的真实 ObjectId（仅 provider=fastgpt 需要）\n  maxTokens?: number;\n  temperature?: number;\n  systemPrompt?: string;\n  capabilities: string[];\n  rateLimit?: {\n    requestsPerMinute: number;\n    tokensPerMinute: number;\n  };\n  provider: 'fastgpt' | 'openai' | 'anthropic' | 'dify' | 'dashscope' | 'custom';\n  type?: string;\n  isActive: boolean;\n  features: {\n    supportsChatId: boolean;\n    supportsStream: boolean;\n    supportsDetail: boolean;\n    supportsFiles: boolean;\n    supportsImages: boolean;\n    streamingConfig: {\n      enabled: boolean;\n      endpoint: 'same' | 'different';\n      statusEvents: boolean;\n      flowNodeStatus: boolean;\n    };\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * 智能体状态\n */\nexport type AgentStatus = 'active' | 'inactive' | 'error' | 'loading';\n\n/**\n * 简化的智能体信息（用于前端显示）\n */\nexport interface Agent {\n  id: string;\n  name: string;\n  description: string;\n  avatar?: string;\n  model: string;\n  status: AgentStatus;\n  capabilities: string[];\n  provider: string;\n}\n\n/**\n * 聊天消息接口\n */\nexport interface ChatMessage {\n  id?: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  timestamp?: number;\n  attachments?: ChatAttachmentMetadata[];\n  voiceNote?: VoiceNoteMetadata | null;\n  metadata?: {\n    model?: string;\n    tokens?: number;\n    provider?: string;\n    attachments?: ChatAttachmentMetadata[];\n    voiceNote?: VoiceNoteMetadata | null;\n  };\n}\n\n/**\n * 聊天选项\n */\nexport interface ChatOptions {\n  stream?: boolean;\n  chatId?: string;\n  detail?: boolean;\n  temperature?: number;\n  maxTokens?: number;\n  noCache?: boolean;                 // 禁用缓存\n  // FastGPT 特有参数\n  variables?: Record<string, JsonValue>; // 模块变量，会替换模块中输入框内容里的 [key]\n  responseChatItemId?: string;     // 响应消息的 ID，FastGPT 会自动将该 ID 存入数据库\n  attachments?: ChatAttachmentMetadata[];\n  voiceNote?: VoiceNoteMetadata | null;\n  // Dify 特有参数\n  userId?: string;                 // 用户标识，用于区分不同用户\n  files?: Array<{                  // 文件列表\n    type?: string;\n    transfer_method?: string;\n    url: string;\n  }>;\n}\n\n/**\n * 聊天响应\n */\nexport interface ChatResponse {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: Array<{\n    index: number;\n    message: ChatMessage;\n    finish_reason: string;\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n  // Provider 特有元数据\n  metadata?: {\n    conversation_id?: string;        // Dify: 会话 ID\n    retriever_resources?: any[];     // Dify: 知识库检索结果\n    [key: string]: any;              // 其他 Provider 特有字段\n  };\n}\n\n/**\n * 流式响应状态\n */\nexport interface StreamStatus {\n  type: 'flowNodeStatus' | 'progress' | 'error' | 'complete';\n  status: 'running' | 'completed' | 'error';\n  moduleName?: string;\n  progress?: number;\n  error?: string;\n}\n\n/**\n * 聊天请求\n */\nexport interface ChatRequest {\n  agentId: string;\n  messages: ChatMessage[];\n  stream?: boolean;\n  options?: ChatOptions;\n  chatId?: string;\n  detail?: boolean;\n  temperature?: number;\n  maxTokens?: number;\n  variables?: Record<string, JsonValue>;\n  responseChatItemId?: string;\n  attachments?: ChatAttachmentMetadata[];\n  voiceNote?: VoiceNoteMetadata | null;\n}\n\n/**\n * 反馈请求\n */\nexport interface FeedbackRequest {\n  agentId: string;\n  chatId: string;\n  dataId: string;\n  userGoodFeedback?: boolean | undefined;\n  userBadFeedback?: boolean | undefined;\n}\n\n/**\n * API错误响应\n */\nexport interface ApiError {\n  code: string;\n  message: string;\n  category?: ErrorCategory;\n  severity?: ErrorSeverity;\n  details?: JsonValue;\n  timestamp: string;\n  userId?: string;\n  requestId?: string;\n}\n\n/**\n * 智能体健康检查响应\n */\nexport interface AgentHealthStatus {\n  agentId: string;\n  status: AgentStatus;\n  responseTime?: number;\n  lastChecked: string;\n  error?: string;\n}\n\n/**\n * 请求头类型\n */\nexport interface RequestHeaders {\n  authorization?: string;\n  'content-type'?: string;\n  'user-agent'?: string;\n  [key: string]: string | undefined;\n}\n\n/**\n * 聊天会话\n */\nexport interface ChatSession {\n  id: string;\n  title: string;\n  agentId: string;\n  messages: ChatMessage[];\n  createdAt: number;\n  updatedAt: number;\n  metadata?: {\n    totalTokens: number;\n    messageCount: number;\n  };\n}\n\nexport interface ChatAttachmentMetadata {\n  id: string;\n  url: string;\n  name: string;\n  size: number;\n  mimeType: string;\n  source?: 'upload' | 'voice' | 'external';\n}\n\nexport interface VoiceNoteMetadata {\n  id: string;\n  url: string;\n  duration: number;\n  mimeType: string;\n  size?: number;\n}\n\n/**\n * FastGPT初始化响应接口\n */\nexport interface FastGPTInitResponse {\n  chatId: string;\n  appId: string;\n  variables: Record<string, any>;\n  app: {\n    chatConfig: {\n      questionGuide: boolean;\n      ttsConfig: { type: string };\n      whisperConfig: {\n        open: boolean;\n        autoSend: boolean;\n        autoTTSResponse: boolean\n      };\n      chatInputGuide: {\n        open: boolean;\n        textList: string[];\n        customUrl: string\n      };\n      instruction: string;\n      variables: any[];\n      fileSelectConfig: {\n        canSelectFile: boolean;\n        canSelectImg: boolean;\n        maxFiles: number\n      };\n      welcomeText: string;\n    };\n    chatModels: string[];\n    name: string;\n    avatar: string;\n    intro: string;\n    type: string;\n    pluginInputs: any[];\n  };\n}\n\n/**\n * FastGPT 会话摘要\n */\nexport interface FastGPTChatHistorySummary {\n  chatId: string;\n  appId?: string | undefined;\n  title: string;\n  createdAt: string;\n  updatedAt: string;\n  messageCount?: number | undefined;\n  tags?: string[] | undefined;\n  raw?: any;\n}\n\n/**\n * FastGPT 历史消息\n */\nexport interface FastGPTChatHistoryMessage {\n  id?: string | undefined;\n  dataId?: string | undefined;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  feedback?: 'good' | 'bad' | null | undefined;\n  raw?: any;\n}\n\n/**\n * FastGPT 会话详情\n */\nexport interface FastGPTChatHistoryDetail {\n  chatId: string;\n  appId?: string | undefined;\n  title?: string | undefined;\n  messages: FastGPTChatHistoryMessage[];\n  metadata?: Record<string, any> | undefined;\n  sessionInfo?: {\n    userId?: string | null;\n  };\n}\n\nexport interface ProductPreviewBoundingBox {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface ProductPreviewRequest {\n  sceneImage: string;\n  productImage?: string;\n  productQuery: string;\n  personalization?: string;\n  boundingBox: ProductPreviewBoundingBox;\n}\n\nexport interface ProductPreviewResult {\n  requestId?: string;\n  traceId?: string;\n  previewImage?: string;\n  imageUrl?: string;\n  status?: string;\n  raw?: any;\n}\n\n/**\n * 增强的会话过滤和查询参数\n */\nexport interface SessionListParams {\n  page?: number;\n  pageSize?: number;\n  startDate?: string; // ISO 8601 日期字符串\n  endDate?: string;   // ISO 8601 日期字符串\n  tags?: string[];    // 标签过滤\n  minMessageCount?: number;\n  maxMessageCount?: number;\n  sortBy?: 'createdAt' | 'updatedAt' | 'messageCount' | 'title';\n  sortOrder?: 'asc' | 'desc';\n  searchKeyword?: string; // 在标题和内容中搜索\n}\n\n/**\n * 分页响应\n */\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n  totalPages: number;\n  hasNext: boolean;\n  hasPrev: boolean;\n}\n\n/**\n * 批量操作选项\n */\nexport interface BatchOperationOptions {\n  sessionIds: string[];\n  operation: 'delete' | 'archive' | 'addTags' | 'removeTags';\n  tags?: string[]; // 用于标签操作\n}\n\n/**\n * 会话导出选项\n */\nexport interface ExportOptions {\n  format: 'json' | 'csv' | 'excel';\n  includeMessages?: boolean;\n  includeMetadata?: boolean;\n  filters?: SessionListParams;\n  dateRange?: {\n    start: string;\n    end: string;\n  };\n}\n\n/**\n * 会话事件类型\n */\nexport type SessionEventType =\n  | 'created'\n  | 'updated'\n  | 'deleted'\n  | 'archived'\n  | 'restored'\n  | 'feedback_added'\n  | 'feedback_updated'\n  | 'message_added'\n  | 'tags_updated'\n  | 'exported';\n\n/**\n * 会话事件记录\n */\nexport interface SessionEvent {\n  id: string;\n  sessionId: string;\n  agentId: string;\n  eventType: SessionEventType;\n  timestamp: string;\n  userId?: string;\n  metadata?: {\n    oldData?: any;\n    newData?: any;\n    reason?: string;\n    feedbackType?: 'good' | 'bad';\n    feedbackValue?: string;\n    tags?: string[];\n    exportFormat?: string;\n    [key: string]: any;\n  };\n  userAgent?: string;\n  ipAddress?: string;\n}\n\n/**\n * 事件查询参数\n */\nexport interface EventQueryParams {\n  sessionIds?: string[];\n  agentId?: string;\n  eventTypes?: SessionEventType[];\n  startDate?: string;\n  endDate?: string;\n  userId?: string;\n  page?: number;\n  pageSize?: number;\n  sortBy?: 'timestamp';\n  sortOrder?: 'asc' | 'desc';\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/types/provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/StructuredLogger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":373,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":373,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8323,8326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8323,8326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":373,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":373,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8354,8357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8354,8357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import winston from 'winston';\nimport path from 'path';\nimport { Request } from 'express';\nimport { JsonValue } from '@llmchat/shared-types';\n\n/**\n * 日志级别\n */\nexport type LogLevel = 'error' | 'warn' | 'info' | 'http' | 'verbose' | 'debug' | 'silly';\n\n/**\n * 错误信息结构\n */\nexport interface ErrorInfo {\n  name: string;\n  message: string;\n  stack?: string;\n  code?: string;\n}\n\n/**\n * 性能信息结构\n */\nexport interface PerformanceInfo {\n  memoryUsage?: NodeJS.MemoryUsage;\n  cpuUsage?: NodeJS.CpuUsage;\n  operation?: string;\n  duration?: number;\n}\n\n/**\n * 业务信息结构\n */\nexport interface BusinessInfo {\n  agentId?: string;\n  chatId?: string;\n  action?: string;\n  sessionId?: string;\n  [key: string]: JsonValue;\n}\n\n/**\n * 安全信息结构\n */\nexport interface SecurityInfo {\n  ip?: string;\n  userAgent?: string;\n  suspicious?: boolean;\n  threat?: string;\n  event?: string;\n  userId?: string;\n}\n\n/**\n * 结构化日志上下文 - 完全类型安全\n */\nexport interface LogContext {\n  // 请求上下文\n  requestId?: string;\n  userId?: string;\n  method?: string;\n  url?: string;\n  statusCode?: number;\n  duration?: number;\n  ip?: string;    // IP地址\n  origin?: string; // 来源地址\n\n  // 错误上下文\n  error?: ErrorInfo;\n\n  // 性能上下文\n  performance?: PerformanceInfo;\n\n  // 业务上下文\n  business?: BusinessInfo;\n\n  // 安全上下文\n  security?: SecurityInfo;\n\n  // 扩展的安全上下文\n  userAgent?: string;\n  contentLength?: number;\n  allowedOrigins?: string[];\n\n  // 自定义扩展上下文 - 类型安全\n  custom?: Record<string, JsonValue>;\n}\n\n/**\n * 日志条目\n */\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  context: LogContext;\n  service: string;\n  version: string;\n  environment: string;\n}\n\n/**\n * 结构化日志记录器\n */\nexport class StructuredLogger {\n  private logger: winston.Logger;\n  private serviceName: string;\n  private version: string;\n  private environment: string;\n\n  constructor(serviceName: string = 'llmchat-backend') {\n    this.serviceName = serviceName;\n    this.version = process.env.npm_package_version || '1.0.0';\n    this.environment = process.env.NODE_ENV || 'development';\n\n    // 创建Winston logger\n    this.logger = winston.createLogger({\n      level: this.getLogLevel(),\n      format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.errors({ stack: true }),\n        winston.format.json(),\n        winston.format.printf(this.formatLogEntry.bind(this)),\n      ),\n      defaultMeta: {\n        service: this.serviceName,\n        version: this.version,\n        environment: this.environment,\n      },\n      transports: [\n        // 控制台输出\n        new winston.transports.Console({\n          format: winston.format.combine(\n            winston.format.colorize(),\n            winston.format.simple(),\n            winston.format.printf(this.formatConsoleLog.bind(this)),\n          ),\n        }),\n\n        // 错误日志文件\n        new winston.transports.File({\n          filename: path.join(process.cwd(), 'logs', 'error.log'),\n          level: 'error',\n          maxsize: 5242880, // 5MB\n          maxFiles: 5,\n          format: winston.format.combine(\n            winston.format.timestamp(),\n            winston.format.json(),\n          ),\n        }),\n\n        // 组合日志文件\n        new winston.transports.File({\n          filename: path.join(process.cwd(), 'logs', 'combined.log'),\n          maxsize: 5242880, // 5MB\n          maxFiles: 5,\n          format: winston.format.combine(\n            winston.format.timestamp(),\n            winston.format.json(),\n          ),\n        }),\n      ],\n\n      // 异常处理\n      exceptionHandlers: [\n        new winston.transports.File({\n          filename: path.join(process.cwd(), 'logs', 'exceptions.log'),\n        }),\n      ],\n\n      // 拒绝处理\n      rejectionHandlers: [\n        new winston.transports.File({\n          filename: path.join(process.cwd(), 'logs', 'rejections.log'),\n        }),\n      ],\n    });\n  }\n\n  /**\n   * 获取日志级别\n   */\n  private getLogLevel(): string {\n    const envLevel = process.env.LOG_LEVEL;\n    const validLevels = ['error', 'warn', 'info', 'http', 'verbose', 'debug', 'silly'];\n    return validLevels.includes(envLevel as string) ? envLevel as string : 'info';\n  }\n\n  /**\n   * 格式化日志条目\n   */\n  private formatLogEntry(info: winston.Logform.TransformableInfo): string {\n    const { level, message, timestamp, service, version, environment, ...meta } = info;\n\n    const logEntry: LogEntry = {\n      level: level as LogLevel,\n      message: String(message),\n      timestamp: String(timestamp),\n      context: meta as LogContext,\n      service: String(service),\n      version: String(version),\n      environment: String(environment),\n    };\n\n    return JSON.stringify(logEntry);\n  }\n\n  /**\n   * 格式化控制台日志\n   */\n  private formatConsoleLog(info: winston.Logform.TransformableInfo): string {\n    const { timestamp, level, message, requestId, method, url, statusCode, duration, userId } = info;\n\n    let output = `${timestamp} [${level.toUpperCase()}]`;\n\n    if (requestId) {\n      output += ` [${requestId}]`;\n    }\n    if (userId) {\n      output += ` [user:${userId}]`;\n    }\n\n    output += `: ${message}`;\n\n    if (method && url) {\n      output += ` ${method} ${url}`;\n      if (statusCode) {\n        output += ` -> ${statusCode}`;\n      }\n      if (typeof duration === 'number') {\n        output += ` (${duration.toFixed(2)}ms)`;\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * 记录错误\n   */\n  public error(message: string, context: LogContext = {}): void {\n    this.logger.error(message, context);\n  }\n\n  /**\n   * 记录警告\n   */\n  public warn(message: string, context: LogContext = {}): void {\n    this.logger.warn(message, context);\n  }\n\n  /**\n   * 记录信息\n   */\n  public info(message: string, context: LogContext = {}): void {\n    this.logger.info(message, context);\n  }\n\n  /**\n   * 记录HTTP请求\n   */\n  public http(message: string, context: LogContext = {}): void {\n    this.logger.http(message, context);\n  }\n\n  /**\n   * 记录详细信息\n   */\n  public verbose(message: string, context: LogContext = {}): void {\n    this.logger.verbose(message, context);\n  }\n\n  /**\n   * 记录调试信息\n   */\n  public debug(message: string, context: LogContext = {}): void {\n    this.logger.debug(message, context);\n  }\n\n  /**\n   * 记录详细调试信息\n   */\n  public silly(message: string, context: LogContext = {}): void {\n    this.logger.silly(message, context);\n  }\n\n  /**\n   * 记录HTTP请求开始\n   */\n  public logRequestStart(req: Request): void {\n    // 类型安全的请求扩展接口\n    interface EnhancedRequest extends Request {\n      requestId?: string;\n      user?: { id: string };\n    }\n\n    const enhancedReq = req as EnhancedRequest;\n    const requestId = enhancedReq.requestId;\n    const userId = enhancedReq.user?.id;\n    const userAgent = req.get('User-Agent');\n    const ip = req.ip || req.connection.remoteAddress;\n\n    const securityContext: SecurityInfo = {};\n    if (userAgent) {\n      securityContext.userAgent = userAgent;\n    }\n    if (ip) {\n      securityContext.ip = ip;\n    }\n    if (userId) {\n      securityContext.userId = userId;\n    }\n\n    const context: LogContext = {\n      method: req.method,\n      url: req.originalUrl || req.url,\n      ...(Object.keys(securityContext).length > 0 && { security: securityContext }),\n    };\n\n    if (requestId) {\n      context.requestId = requestId;\n    }\n\n    this.http('Request started', context);\n  }\n\n  /**\n   * 记录HTTP请求完成\n   */\n  public logRequestComplete(req: Request, statusCode: number, duration: number): void {\n    // 类型安全的请求扩展接口\n    interface EnhancedRequest extends Request {\n      requestId?: string;\n      user?: { id: string };\n    }\n\n    const enhancedReq = req as EnhancedRequest;\n    const requestId = enhancedReq.requestId;\n    const userId = enhancedReq.user?.id;\n\n    const context: LogContext = {\n      method: req.method,\n      url: req.originalUrl || req.url,\n      statusCode,\n      duration,\n    };\n\n    if (requestId) {\n      context.requestId = requestId;\n    }\n    if (userId) {\n      context.userId = userId;\n    }\n\n    this.http('Request completed', context);\n  }\n\n  /**\n   * 记录API错误\n   */\n  public logApiError(error: Error, req?: Request, context?: LogContext): void {\n    // 类型安全的请求扩展接口\n    interface EnhancedRequest extends Request {\n      requestId?: string;\n      user?: { id: string };\n    }\n\n    const enhancedReq = req as EnhancedRequest;\n    const errorInfo: ErrorInfo = {\n      name: error.name,\n      message: error.message,\n      ...(error.stack && { stack: error.stack }),\n      ...((error as any).code && { code: (error as any).code }),\n    };\n\n    const errorContext: LogContext = {\n      error: errorInfo,\n      ...(req && { requestId: enhancedReq.requestId }),\n      ...(req?.method && { method: req.method }),\n      ...(req && { url: req.originalUrl || req.url }),\n      ...(req && enhancedReq.user?.id && { userId: enhancedReq.user.id }),\n      ...context,\n    };\n\n    this.error('API error occurred', errorContext);\n  }\n\n  /**\n   * 记录业务事件\n   */\n  public logBusinessEvent(event: string, context: LogContext = {}): void {\n    this.info(`Business event: ${event}`, {\n      business: {\n        event,\n        ...context.business,\n      },\n      ...context,\n    });\n  }\n\n  /**\n   * 记录安全事件\n   */\n  public logSecurityEvent(event: string, context: LogContext = {}): void {\n    const { security, ...restContext } = context;\n    this.warn(`Security event: ${event}`, {\n      security: {\n        event,\n        ...security,\n      },\n      ...restContext,\n    });\n  }\n\n  /**\n   * 记录性能指标\n   */\n  public logPerformance(operation: string, duration: number, context: LogContext = {}): void {\n    const { performance, ...restContext } = context;\n    this.info(`Performance: ${operation}`, {\n      performance: {\n        operation,\n        duration,\n        memoryUsage: process.memoryUsage(),\n        ...performance,\n      },\n      ...restContext,\n    });\n  }\n\n  /**\n   * 记录外部服务调用\n   */\n  public logExternalService(service: string, operation: string, statusCode?: number, duration?: number, error?: Error): void {\n    const context: LogContext = {\n      business: {\n        externalService: service,\n        operation,\n        ...(statusCode && { statusCode }),\n        ...(duration && { duration }),\n      },\n    };\n\n    if (error) {\n      context.error = {\n        name: error.name,\n        message: error.message,\n        ...(error.stack && { stack: error.stack }),\n      };\n      this.warn(`External service error: ${service} ${operation}`, context);\n    } else {\n      this.info(`External service call: ${service} ${operation}`, context);\n    }\n  }\n\n  /**\n   * 记录用户操作\n   */\n  public logUserAction(userId: string, action: string, context: LogContext = {}): void {\n    this.info(`User action: ${action}`, {\n      userId,\n      business: {\n        action,\n        ...context.business,\n      },\n      ...context,\n    });\n  }\n\n  /**\n   * 创建子日志记录器（用于特定模块）\n   */\n  public createChildLogger(module: string): StructuredLogger {\n    const childLogger = new StructuredLogger(this.serviceName);\n    childLogger.logger = this.logger.child({ module });\n    return childLogger;\n  }\n\n  /**\n   * 获取原始Winston logger（用于兼容性）\n   */\n  public getWinstonLogger(): winston.Logger {\n    return this.logger;\n  }\n\n  /**\n   * 测试辅助方法：清理日志缓存\n   */\n  public clearLogs(): void {\n    // 测试用：清理日志缓存\n  }\n\n  /**\n   * 测试辅助方法：获取性能日志\n   */\n  public getPerformanceLogs(): LogEntry[] {\n    // 测试用：获取性能日志\n    return [];\n  }\n}\n\n// 创建默认日志记录器实例\nexport const structuredLogger = new StructuredLogger();\n\n// 创建特定模块的日志记录器\nexport const authLogger = structuredLogger.createChildLogger('auth');\nexport const chatLogger = structuredLogger.createChildLogger('chat');\nexport const agentLogger = structuredLogger.createChildLogger('agent');\nexport const performanceLogger = structuredLogger.createChildLogger('performance');\nexport const securityLogger = structuredLogger.createChildLogger('security');\n\n// 为了向后兼容，导出默认实例\nexport default structuredLogger;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/adaptiveCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/apiResponse.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ApiError' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'typedError' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":357,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":357,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Response } from 'express';\nimport { ApiSuccessResponse, JsonObject, JsonValue, DynamicTypeGuard, DynamicDataConverter } from '@/types/dynamic';\nimport { createErrorFromUnknown } from '@/types/errors';\nimport { ApiError } from '@/types';\n\ntype PaginationMetadata = {\n  page: number;\n  pageSize: number;\n  total: number;\n  totalPages: number;\n  hasNext: boolean;\n  hasPrev: boolean;\n};\n\ninterface SuccessMetadata {\n  pagination?: PaginationMetadata;\n  extra?: unknown;\n}\n\ntype SendSuccessOptions = Exclude<Parameters<typeof ApiResponseHandler.sendSuccess>[2], undefined>;\n\n/**\n * 类型安全的API响应处理工具\n *\n * 特性：\n * - 类型安全的数据验证\n * - 统一的响应格式\n * - 自动序列化处理\n * - 请求ID追踪\n * - 性能监控\n * - 错误边界保护\n */\nexport class ApiResponseHandler {\n  private static readonly API_VERSION = '1.0.0';\n\n  /**\n   * 发送成功响应\n   */\n  static sendSuccess<T = unknown>(\n    res: Response,\n    data: T,\n    options: {\n      message?: string;\n      code?: string;\n      statusCode?: number;\n      requestId?: string;\n      metadata?: SuccessMetadata;\n      startTime?: number;\n    } = {},\n  ): void {\n    const {\n      message = 'success',\n      code = 'OK',\n      statusCode = 200,\n      requestId,\n      metadata,\n      startTime,\n    } = options;\n\n    // 验证响应数据类型\n    const safeData = DynamicDataConverter.toSafeJsonValue(data);\n\n    if (!DynamicTypeGuard.isJsonValue(safeData)) {\n      const error = createErrorFromUnknown(\n        new Error('Response data is not a valid JSON value'),\n        {\n          component: 'ApiResponseHandler',\n          operation: 'sendSuccess',\n          context: { dataType: typeof data },\n        },\n      );\n\n      return this.sendError(res, error, requestId ? { requestId } : {});\n    }\n\n    const metadataPayload: ApiSuccessResponse<JsonValue>['metadata'] = {\n      version: this.API_VERSION,\n      ...(startTime ? { duration: Date.now() - startTime } : {}),\n      ...(metadata?.pagination ? { pagination: metadata.pagination } : {}),\n      ...(metadata?.extra\n        ? this.getMetadataExtra(metadata.extra)\n        : {}),\n    };\n\n    const responseData: ApiSuccessResponse<JsonValue> = {\n      code,\n      message,\n      data: safeData as JsonValue,\n      timestamp: new Date().toISOString(),\n      ...(requestId ? { requestId } : {}),\n      metadata: metadataPayload,\n    };\n\n    // 设置响应头\n    if (requestId) {\n      res.setHeader('X-Request-ID', requestId);\n    }\n\n    res.setHeader('Content-Type', 'application/json');\n    res.status(statusCode).json(responseData);\n  }\n\n  /**\n   * 发送分页响应\n   */\n  static sendPaginated<T = unknown>(\n    res: Response,\n    data: T[],\n    pagination: {\n      page: number;\n      pageSize: number;\n      total: number;\n    },\n    options: {\n      message?: string;\n      requestId?: string;\n      startTime?: number;\n      metadata?: SuccessMetadata;\n    } = {},\n  ): void {\n    const totalPages = Math.ceil(pagination.total / pagination.pageSize);\n    const hasNext = pagination.page < totalPages;\n    const hasPrev = pagination.page > 1;\n\n    const paginationData = {\n      ...pagination,\n      totalPages,\n      hasNext,\n      hasPrev,\n    };\n\n    this.sendSuccess(res, data, {\n      ...(options.message ? { message: options.message } : {}),\n      ...(options.requestId ? { requestId: options.requestId } : {}),\n      ...(options.startTime ? { startTime: options.startTime } : {}),\n      metadata: {\n        pagination: paginationData,\n        ...(options.metadata?.extra\n          ? this.getMetadataExtra(options.metadata.extra)\n          : {}),\n      },\n    });\n  }\n\n  /**\n   * 发送错误响应\n   */\n  static sendError(\n    res: Response,\n    error: unknown,\n    options: {\n      statusCode?: number;\n      requestId?: string;\n      includeDetails?: boolean;\n    } = {},\n  ): void {\n    const typedError = createErrorFromUnknown(error, {\n      component: 'ApiResponseHandler',\n      operation: 'sendError',\n      context: { statusCode: options.statusCode },\n    });\n\n    const errorResponse = typedError.toApiError();\n\n    // 开发环境下添加详细信息\n    if (process.env.NODE_ENV === 'development' && options.includeDetails) {\n      errorResponse.details = {\n        originalError: typedError.message,\n        ...(typedError.stack && { stack: typedError.stack }),\n        ...(typedError.context && { context: typedError.context }),\n        errorId: typedError.id,\n      } as JsonValue;\n    }\n\n    // 设置响应头\n    if (options.requestId) {\n      res.setHeader('X-Request-ID', options.requestId);\n    }\n\n    if (process.env.NODE_ENV === 'production') {\n      res.setHeader('X-Error-ID', typedError.id);\n    }\n\n    const statusCode = options.statusCode || this.getDefaultErrorStatusCode(typedError);\n    res.status(statusCode).json(errorResponse);\n  }\n\n  /**\n   * 发送创建成功响应 (201)\n   */\n  static sendCreated<T = unknown>(\n    res: Response,\n    data: T,\n    options: Omit<SendSuccessOptions, 'statusCode'> = {},\n  ): void {\n    const nextOptions: SendSuccessOptions = {\n      ...(options ?? {}),\n      statusCode: 201,\n    };\n\n    if (!options?.code) {\n      nextOptions.code = 'CREATED';\n    }\n\n    this.sendSuccess(res, data, nextOptions);\n  }\n\n  private static getMetadataExtra(extra: unknown): Partial<{ extra: JsonObject }> {\n    const safeExtra = DynamicDataConverter.toSafeJsonValue(extra);\n\n    if (safeExtra && typeof safeExtra === 'object' && !Array.isArray(safeExtra)) {\n      return { extra: safeExtra as JsonObject };\n    }\n\n    if (safeExtra === null || safeExtra === undefined) {\n      return {};\n    }\n\n    return { extra: { value: safeExtra } as JsonObject };\n  }\n\n  /**\n   * 发送无内容响应 (204)\n   */\n  static sendNoContent(res: Response, options: { requestId?: string } = {}): void {\n    if (options.requestId) {\n      res.setHeader('X-Request-ID', options.requestId);\n    }\n    res.status(204).end();\n  }\n\n  /**\n   * 发送验证错误响应 (400)\n   */\n  static sendValidationError(\n    res: Response,\n    message: string,\n    options: {\n      details?: JsonValue;\n      requestId?: string;\n    } = {},\n  ): void {\n    const error = createErrorFromUnknown(\n      new Error(message),\n      {\n        component: 'ApiResponseHandler',\n        operation: 'sendValidationError',\n        context: { details: options.details },\n      },\n    );\n\n    this.sendError(res, error, { ...options, statusCode: 400 });\n  }\n\n  /**\n   * 发送未授权响应 (401)\n   */\n  static sendUnauthorized(\n    res: Response,\n    message: string = '未授权访问',\n    options: { requestId?: string } = {},\n  ): void {\n    const error = createErrorFromUnknown(\n      new Error(message),\n      {\n        component: 'ApiResponseHandler',\n        operation: 'sendUnauthorized',\n      },\n    );\n\n    this.sendError(res, error, { ...options, statusCode: 401 });\n  }\n\n  /**\n   * 发送禁止访问响应 (403)\n   */\n  static sendForbidden(\n    res: Response,\n    message: string = '禁止访问',\n    options: { requestId?: string } = {},\n  ): void {\n    const error = createErrorFromUnknown(\n      new Error(message),\n      {\n        component: 'ApiResponseHandler',\n        operation: 'sendForbidden',\n      },\n    );\n\n    this.sendError(res, error, { ...options, statusCode: 403 });\n  }\n\n  /**\n   * 发送未找到响应 (404)\n   */\n  static sendNotFound(\n    res: Response,\n    message: string = '资源不存在',\n    options: { requestId?: string } = {},\n  ): void {\n    const error = createErrorFromUnknown(\n      new Error(message),\n      {\n        component: 'ApiResponseHandler',\n        operation: 'sendNotFound',\n      },\n    );\n\n    this.sendError(res, error, { ...options, statusCode: 404 });\n  }\n\n  /**\n   * 发送方法不允许响应 (405)\n   */\n  static sendMethodNotAllowed(\n    res: Response,\n    message: string = '方法不允许',\n    options: { requestId?: string } = {},\n  ): void {\n    const error = createErrorFromUnknown(\n      new Error(message),\n      {\n        component: 'ApiResponseHandler',\n        operation: 'sendMethodNotAllowed',\n      },\n    );\n\n    this.sendError(res, error, { ...options, statusCode: 405 });\n  }\n\n  /**\n   * 发送冲突响应 (409)\n   */\n  static sendConflict(\n    res: Response,\n    message: string = '资源冲突',\n    options: { requestId?: string } = {},\n  ): void {\n    const error = createErrorFromUnknown(\n      new Error(message),\n      {\n        component: 'ApiResponseHandler',\n        operation: 'sendConflict',\n      },\n    );\n\n    this.sendError(res, error, { ...options, statusCode: 409 });\n  }\n\n  /**\n   * 安全的JSON序列化\n   */\n  static safeJsonStringify(data: JsonValue): string {\n    try {\n      return JSON.stringify(data, null, 2);\n    } catch (error) {\n      const typedError = createErrorFromUnknown(error, {\n        component: 'ApiResponseHandler',\n        operation: 'safeJsonStringify',\n        context: { dataType: typeof data },\n      });\n\n      return JSON.stringify({\n        code: 'SERIALIZATION_ERROR',\n        message: '数据序列化失败',\n        data: null,\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  /**\n   * 批量操作响应\n   */\n  static sendBatchResult(\n    res: Response,\n    results: {\n      success: boolean;\n      data?: JsonValue;\n      error?: string;\n      index: number;\n    }[],\n    options: { requestId?: string; startTime?: number } = {},\n  ): void {\n    const successful = results.filter(r => r.success).length;\n    const failed = results.length - successful;\n\n    const data = {\n      total: results.length,\n      successful,\n      failed,\n      results,\n    };\n\n    const message = failed === 0\n      ? '批量操作全部成功'\n      : successful === 0\n        ? '批量操作全部失败'\n        : `批量操作部分成功 (${successful}/${results.length})`;\n\n    this.sendSuccess(res, data, { ...options, message });\n  }\n\n  /**\n   * 健康检查响应\n   */\n  static sendHealthCheck(\n    res: Response,\n    status: 'healthy' | 'degraded' | 'unhealthy',\n    details?: JsonValue,\n    options: { requestId?: string } = {},\n  ): void {\n    const statusCode = status === 'healthy' ? 200 :\n      status === 'degraded' ? 200 : 503;\n\n    const data = {\n      status,\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      ...(details && { details }),\n    };\n\n    this.sendSuccess(res, data, {\n      ...options,\n      statusCode,\n      message: `服务状态: ${status}`,\n    });\n  }\n\n  /**\n   * 获取默认错误状态码\n   */\n  private static getDefaultErrorStatusCode(error: ReturnType<typeof createErrorFromUnknown>): number {\n    const code = error.code;\n    const message = error.message.toLowerCase();\n\n    // 客户端错误\n    if (code === 'VALIDATION_ERROR') {\n      return 400;\n    }\n    if (code === 'UNAUTHORIZED') {\n      return 401;\n    }\n    if (code === 'FORBIDDEN') {\n      return 403;\n    }\n    if (code === 'NOT_FOUND') {\n      return 404;\n    }\n    if (code === 'CONFLICT') {\n      return 409;\n    }\n\n    // 服务器错误\n    if (code === 'INTERNAL_SERVER_ERROR') {\n      return 500;\n    }\n    if (code === 'SERVICE_UNAVAILABLE') {\n      return 503;\n    }\n\n    // 基于消息判断\n    if (message.includes('not found')) {\n      return 404;\n    }\n    if (message.includes('unauthorized')) {\n      return 401;\n    }\n    if (message.includes('forbidden')) {\n      return 403;\n    }\n    if (message.includes('validation')) {\n      return 400;\n    }\n\n    return 500;\n  }\n}\n\n/**\n * 便捷的响应处理函数\n */\nexport const sendSuccess = <T = JsonValue>(\n  res: Response,\n  data: T,\n  options?: Parameters<typeof ApiResponseHandler.sendSuccess>[2],\n): void => {\n  ApiResponseHandler.sendSuccess(res, data, options);\n};\n\nexport const sendError = (\n  res: Response,\n  error: unknown,\n  options?: Parameters<typeof ApiResponseHandler.sendError>[2],\n): void => {\n  ApiResponseHandler.sendError(res, error, options);\n};\n\nexport const sendPaginated = <T = JsonValue>(\n  res: Response,\n  data: T[],\n  pagination: Parameters<typeof ApiResponseHandler.sendPaginated>[2],\n  options?: Parameters<typeof ApiResponseHandler.sendPaginated>[3],\n): void => {\n  ApiResponseHandler.sendPaginated(res, data, pagination, options);\n};\n\nexport const sendCreated = <T = JsonValue>(\n  res: Response,\n  data: T,\n  options?: Parameters<typeof ApiResponseHandler.sendCreated>[2],\n): void => {\n  ApiResponseHandler.sendCreated(res, data, options);\n};\n\nexport const sendNotFound = (\n  res: Response,\n  message?: string,\n  options?: { requestId?: string },\n): void => {\n  ApiResponseHandler.sendNotFound(res, message, options);\n};\n\nexport const sendValidationError = (\n  res: Response,\n  message: string,\n  options?: Parameters<typeof ApiResponseHandler.sendValidationError>[2],\n): void => {\n  ApiResponseHandler.sendValidationError(res, message, options);\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/appConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/cadFunctionTools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/config.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[152,155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[152,155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs/promises';\nimport path from 'path';\n\n/**\n * 读取带注释的 JSONC 配置文件并解析为对象\n * 支持环境变量占位符 ${VAR_NAME}\n */\nexport async function readJsonc<T = any>(configRelativePath: string): Promise<T> {\n  const fullPath = path.isAbsolute(configRelativePath)\n    ? configRelativePath\n    : path.join(__dirname, '../../../', configRelativePath);\n  const raw = await fs.readFile(fullPath, 'utf-8');\n  const stripped = stripJsonComments(raw);\n\n  // 替换环境变量占位符 \"${VAR_NAME}\" 或 ${VAR_NAME}\n  const replaced = stripped.replace(/\"?\\$\\{([^}]+)\\}\"?/g, (match, varName) => {\n    // 清理变量名中的空白字符（包括换行符）\n    const cleanVarName = varName.trim().replace(/\\s+/g, '');\n    const value = process.env[cleanVarName];\n    if (value === undefined) {\n      // 使用logger而非console.warn\n      return match;\n    }\n\n    // 检查原始匹配是否包含引号\n    const hasQuotes = match.startsWith('\"') && match.endsWith('\"');\n\n    // 如果值看起来像数字或布尔值\n    if (value === 'true' || value === 'false' || /^\\d+$/.test(value)) {\n      // 如果原本有引号，移除它们（因为数字和布尔值不需要引号）\n      return value;\n    }\n\n    // 字符串值\n    if (hasQuotes) {\n      // 已经有引号，只替换值\n      return `\"${value.replace(/\"/g, '\\\\\"')}\"`;\n    } else {\n      // 没有引号，直接返回值（通常不会发生）\n      return value;\n    }\n  });\n\n  return JSON.parse(replaced) as T;\n}\n\n/**\n * 简单去除 // 和 /* *\\/ 样式注释\n * 注意：该实现针对配置文件足够，勿用于复杂 JS 代码解析\n */\nexport function stripJsonComments(input: string): string {\n  // 去除多行注释 /* ... */\n  let output = input.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n  // 去除单行注释 //...\n  output = output.replace(/^\\s*\\/\\/.*$/gm, '');\n  return output;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/db.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3445,3448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3445,3448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4776,4779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4776,4779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":429,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":429,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12174,12177],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12174,12177],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":437,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12335,12338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12335,12338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool } from 'pg';\nimport crypto from 'crypto';\nimport path from 'path';\nimport fs from 'fs';\nimport { readJsonc } from '@/utils/config';\nimport { deepReplaceEnvVariables } from '@/utils/envHelper';\nimport logger from '@/utils/logger';\n\nexport interface PgConfig {\n  database?: {\n    postgres?: {\n      host: string;\n      port?: number | string;\n      user: string;\n      password: string;\n      database: string;\n      ssl?: boolean | string;\n    }\n  };\n  auth?: {\n    tokenTTLSeconds?: number;\n  };\n}\n\ntype PostgresConfig = NonNullable<NonNullable<PgConfig['database']>['postgres']>;\nexport type NormalizedPostgresConfig = Omit<PostgresConfig, 'port' | 'ssl'> & {\n  port?: number;\n  ssl?: boolean;\n};\n\nconst PLACEHOLDER_REGEX = /\\$\\{[^}]+\\}/;\n\nfunction isPlaceholder(value: string): boolean {\n  return PLACEHOLDER_REGEX.test(value);\n}\n\nfunction parseOptionalNumber(value: unknown, fieldName: string): number | undefined {\n  if (typeof value === 'number') {\n    return Number.isFinite(value) ? value : undefined;\n  }\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed || isPlaceholder(trimmed)) {\n      return undefined;\n    }\n\n    const parsed = Number.parseInt(trimmed, 10);\n    if (!Number.isNaN(parsed)) {\n      return parsed;\n    }\n\n    logger.warn(`[initDB] 无法解析数据库配置字段 ${fieldName} 为数字`, { value });\n  }\n\n  return undefined;\n}\n\nfunction parseOptionalBoolean(value: unknown, fieldName: string): boolean | undefined {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed || isPlaceholder(trimmed)) {\n      return undefined;\n    }\n\n    const normalized = trimmed.toLowerCase();\n    if (['1', 'true', 'yes', 'on'].includes(normalized)) {\n      return true;\n    }\n    if (['0', 'false', 'no', 'off'].includes(normalized)) {\n      return false;\n    }\n\n    logger.warn(`[initDB] 无法解析数据库配置字段 ${fieldName} 为布尔值`, { value });\n  }\n\n  return undefined;\n}\n\nexport function normalizePostgresConfig(pg: PostgresConfig): NormalizedPostgresConfig {\n  const config: NormalizedPostgresConfig = {\n    host: pg.host,\n    user: pg.user,\n    password: pg.password,\n    database: pg.database,\n  };\n\n  const port = parseOptionalNumber(pg.port, 'port');\n  if (port !== undefined) {\n    config.port = port;\n  }\n\n  const ssl = parseOptionalBoolean(pg.ssl, 'ssl');\n  if (ssl !== undefined) {\n    config.ssl = ssl;\n  }\n\n  return config;\n}\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    throw new Error('DB_NOT_INITIALIZED');\n  }\n  return pool;\n}\n\nexport async function initDB(): Promise<void> {\n  logger.info('[initDB] 开始初始化数据库...');\n\n  const rawCfg = await readJsonc<PgConfig>('config/config.jsonc');\n  logger.info('[initDB] 配置文件加载成功');\n\n  // 替换配置中的环境变量占位符\n  const cfg = deepReplaceEnvVariables(rawCfg);\n  const rawPg = cfg.database?.postgres;\n\n  if (!rawPg) {\n    logger.error('[initDB] 数据库配置缺失');\n    throw new Error('DATABASE_CONFIG_MISSING');\n  }\n\n  const pg = normalizePostgresConfig(rawPg);\n  logger.info(`[initDB] 数据库配置 - Host: ${pg.host}, Port: ${pg.port}, Database: ${pg.database}`);\n\n  // 先连接到 postgres 默认数据库，检查并创建目标数据库\n  logger.info('[initDB] 连接到 postgres 默认数据库...');\n  const tempPool = new Pool({\n    host: pg.host,\n    port: pg.port ?? 5432,\n    user: pg.user,\n    password: pg.password,\n    database: 'postgres', // 先连接到默认数据库\n    ssl: pg.ssl ? { rejectUnauthorized: false } as any : undefined,\n  });\n\n  try {\n    const client = await tempPool.connect();\n    logger.info('[initDB] 成功连接到 postgres 数据库');\n\n    try {\n      // 检查数据库是否存在\n      logger.info(`[initDB] 检查数据库 \"${pg.database}\" 是否存在...`);\n      const result = await client.query(\n        'SELECT 1 FROM pg_database WHERE datname = $1',\n        [pg.database],\n      );\n\n      if (result.rows.length === 0) {\n        // 数据库不存在，创建它\n        logger.info(`🔨 数据库 \"${pg.database}\" 不存在，正在创建...`);\n        await client.query(`CREATE DATABASE \"${pg.database}\"`);\n        logger.info(`✅ 数据库 \"${pg.database}\" 创建成功`);\n      } else {\n        logger.info(`✅ 数据库 \"${pg.database}\" 已存在`);\n      }\n    } catch (checkError) {\n      logger.error('[initDB] 检查/创建数据库时出错', { error: checkError });\n      throw checkError;\n    } finally {\n      client.release();\n      logger.info('[initDB] 释放临时连接');\n    }\n  } catch (tempPoolError) {\n    logger.error('[initDB] 连接到 postgres 数据库失败', { error: tempPoolError });\n    throw tempPoolError;\n  } finally {\n    await tempPool.end();\n    logger.info('[initDB] 关闭临时连接池');\n  }\n\n  // 现在连接到目标数据库\n  logger.info(`[initDB] 连接到目标数据库 \"${pg.database}\"...`);\n  pool = new Pool({\n    host: pg.host,\n    port: pg.port ?? 5432,\n    user: pg.user,\n    password: pg.password,\n    database: pg.database,\n    ssl: pg.ssl ? { rejectUnauthorized: false } as any : undefined,\n    max: 50,                          // 连接池最大50个连接（支持1000并发）\n    min: 5,                           // 最小保持5个连接\n    idleTimeoutMillis: 30_000,        // 30秒空闲超时\n    connectionTimeoutMillis: 10_000,  // 10秒连接超时\n    maxUses: 7500,                    // 每个连接最多使用7500次后回收\n  });\n\n  logger.info('[initDB] 数据库连接池创建成功');\n\n  // 建表（若不存在）\n  await withClient(async (client) => {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        username TEXT UNIQUE NOT NULL,\n        password_salt TEXT NOT NULL,\n        password_hash TEXT NOT NULL,\n        role TEXT DEFAULT 'user',\n        status TEXT DEFAULT 'active',\n        created_at TIMESTAMPTZ DEFAULT NOW(),\n        updated_at TIMESTAMPTZ DEFAULT NOW()\n      );\n    `);\n\n    // 移除明文密码列（安全修复）\n    try {\n      await client.query('ALTER TABLE users DROP COLUMN IF EXISTS password_plain;');\n      logger.info('[initDB] ✅ 已移除不安全的明文密码列');\n    } catch (error) {\n      // 列可能不存在，忽略错误\n      logger.info('[initDB] 明文密码列不存在或已移除');\n    }\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS logs (\n        id SERIAL PRIMARY KEY,\n        timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n        level TEXT NOT NULL,\n        message TEXT NOT NULL\n      );\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS agent_configs (\n        id TEXT PRIMARY KEY,\n        name TEXT NOT NULL,\n        description TEXT,\n        provider TEXT NOT NULL,\n        endpoint TEXT NOT NULL,\n        api_key TEXT NOT NULL,\n        app_id TEXT,\n        model TEXT NOT NULL,\n        max_tokens INTEGER,\n        temperature REAL,\n        system_prompt TEXT,\n        capabilities JSONB DEFAULT '[]'::jsonb,\n        rate_limit JSONB,\n        features JSONB,\n        metadata JSONB,\n        is_active BOOLEAN DEFAULT true,\n        source TEXT DEFAULT 'db',\n        created_at TIMESTAMPTZ DEFAULT NOW(),\n        updated_at TIMESTAMPTZ DEFAULT NOW()\n      );\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS chat_sessions (\n        id TEXT PRIMARY KEY,\n        agent_id TEXT NOT NULL REFERENCES agent_configs(id) ON DELETE CASCADE,\n        title TEXT,\n        user_id TEXT,\n        created_at TIMESTAMPTZ DEFAULT NOW(),\n        updated_at TIMESTAMPTZ DEFAULT NOW()\n      );\n    `);\n\n    // 审计日志表\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS audit_logs (\n        id SERIAL PRIMARY KEY,\n        timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n        user_id TEXT,\n        username TEXT,\n        action TEXT NOT NULL,\n        resource_type TEXT,\n        resource_id TEXT,\n        details JSONB,\n        ip_address TEXT,\n        user_agent TEXT,\n        status TEXT NOT NULL DEFAULT 'SUCCESS',\n        error_message TEXT,\n        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n      );\n    `);\n\n    // 审计日志索引\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp DESC);\n    `);\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);\n    `);\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);\n    `);\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_resource ON audit_logs(resource_type, resource_id);\n    `);\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_status ON audit_logs(status);\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS chat_messages (\n        id TEXT PRIMARY KEY,\n        session_id TEXT NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,\n        role TEXT NOT NULL,\n        content TEXT NOT NULL,\n        metadata JSONB,\n        created_at TIMESTAMPTZ DEFAULT NOW()\n      );\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_chat_messages_session_created\n        ON chat_messages (session_id, created_at);\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_agent_configs_provider\n        ON agent_configs (provider);\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_agent_configs_app\n        ON agent_configs (app_id)\n        WHERE app_id IS NOT NULL;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS chat_geo_events (\n        id TEXT PRIMARY KEY,\n        agent_id TEXT NOT NULL REFERENCES agent_configs(id) ON DELETE CASCADE,\n        session_id TEXT,\n        ip TEXT,\n        country TEXT,\n        province TEXT,\n        city TEXT,\n        created_at TIMESTAMPTZ DEFAULT NOW()\n      );\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_chat_geo_events_created\n        ON chat_geo_events (created_at);\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_chat_geo_events_agent\n        ON chat_geo_events (agent_id, created_at);\n    `);\n\n    // 首次空库自动种子管理员（仅非生产环境）——使用安全哈希\n    const { rows } = await client.query<{ count: string }>('SELECT COUNT(*)::text AS count FROM users');\n    const count = parseInt(rows[0]?.count || '0', 10);\n    if (count === 0) {\n      const { salt, hash } = hashPassword('admin');\n      await client.query(\n        'INSERT INTO users(username, password_salt, password_hash, role, status) VALUES ($1,$2,$3,$4,$5)',\n        ['admin', salt, hash, 'admin', 'active'],\n      );\n      logger.info('[initDB] ✅ 安全管理员账户已创建（密码：admin，请立即修改）');\n    }\n  });\n\n  // 🔧 种子智能体数据（添加错误处理）\n  try {\n    logger.info('🌱 开始种子智能体数据...');\n    await seedAgentsFromFile();\n    logger.info('✅ 智能体数据种子完成');\n  } catch (error) {\n    logger.error('❌ 智能体数据种子失败', { error });\n    // 不抛出异常，允许服务继续启动\n  }\n}\n\nexport async function withClient<T>(fn: (client: import('pg').PoolClient) => Promise<T>): Promise<T> {\n  const p = getPool();\n  const client = await p.connect();\n  try {\n    return await fn(client);\n  } finally {\n    client.release();\n  }\n}\n\nexport function hashPassword(password: string, salt?: string): { salt: string; hash: string } {\n  const realSalt = salt || crypto.randomBytes(16).toString('hex');\n  const hash = crypto.createHash('sha256').update(`${realSalt}:${password}`).digest('hex');\n  return { salt: realSalt, hash };\n}\n\nexport async function closeDB(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n\nasync function seedAgentsFromFile(): Promise<void> {\n  logger.info('🌱 [seedAgentsFromFile] 开始执行智能体种子函数...');\n\n  const filePathCandidates = [\n    path.resolve(__dirname, '../../../config/agents.json'),  // 从 backend/src/utils 到根目录 config\n    path.resolve(process.cwd(), 'config/agents.json'),       // 从当前工作目录\n    path.resolve(process.cwd(), '../config/agents.json'),     // 如果 cwd 是 backend\n  ];\n\n  logger.info('[seedAgentsFromFile] 候选文件路径', { paths: filePathCandidates });\n\n  let fileContent: string | null = null;\n  for (const filePath of filePathCandidates) {\n    try {\n      logger.info('[seedAgentsFromFile] 尝试读取文件', { path: filePath });\n      if (fs.existsSync(filePath)) {\n        fileContent = fs.readFileSync(filePath, 'utf-8');\n        logger.info('[seedAgentsFromFile] ✅ 文件读取成功', { path: filePath, length: fileContent.length });\n        break;\n      } else {\n        logger.warn('[seedAgentsFromFile] 文件不存在', { path: filePath });\n      }\n    } catch (e) {\n      logger.error('[seedAgentsFromFile] 读取智能体配置文件失败', { path: filePath, error: e });\n    }\n  }\n\n  if (!fileContent) {\n    logger.error('[seedAgentsFromFile] ❌ 所有候选路径都未找到agents.json文件！');\n    return;\n  }\n\n  let parsed: any;\n  try {\n    parsed = JSON.parse(fileContent);\n  } catch (e) {\n    logger.warn('[initDB] 解析 agents.json 失败', { error: e });\n    return;\n  }\n\n  const agents: any[] = Array.isArray(parsed?.agents) ? parsed.agents : [];\n  if (agents.length === 0) {\n    logger.info('[seedAgentsFromFile] agents.json为空，跳过种子');\n    return;\n  }\n\n  // 🔧 关键修复：替换环境变量占位符\n  const resolvedAgents = deepReplaceEnvVariables(agents);\n  logger.info('[seedAgentsFromFile] 智能体配置环境变量已替换', { count: agents.length });\n\n  await withClient(async (client) => {\n    const { rows } = await client.query<{ count: string }>('SELECT COUNT(*)::text AS count FROM agent_configs');\n    const count = parseInt(rows[0]?.count || '0', 10);\n\n    logger.info(`[seedAgentsFromFile] 数据库现有智能体数量: ${count}`);\n\n    // 🔧 修复：即使有数据也执行UPSERT（使用ON CONFLICT）\n    // if (count > 0) {\n    //   return;\n    // }\n\n    const insertText = `\n      INSERT INTO agent_configs (\n        id, name, description, provider, endpoint, api_key, app_id, model,\n        max_tokens, temperature, system_prompt, capabilities, rate_limit,\n        features, metadata, is_active, source\n      ) VALUES (\n        $1,$2,$3,$4,$5,$6,$7,$8,\n        $9,$10,$11,$12::jsonb,$13::jsonb,\n        $14::jsonb,$15::jsonb,$16,$17\n      )\n      ON CONFLICT (id) DO UPDATE SET\n        name = EXCLUDED.name,\n        description = EXCLUDED.description,\n        provider = EXCLUDED.provider,\n        endpoint = EXCLUDED.endpoint,\n        api_key = EXCLUDED.api_key,\n        app_id = EXCLUDED.app_id,\n        model = EXCLUDED.model,\n        max_tokens = EXCLUDED.max_tokens,\n        temperature = EXCLUDED.temperature,\n        system_prompt = EXCLUDED.system_prompt,\n        capabilities = EXCLUDED.capabilities,\n        rate_limit = EXCLUDED.rate_limit,\n        features = EXCLUDED.features,\n        metadata = EXCLUDED.metadata,\n        is_active = EXCLUDED.is_active,\n        source = 'json',\n        updated_at = NOW();\n    `;\n\n    for (const agent of resolvedAgents) {\n      try {\n        logger.info('[seedAgentsFromFile] 导入智能体', { id: agent.id, name: agent.name });\n        await client.query(insertText, [\n          agent.id,\n          agent.name,\n          agent.description ?? '',\n          agent.provider,\n          agent.endpoint,\n          agent.apiKey,\n          agent.appId ?? null,\n          agent.model,\n          agent.maxTokens ?? null,\n          agent.temperature ?? null,\n          agent.systemPrompt ?? null,\n          JSON.stringify(agent.capabilities ?? []),\n          JSON.stringify(agent.rateLimit ?? null),\n          JSON.stringify(agent.features ?? null),\n          JSON.stringify({ source: 'json' }),\n          agent.isActive ?? true,\n          'json',\n        ]);\n      } catch (e) {\n        logger.error('[seedAgentsFromFile] 导入智能体失败', { agentId: agent?.id, error: e });\n      }\n    }\n\n    logger.info(`✅ [seedAgentsFromFile] 智能体种子完成，共处理 ${resolvedAgents.length} 个智能体`);\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/envHelper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1868,1871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1868,1871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 环境变量处理工具\n * 提供安全的环境变量替换和验证功能\n *\n * 高可用特性:\n * - 使用EnvManager统一管理\n * - 支持降级默认值\n * - 敏感信息自动脱敏\n */\n\nimport logger from '@/utils/logger';\nimport { EnvManager } from '@/config/EnvManager';\n\n/**\n * 替换字符串中的环境变量占位符\n * 支持 ${VARIABLE_NAME} 格式的占位符\n * @param input 包含环境变量占位符的字符串\n * @param defaultValue 当环境变量未定义时的默认值\n * @param silent 是否静默模式（不记录警告）\n * @returns 替换后的字符串\n */\nexport function replaceEnvVariables(input: string, defaultValue?: string, silent: boolean = false): string {\n  const envManager = EnvManager.getInstance();\n\n  return input.replace(/\\$\\{([^}]+)\\}/g, (match, envVar) => {\n    // 使用EnvManager获取环境变量\n    const value = envManager.has(envVar) ? envManager.get(envVar) : undefined;\n\n    if (value === undefined || value === '') {\n      if (defaultValue !== undefined) {\n        return defaultValue;\n      }\n      // 如果没有默认值，返回原始占位符（保持向后兼容）\n      // 只有非静默模式才记录警告\n      if (!silent) {\n        logger.warn('环境变量未定义，保留占位符', {\n          envVar,\n          placeholder: match,\n          suggestion: `请在.env文件中设置 ${envVar}`,\n        });\n      }\n      return match;\n    }\n\n    // 敏感信息脱敏日志\n    if (!silent && !envManager.isDevelopment()) {\n      const isSensitive = ['PASSWORD', 'SECRET', 'KEY', 'TOKEN', 'API_KEY'].some(\n        pattern => envVar.toUpperCase().includes(pattern),\n      );\n      if (isSensitive) {\n        logger.debug('环境变量已替换', { envVar, value: '***REDACTED***' });\n      }\n    }\n\n    return value;\n  });\n}\n\n/**\n * 递归替换对象中的所有环境变量占位符\n * @param obj 需要处理的对象\n * @param silent 是否静默模式（不记录警告）\n * @returns 处理后的对象\n */\nexport function deepReplaceEnvVariables<T>(obj: T, silent: boolean = false): T {\n  if (typeof obj === 'string') {\n    return replaceEnvVariables(obj, undefined, silent) as T;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => deepReplaceEnvVariables(item, silent)) as T;\n  }\n\n  if (obj && typeof obj === 'object') {\n    const result: any = {};\n    for (const [key, value] of Object.entries(obj)) {\n      result[key] = deepReplaceEnvVariables(value, silent);\n    }\n    return result;\n  }\n\n  return obj;\n}\n\n/**\n * 验证必需的环境变量\n * @param requiredVars 必需的环境变量列表\n * @throws 如果必需的环境变量未定义\n */\nexport function validateRequiredEnvVars(requiredVars: string[]): void {\n  const envManager = EnvManager.getInstance();\n  const missing: string[] = [];\n\n  for (const varName of requiredVars) {\n    if (!envManager.has(varName)) {\n      missing.push(varName);\n    }\n  }\n\n  if (missing.length > 0) {\n    const error = new Error(\n      `缺少必需的环境变量: ${missing.join(', ')}\\n` +\n      '请在 backend/.env 文件中设置这些变量，参考 backend/ENV_TEMPLATE.txt',\n    );\n    logger.error('环境变量验证失败', { missing });\n    throw error;\n  }\n\n  logger.info('环境变量验证通过', { checked: requiredVars.length });\n}\n\n/**\n * 安全获取环境变量 (兼容旧代码)\n * @param key 环境变量键\n * @param defaultValue 默认值\n * @returns 环境变量值或默认值\n * @deprecated 建议使用 EnvManager.getInstance().get(key, defaultValue)\n */\nexport function getEnvVar(key: string, defaultValue?: string): string | undefined {\n  const envManager = EnvManager.getInstance();\n  return envManager.get(key, defaultValue || '');\n}\n\n/**\n * 检查字符串中是否包含未替换的环境变量占位符\n * @param str 要检查的字符串\n * @returns 是否包含未替换的占位符\n */\nexport function containsUnresolvedPlaceholders(str: string): boolean {\n  return /\\$\\{[^}]+\\}/.test(str);\n}\n\n/**\n * 获取字符串中的所有环境变量占位符\n * @param str 要分析的字符串\n * @returns 环境变量名数组\n */\nexport function extractEnvPlaceholders(str: string): string[] {\n  const matches = str.match(/\\$\\{([^}]+)\\}/g);\n  return matches ? matches.map(match => match.slice(2, -1)) : [];\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/envResolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/errorHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[494,497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[494,497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[546,549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[546,549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1821,1824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1821,1824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 类型安全的错误处理工具\n * 替代catch (error: any)的模式\n */\n\nimport type { EnhancedError } from '@llmchat/shared-types';\n\n/**\n * 类型守卫：检查是否为Error对象\n */\nexport function isError(error: unknown): error is Error {\n  return error instanceof Error;\n}\n\n/**\n * 类型守卫：检查是否为EnhancedError\n */\nexport function isEnhancedError(error: unknown): error is EnhancedError {\n  return typeof error === 'object' &&\n         error !== null &&\n         'name' in error &&\n         'message' in error &&\n         typeof (error as any).name === 'string' &&\n         typeof (error as any).message === 'string';\n}\n\n/**\n * 安全的字符串转换\n */\nexport function safeStringify(value: unknown): string {\n  if (value === null || value === undefined) {\n    return '';\n  }\n\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return String(value);\n  }\n\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return '[Unstringifiable]';\n  }\n}\n\n/**\n * 将unknown错误转换为EnhancedError\n */\nexport function toEnhancedError(\n  error: unknown,\n  context: {\n    operation?: string;\n    requestId?: string;\n    userId?: string;\n  } = {}\n): EnhancedError {\n  if (isEnhancedError(error)) {\n    return error;\n  }\n\n  if (isError(error)) {\n    return {\n      name: error.name,\n      message: error.message,\n      stack: error.stack,\n      category: 'internal',\n      severity: 'medium',\n      timestamp: new Date().toISOString(),\n      ...context\n    } as EnhancedError;\n  }\n\n  if (typeof error === 'string') {\n    return {\n      name: 'StringError',\n      message: error,\n      category: 'internal',\n      severity: 'medium',\n      timestamp: new Date().toISOString(),\n      ...context\n    } as EnhancedError;\n  }\n\n  return {\n    name: 'UnknownError',\n    message: 'An unknown error occurred',\n    details: error as any, // 这里使用any是因为无法确定结构\n    category: 'internal',\n    severity: 'medium',\n    timestamp: new Date().toISOString(),\n    ...context\n  } as EnhancedError;\n}\n\n/**\n * 类型安全的错误处理函数\n */\nexport function safeErrorHandler<T>(\n  error: unknown,\n  fallbackValue: T,\n  context?: {\n    operation?: string;\n    requestId?: string;\n    userId?: string;\n  }\n): { error: EnhancedError; fallback: T } {\n  const enhancedError = toEnhancedError(error, context);\n  return {\n    error: enhancedError,\n    fallback: fallbackValue\n  };\n}\n\n/**\n * Express错误处理助手\n */\nexport class ExpressErrorHandler {\n  /**\n   * 获取错误状态码\n   */\n  static getStatusCode(error: EnhancedError): number {\n    switch (error.category) {\n      case 'authentication':\n        return 401;\n      case 'authorization':\n        return 403;\n      case 'validation':\n        return 400;\n      case 'network':\n      case 'external':\n        return 502;\n      default:\n        return 500;\n    }\n  }\n\n  /**\n   * 获取用户友好的错误消息\n   */\n  static getUserMessage(error: EnhancedError): string {\n    switch (error.category) {\n      case 'authentication':\n        return '身份验证失败';\n      case 'authorization':\n        return '权限不足';\n      case 'validation':\n        return '输入数据不正确';\n      case 'network':\n        return '网络连接异常';\n      case 'external':\n        return '外部服务异常';\n      default:\n        return error.message || '服务器内部错误';\n    }\n  }\n\n  /**\n   * 标准化错误响应\n   */\n  static createErrorResponse(\n    error: EnhancedError,\n    requestId?: string\n  ): {\n    code: string | number;\n    message: string;\n    data: null;\n    timestamp: string;\n    requestId?: string;\n  } {\n    return {\n      code: error.code || this.getStatusCode(error),\n      message: this.getUserMessage(error),\n      data: null,\n      timestamp: error.timestamp || new Date().toISOString(),\n      ...(requestId && { requestId })\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/fastgptEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1004,1007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1004,1007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1380,1383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1380,1383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { v4 as uuidv4 } from 'uuid';\n\n/**\n * 生成唯一ID\n */\nexport const generateId = (): string => {\n  return uuidv4();\n};\n\n/**\n * 生成时间戳\n */\nexport const generateTimestamp = (): number => {\n  return Math.floor(Date.now() / 1000);\n};\n\n/**\n * 验证URL格式\n */\nexport const isValidUrl = (url: string): boolean => {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * 安全地解析JSON\n */\nexport const safeJsonParse = <T>(jsonString: string, defaultValue: T): T => {\n  try {\n    return JSON.parse(jsonString);\n  } catch {\n    return defaultValue;\n  }\n};\n\n/**\n * 延迟函数\n */\nexport const delay = (ms: number): Promise<void> => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n\n/**\n * 获取错误消息\n */\nexport const getErrorMessage = (error: unknown): string => {\n  if (error instanceof Error) {\n    return error.message;\n  }\n  if (typeof error === 'string') {\n    return error;\n  }\n  return '未知错误';\n};\n\n/**\n * 清理对象中的undefined值\n */\nexport const cleanObject = <T extends Record<string, any>>(obj: T): Partial<T> => {\n  const cleaned: Partial<T> = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== undefined) {\n      cleaned[key as keyof T] = value;\n    }\n  }\n  return cleaned;\n};\n\n/**\n * 深拷贝对象\n */\nexport const deepClone = <T>(obj: T): T => {\n  return JSON.parse(JSON.stringify(obj));\n};\n\n/**\n * 检查是否为空对象\n */\nexport const isEmpty = (obj: any): boolean => {\n  if (obj === null) {\n    return true;\n  }\n  if (Array.isArray(obj) || typeof obj === 'string') {\n    return obj.length === 0;\n  }\n  if (typeof obj === 'object') {\n    return Object.keys(obj).length === 0;\n  }\n  return false;\n};\n\n/**\n * 格式化文件大小\n */\nexport const formatFileSize = (bytes: number): string => {\n  if (bytes === 0) {\n    return '0 Bytes';\n  }\n\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\n\n/**\n * 截断字符串\n */\nexport const truncateString = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return str;\n  }\n  return str.slice(0, maxLength - 3) + '...';\n};\n\n/**\n * 转换为驼峰命名\n */\nexport const toCamelCase = (str: string): string => {\n  return str.replace(/_([a-z])/g, (match, letter) => letter.toUpperCase());\n};\n\n/**\n * 转换为下划线命名\n */\nexport const toSnakeCase = (str: string): string => {\n  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/logSanitizer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StructuredLogger' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[152,155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[152,155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[298,301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[298,301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[446,449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[446,449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[592,595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[592,595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":30,"column":42,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":30,"endColumn":43,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1065,1066],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1065,1065],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1677,1680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1677,1680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1683,1686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1683,1686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1809,1812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1809,1812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 日志脱敏工具\n * 用于在日志中屏蔽敏感信息\n */\n\nimport { StructuredLogger } from './StructuredLogger';\n\nexport const safeLogger = {\n  info: (message: string, meta?: any) => {\n    console.log(LogSanitizer.sanitize(message), meta ? LogSanitizer.sanitizeObject(meta) : '');\n  },\n  error: (message: string, error?: any) => {\n    console.error(LogSanitizer.sanitize(message), error ? LogSanitizer.sanitizeObject(error) : '');\n  },\n  warn: (message: string, meta?: any) => {\n    console.warn(LogSanitizer.sanitize(message), meta ? LogSanitizer.sanitizeObject(meta) : '');\n  },\n  debug: (message: string, meta?: any) => {\n    console.log(`[DEBUG] ${LogSanitizer.sanitize(message)}`, meta ? LogSanitizer.sanitizeObject(meta) : '');\n  },\n};\n\nexport class LogSanitizer {\n  private static sensitivePatterns = [\n    { pattern: /password/i, replacement: '****' },\n    { pattern: /token/i, replacement: '***' },\n    { pattern: /secret/i, replacement: '***' },\n    { pattern: /key/i, replacement: '***' },\n    { pattern: /auth/i, replacement: '***' },\n    { pattern: /Bearer\\s+[A-Za-z0-9\\-._~+\\/]+=*/g, replacement: 'Bearer ***' },\n    { pattern: /sk-[A-Za-z0-9]+/g, replacement: 'sk-***' },\n    { pattern: /mongodb:\\/\\/[^:]+:[^@]+@/g, replacement: 'mongodb://***:***@' },\n    { pattern: /postgresql:\\/\\/[^:]+:[^@]+@/g, replacement: 'postgresql://***:***@' },\n    { pattern: /mysql:\\/\\/[^:]+:[^@]+@/g, replacement: 'mysql://***:***@' },\n  ];\n\n  static sanitize(input: string): string {\n    let sanitized = input;\n\n    for (const { pattern, replacement } of this.sensitivePatterns) {\n      sanitized = sanitized.replace(pattern, replacement);\n    }\n\n    return sanitized;\n  }\n\n  static sanitizeObject(obj: any): any {\n    if (typeof obj !== 'object' || obj === null) {\n      return this.sanitize(String(obj));\n    }\n\n    const sanitized: any = {};\n\n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === 'string') {\n        sanitized[key] = this.sanitize(value);\n      } else if (typeof value === 'object' && value !== null) {\n        sanitized[key] = this.sanitizeObject(value);\n      } else {\n        sanitized[key] = value;\n      }\n    }\n\n    return sanitized;\n  }\n\n  static maskConnectionString(connectionString: string): string {\n    return this.sanitize(connectionString);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/migrate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/mongo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/secureCredentials.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3584,3587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3584,3587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Secure Credentials Manager\n *\n * Provides encryption at rest for sensitive credentials like database passwords\n * and API keys using AES-256-CBC encryption with environment-derived keys.\n */\n\nimport crypto from 'crypto';\nimport logger from '@/utils/logger';\n\nexport interface EncryptedData {\n  data: string;      // Base64 encoded encrypted data\n  iv: string;        // Base64 encoded initialization vector\n  algorithm: string; // Encryption algorithm used\n}\n\nexport class SecureCredentialsManager {\n  private static readonly ALGORITHM = 'aes-256-cbc';\n  private static readonly SALT_ROUNDS = 329_876; // NIST recommended\n\n  /**\n   * Derives encryption key from environment variables using PBKDF2\n   */\n  private static deriveKey(): Buffer {\n    const secretSources = [\n      process.env.TOKEN_SECRET || process.env.JWT_SECRET || 'default-secret',\n      process.env.DATABASE_URL || '',\n      process.env.NODE_ENV || 'development',\n      process.env.HOSTNAME || '',\n      'llmchat-credentials-salt-2024', // Fixed salt component\n    ];\n\n    // Create combined secret\n    const combinedSecret = secretSources.join('|');\n\n    // Create consistent salt from environment\n    const saltInput = process.env.CREDENTIALS_SALT || 'llmchat-default-salt';\n    const salt = crypto.createHash('sha256').update(saltInput).digest();\n\n    return crypto.pbkdf2Sync(combinedSecret, salt, this.SALT_ROUNDS, 32, 'sha256');\n  }\n\n  /**\n   * Encrypts sensitive data\n   */\n  static encrypt(plaintext: string): EncryptedData {\n    try {\n      const key = this.deriveKey();\n      const iv = crypto.randomBytes(16); // CBC needs 16-byte IV\n\n      const cipher = crypto.createCipheriv(this.ALGORITHM, key, iv);\n\n      const encrypted = Buffer.concat([\n        cipher.update(plaintext, 'utf8'),\n        cipher.final(),\n      ]);\n\n      return {\n        data: Buffer.from(encrypted).toString('base64'),\n        iv: iv.toString('base64'),\n        algorithm: this.ALGORITHM,\n      };\n    } catch (error) {\n      logger.error('[SecureCredentialsManager] Encryption failed', { error });\n      throw new Error('Failed to encrypt sensitive data');\n    }\n  }\n\n  /**\n   * Decrypts sensitive data\n   */\n  static decrypt(encryptedData: EncryptedData): string {\n    try {\n      const key = this.deriveKey();\n      const iv = Buffer.from(encryptedData.iv, 'base64');\n\n      const decipher = crypto.createDecipheriv(encryptedData.algorithm, key, iv);\n\n      const encryptedBuffer = Buffer.from(encryptedData.data, 'base64');\n      const decrypted = Buffer.concat([\n        decipher.update(encryptedBuffer),\n        decipher.final(),\n      ]);\n\n      return decrypted.toString('utf8');\n    } catch (error) {\n      logger.error('[SecureCredentialsManager] Decryption failed', { error });\n      throw new Error('Failed to decrypt sensitive data');\n    }\n  }\n\n  /**\n   * Encrypts database password for secure storage\n   */\n  static encryptDatabasePassword(password: string): EncryptedData {\n    return this.encrypt(password);\n  }\n\n  /**\n   * Decrypts database password for use in connections\n   */\n  static decryptDatabasePassword(encryptedData: EncryptedData): string {\n    return this.decrypt(encryptedData);\n  }\n\n  /**\n   * Encrypts API keys for secure storage\n   */\n  static encryptApiKey(apiKey: string): EncryptedData {\n    return this.encrypt(apiKey);\n  }\n\n  /**\n   * Decrypts API keys for use in requests\n   */\n  static decryptApiKey(encryptedData: EncryptedData): string {\n    return this.decrypt(encryptedData);\n  }\n\n  /**\n   * Validates encrypted data integrity\n   */\n  static validateEncryptedData(encryptedData: any): encryptedData is EncryptedData {\n    return (\n      encryptedData &&\n      typeof encryptedData === 'object' &&\n      typeof encryptedData.data === 'string' &&\n      typeof encryptedData.iv === 'string' &&\n      typeof encryptedData.algorithm === 'string' &&\n      encryptedData.data.length > 0 &&\n      encryptedData.iv.length > 0\n    );\n  }\n\n  /**\n   * Generates a secure random key for additional entropy\n   */\n  static generateSecureKey(length: number = 32): string {\n    return crypto.randomBytes(length).toString('hex');\n  }\n\n  /**\n   * Checks if encryption is available (proper environment setup)\n   */\n  static isEncryptionAvailable(): boolean {\n    try {\n      this.deriveKey();\n      return true;\n    } catch (error) {\n      logger.warn('[SecureCredentialsManager] Encryption not available', { error });\n      return false;\n    }\n  }\n\n  /**\n   * Masks sensitive data for logging\n   */\n  static maskSensitiveData(data: string): string {\n    if (!data || data.length < 8) {\n      return '***';\n    }\n    return data.substring(0, 4) + '***' + data.substring(data.length - 4);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/secureDb.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'deepReplaceEnvVariables' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readJsonc' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3924,3927],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3924,3927],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":161,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4530,4533],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4530,4533],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5862,5865],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5862,5865],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Secure Database Configuration Manager\n *\n * Handles encrypted database credentials and secure connection management\n * to prevent plaintext password exposure in logs, memory dumps, and configuration files.\n */\n\nimport { Pool, PoolConfig } from 'pg';\nimport { SecureCredentialsManager, EncryptedData } from './secureCredentials';\nimport { deepReplaceEnvVariables } from './envHelper';\nimport { readJsonc } from './config';\nimport logger from './logger';\n\nexport interface SecurePgConfig {\n  database?: {\n    postgres?: {\n      host: string;\n      port?: number | string;\n      user: string;\n      password: string | EncryptedData; // Can be encrypted or plaintext (for migration)\n      database: string;\n      ssl?: boolean | string;\n      encryptedPassword?: boolean; // Flag to indicate if password is encrypted\n    }\n  };\n  auth?: {\n    tokenTTLSeconds?: number;\n  };\n}\n\ntype PostgresConfig = NonNullable<NonNullable<SecurePgConfig['database']>['postgres']>;\nexport type NormalizedSecurePostgresConfig = Omit<PostgresConfig, 'port' | 'ssl'> & {\n  port?: number;\n  ssl?: boolean;\n};\n\nconst PLACEHOLDER_REGEX = /\\$\\{[^}]+\\}/;\n\nfunction isPlaceholder(value: string): boolean {\n  return PLACEHOLDER_REGEX.test(value);\n}\n\nfunction parseOptionalNumber(value: unknown, fieldName: string): number | undefined {\n  if (typeof value === 'number') {\n    return Number.isFinite(value) ? value : undefined;\n  }\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed || isPlaceholder(trimmed)) {\n      return undefined;\n    }\n\n    const parsed = Number.parseInt(trimmed, 10);\n    if (!Number.isNaN(parsed)) {\n      return parsed;\n    }\n\n    logger.warn(`[secureDb] 无法解析数据库配置字段 ${fieldName} 为数字`, { value });\n  }\n\n  return undefined;\n}\n\nfunction parseOptionalBoolean(value: unknown, fieldName: string): boolean | undefined {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed || isPlaceholder(trimmed)) {\n      return undefined;\n    }\n\n    const normalized = trimmed.toLowerCase();\n    if (['1', 'true', 'yes', 'on'].includes(normalized)) {\n      return true;\n    }\n    if (['0', 'false', 'no', 'off'].includes(normalized)) {\n      return false;\n    }\n\n    logger.warn(`[secureDb] 无法解析数据库配置字段 ${fieldName} 为布尔值`, { value });\n  }\n\n  return undefined;\n}\n\n/**\n * Decrypts password if it's encrypted, otherwise returns as-is\n */\nfunction decryptPasswordIfNeeded(password: string | EncryptedData, isEncrypted?: boolean): string {\n  if (isEncrypted && typeof password === 'object' && SecureCredentialsManager.validateEncryptedData(password)) {\n    try {\n      return SecureCredentialsManager.decryptDatabasePassword(password);\n    } catch (error) {\n      logger.error('[secureDb] Failed to decrypt database password', { error });\n      throw new Error('Failed to decrypt database password');\n    }\n  }\n\n  if (typeof password === 'string') {\n    return password;\n  }\n\n  throw new Error('Invalid password format');\n}\n\n/**\n * Masks password in logs and error messages\n */\nfunction maskPassword(password: string): string {\n  if (!password || password.length < 4) {\n    return '***';\n  }\n  return password.substring(0, 2) + '***' + password.substring(password.length - 2);\n}\n\nexport function normalizeSecurePostgresConfig(pg: PostgresConfig): NormalizedSecurePostgresConfig {\n  const config: NormalizedSecurePostgresConfig = {\n    host: pg.host,\n    user: pg.user,\n    password: typeof pg.password === 'string' ? pg.password : '***encrypted***',\n    database: pg.database,\n  };\n\n  const port = parseOptionalNumber(pg.port, 'port');\n  if (port !== undefined) {\n    config.port = port;\n  }\n\n  const ssl = parseOptionalBoolean(pg.ssl, 'ssl');\n  if (ssl !== undefined) {\n    config.ssl = ssl;\n  }\n\n  return config;\n}\n\nexport function createSecurePoolConfig(pg: PostgresConfig): PoolConfig {\n  const isEncrypted = (pg as any).encryptedPassword === true;\n  const decryptedPassword = decryptPasswordIfNeeded(pg.password, isEncrypted);\n\n  // Log masked password for security\n  logger.info('[secureDb] Creating database connection pool', {\n    host: pg.host,\n    port: Number(pg.port) ?? 5432,\n    database: pg.database,\n    user: pg.user,\n    passwordMasked: maskPassword(decryptedPassword),\n    passwordEncrypted: isEncrypted,\n  });\n\n  return {\n    host: pg.host,\n    port: Number(pg.port) ?? 5432,\n    user: pg.user,\n    password: decryptedPassword,\n    database: pg.database,\n    ssl: pg.ssl ? { rejectUnauthorized: false } as any : undefined,\n    max: 50,                          // 连接池最大50个连接（支持1000并发）\n    min: 5,                           // 最小保持5个连接\n    idleTimeoutMillis: 30_000,        // 30秒空闲超时\n    connectionTimeoutMillis: 10_000,  // 10秒连接超时\n    maxUses: 7500,                    // 每个连接最多使用7500次后回收\n  };\n}\n\n/**\n * Migrates plaintext password to encrypted format\n */\nexport function migrateToEncryptedPassword(plaintextPassword: string): EncryptedData {\n  logger.info('[secureDb] Migrating password to encrypted storage');\n  return SecureCredentialsManager.encryptDatabasePassword(plaintextPassword);\n}\n\n/**\n * Checks if password needs migration (is plaintext)\n */\nexport function needsPasswordMigration(password: string | EncryptedData): boolean {\n  return typeof password === 'string';\n}\n\n/**\n * Validates secure database configuration\n */\nexport function validateSecureConfig(config: SecurePgConfig): boolean {\n  try {\n    const pg = config.database?.postgres;\n    if (!pg) {\n      logger.error('[secureDb] Database configuration missing');\n      return false;\n    }\n\n    if (!pg.host || !pg.user || !pg.database) {\n      logger.error('[secureDb] Required database fields missing', {\n        hasHost: !!pg.host,\n        hasUser: !!pg.user,\n        hasDatabase: !!pg.database,\n      });\n      return false;\n    }\n\n    const isEncrypted = (pg as any).encryptedPassword === true;\n    if (isEncrypted && !SecureCredentialsManager.validateEncryptedData(pg.password)) {\n      logger.error('[secureDb] Invalid encrypted password format');\n      return false;\n    }\n\n    return true;\n  } catch (error) {\n    logger.error('[secureDb] Configuration validation failed', { error });\n    return false;\n  }\n}\n\n/**\n * Creates a secure database pool with encrypted password support\n */\nexport function createSecurePool(config: SecurePgConfig): Pool {\n  if (!validateSecureConfig(config)) {\n    throw new Error('Invalid database configuration');\n  }\n\n  const pg = config.database!.postgres!;\n  const poolConfig = createSecurePoolConfig(pg);\n\n  return new Pool(poolConfig);\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/secureJwt.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Algorithm' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SignOptions' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2266,2269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2266,2269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'token' is defined but never used. Allowed unused args must match /^_/u.","line":88,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'iat' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":126,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'exp' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":126,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 安全JWT工具\n * 提供JWT令牌的安全创建和验证功能\n */\n\nimport jwt, { Algorithm, SignOptions } from 'jsonwebtoken';\nimport { LogSanitizer } from './logSanitizer';\n\nexport interface JWTPayload {\n  userId: string;\n  email: string;\n  sub?: string;\n  username?: string;\n  role?: string;\n  jti?: string;\n  iat?: number;\n  exp?: number;\n}\n\nexport class SecureJWT {\n  private static readonly DEFAULT_ALGORITHM = 'HS256';\n  private static readonly DEFAULT_EXPIRES_IN = '1h';\n\n  static getConfig(): {\n    secret: string;\n    algorithm: jwt.Algorithm;\n    expiresIn: string;\n    issuer: string;\n    audience: string;\n    } {\n    const secret = process.env.TOKEN_SECRET;\n    if (!secret || secret.length < 32) {\n      throw new Error('TOKEN_SECRET must be at least 32 characters long');\n    }\n\n    return {\n      secret,\n      algorithm: (process.env.JWT_ALGORITHM as jwt.Algorithm) || this.DEFAULT_ALGORITHM,\n      expiresIn: process.env.JWT_EXPIRES_IN || this.DEFAULT_EXPIRES_IN,\n      issuer: process.env.JWT_ISSUER || 'llmchat-backend',\n      audience: process.env.JWT_AUDIENCE || 'llmchat-frontend',\n    };\n  }\n\n  static validateConfiguration(): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const config = this.getConfig();\n\n    try {\n      if (config.secret.length < 32) {\n        errors.push('TOKEN_SECRET must be at least 32 characters long');\n      }\n\n      if (!['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512'].includes(config.algorithm)) {\n        errors.push(`Unsupported JWT algorithm: ${config.algorithm}`);\n      }\n\n      // Test token creation\n      const testPayload = { test: 'validation' };\n      jwt.sign(testPayload, config.secret, { algorithm: config.algorithm });\n    } catch (error) {\n      errors.push(`JWT configuration error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  static createToken(payload: JWTPayload): string {\n    const config = this.getConfig();\n\n      const options: jwt.SignOptions = {\n      issuer: config.issuer,\n      audience: config.audience,\n      algorithm: config.algorithm as jwt.Algorithm,\n    };\n\n    // expiresIn is handled separately to avoid type issues\n    if (config.expiresIn) {\n      (options as any).expiresIn = config.expiresIn;\n    }\n\n    return jwt.sign(payload, config.secret, options);\n  }\n\n  static isTokenRevoked(token: string): boolean {\n    // 这里可以实现token撤销检查逻辑\n    // 例如检查黑名单或数据库记录\n    return false;\n  }\n\n  static getTokenTTL(token: string): number {\n    const decoded = this.decodeToken(token);\n    if (!decoded?.exp || !decoded.iat) {\n      return 0;\n    }\n    return decoded.exp - decoded.iat;\n  }\n\n  static verifyToken(token: string): JWTPayload {\n    const config = this.getConfig();\n\n    try {\n      const decoded = jwt.verify(token, config.secret, {\n        algorithms: [config.algorithm],\n        issuer: config.issuer,\n        audience: config.audience,\n      }) as JWTPayload;\n\n      return decoded;\n    } catch (error) {\n      if (error instanceof jwt.TokenExpiredError) {\n        throw new Error('Token expired');\n      } else if (error instanceof jwt.JsonWebTokenError) {\n        throw new Error('Invalid token');\n      } else {\n        throw new Error('Token verification failed');\n      }\n    }\n  }\n\n  static refreshToken(token: string): string {\n    const decoded = this.verifyToken(token);\n    const { iat, exp, ...payload } = decoded;\n    return this.createToken(payload);\n  }\n\n  static decodeToken(token: string): JWTPayload | null {\n    try {\n      return jwt.decode(token) as JWTPayload;\n    } catch {\n      return null;\n    }\n  }\n\n  static isTokenExpired(token: string): boolean {\n    try {\n      const decoded = this.decodeToken(token);\n      if (!decoded?.exp) {\n        return true;\n      }\n\n      return Date.now() >= decoded.exp * 1000;\n    } catch {\n      return true;\n    }\n  }\n\n  static sanitizeLogMessage(message: string): string {\n    return LogSanitizer.sanitize(message);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/secureUpload.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requireAuth' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":49,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":49,"endColumn":18},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":118,"column":40,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":118,"endColumn":41,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3150,3151],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3150,3150],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":124,"column":35,"nodeType":"Literal","messageId":"unexpected","endLine":124,"endColumn":58},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":130,"column":39,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":130,"endColumn":40,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3438,3439],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3438,3438],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":130,"column":46,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":130,"endColumn":47,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3445,3446],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3445,3445],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":146,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3859,3862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3859,3862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":167,"column":18,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":167,"endColumn":31}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 安全文件上传工具\n * 提供文件上传的安全验证和处理\n */\n\nimport { Request } from 'express';\nimport { LogSanitizer } from './logSanitizer';\n\nexport interface FileValidationOptions {\n  maxSize?: number;\n  allowedTypes?: string[];\n  allowedExtensions?: string[];\n  requireAuth?: boolean;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  isValid?: boolean;\n  error?: string;\n  errors?: string[];\n  sanitizedFilename?: string;\n  warnings?: string[];\n}\n\nexport class SecureUpload {\n  private static readonly DEFAULT_MAX_SIZE = 10 * 1024 * 1024; // 10MB\n  private static readonly DEFAULT_ALLOWED_TYPES = [\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'application/pdf',\n    'text/plain',\n    'application/json',\n  ];\n\n  private static readonly DANGEROUS_EXTENSIONS = [\n    '.exe', '.bat', '.cmd', '.com', '.pif', '.scr', '.vbs', '.js', '.jar',\n    '.php', '.asp', '.aspx', '.jsp', '.py', '.rb', '.sh', '.ps1',\n  ];\n\n  static validateFile(\n    file: Express.Multer.File,\n    options: FileValidationOptions = {},\n  ): ValidationResult {\n    const {\n      maxSize = this.DEFAULT_MAX_SIZE,\n      allowedTypes = this.DEFAULT_ALLOWED_TYPES,\n      allowedExtensions = [],\n      requireAuth = true,\n    } = options;\n\n    // 检查文件大小\n    if (file.size > maxSize) {\n      return {\n        valid: false,\n        isValid: false,\n        error: `File size exceeds maximum allowed size of ${maxSize} bytes`,\n        errors: [`File size exceeds maximum allowed size of ${maxSize} bytes`],\n      };\n    }\n\n    // 检查文件类型\n    if (allowedTypes.length > 0 && !allowedTypes.includes(file.mimetype)) {\n      return {\n        valid: false,\n        isValid: false,\n        error: `File type ${file.mimetype} is not allowed`,\n        errors: [`File type ${file.mimetype} is not allowed`],\n      };\n    }\n\n    // 检查文件扩展名\n    const fileExtension = this.getFileExtension(file.originalname);\n    if (this.DANGEROUS_EXTENSIONS.includes(fileExtension.toLowerCase())) {\n      return {\n        valid: false,\n        error: `File extension ${fileExtension} is not allowed for security reasons`,\n      };\n    }\n\n    if (allowedExtensions.length > 0 && !allowedExtensions.includes(fileExtension.toLowerCase())) {\n      return {\n        valid: false,\n        error: `File extension ${fileExtension} is not allowed`,\n      };\n    }\n\n    // 生成安全的文件名\n    const sanitizedFilename = this.sanitizeFilename(file.originalname);\n\n    return {\n      valid: true,\n      isValid: true,\n      sanitizedFilename,\n      errors: [],\n      warnings: [],\n    };\n  }\n\n  static validateCADFile(file: Express.Multer.File): ValidationResult {\n    const cadOptions: FileValidationOptions = {\n      maxSize: 10 * 1024 * 1024, // 10MB for CAD files\n      allowedTypes: ['application/dxf', 'image/vnd.dxf', 'text/plain'],\n      allowedExtensions: ['.dxf'],\n      requireAuth: true,\n    };\n\n    return this.validateFile(file, cadOptions);\n  }\n\n  static getFileExtension(filename: string): string {\n    const lastDot = filename.lastIndexOf('.');\n    return lastDot !== -1 ? filename.substring(lastDot) : '';\n  }\n\n  static sanitizeFilename(filename: string): string {\n    // 移除路径分隔符\n    let sanitized = filename.replace(/[\\/\\\\]/g, '_');\n\n    // 移除特殊字符\n    sanitized = sanitized.replace(/[<>:\"|?*]/g, '_');\n\n    // 移除控制字符\n    sanitized = sanitized.replace(/[\\x00-\\x1f\\x7f-\\x9f]/g, '_');\n\n    // 移除连续的下划线\n    sanitized = sanitized.replace(/_+/g, '_');\n\n    // 移除开头和结尾的下划线和点\n    sanitized = sanitized.replace(/^[_\\.]+|[_\\.]+$/g, '');\n\n    // 确保文件名不为空\n    if (!sanitized) {\n      sanitized = `file_${Date.now()}`;\n    }\n\n    // 添加时间戳以避免冲突\n    const extension = this.getFileExtension(filename);\n    const nameWithoutExt = sanitized.substring(0, sanitized.length - extension.length);\n\n    return `${nameWithoutExt}_${Date.now()}${extension}`;\n  }\n\n  static validateUserAuth(req: Request): boolean {\n    // 检查用户是否已认证\n    return !!(req as any).user?.id;\n  }\n\n  static logUpload(filename: string, userId: string, success: boolean): void {\n    const sanitizedFilename = LogSanitizer.sanitize(filename);\n    const status = success ? 'SUCCESS' : 'FAILED';\n    console.log(`File upload ${status}: ${sanitizedFilename} by user ${userId}`);\n  }\n\n  static generateSecurePath(userId: string, filename: string): string {\n    const sanitizedUserId = LogSanitizer.sanitize(userId);\n    const sanitizedFilename = LogSanitizer.sanitize(filename);\n    const timestamp = Date.now();\n\n    return `/uploads/${sanitizedUserId}/${timestamp}_${sanitizedFilename}`;\n  }\n\n  static async scanForMalware(filePath: string): Promise<{ safe: boolean; threat?: string }> {\n    // 这里可以集成病毒扫描软件\n    // 目前只做基本的文件签名检查\n    try {\n      const fs = require('fs').promises;\n      const buffer = await fs.readFile(filePath);\n\n      // 检查PE文件头 (Windows可执行文件)\n      if (buffer.length > 2 && buffer[0] === 0x4D && buffer[1] === 0x5A) {\n        return { safe: false, threat: 'PE executable detected' };\n      }\n\n      // 检查ELF文件头 (Linux可执行文件)\n      if (buffer.length > 4 &&\n          buffer[0] === 0x7F &&\n          buffer[1] === 0x45 &&\n          buffer[2] === 0x4C &&\n          buffer[3] === 0x46) {\n        return { safe: false, threat: 'ELF executable detected' };\n      }\n\n      // 检查可疑的脚本内容\n      const content = buffer.toString('utf8', 0, Math.min(1024, buffer.length));\n      const suspiciousPatterns = [\n        /<script/i,\n        /javascript:/i,\n        /vbscript:/i,\n        /onload=/i,\n        /onerror=/i,\n      ];\n\n      for (const pattern of suspiciousPatterns) {\n        if (pattern.test(content)) {\n          return { safe: false, threat: 'Suspicious script content detected' };\n        }\n      }\n\n      return { safe: true };\n    } catch (error) {\n      console.error('Malware scan failed:', error);\n      return { safe: false, threat: 'Scan failed' };\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/sentry.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'app' is defined but never used. Allowed unused args must match /^_/u.","line":20,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hint' is defined but never used. Allowed unused args must match /^_/u.","line":47,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":47,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2635,2638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2635,2638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2646,2649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2646,2649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2657,2660],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2657,2660],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2801,2804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2801,2804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2812,2815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2812,2815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2823,2826],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2823,2826],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2915,2918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2915,2918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'name' is defined but never used. Allowed unused args must match /^_/u.","line":178,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":178,"endColumn":51},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3967,3970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3967,3970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3978,3981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3978,3981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3989,3992],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3989,3992],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sentry 后端错误追踪配置\n *\n * 功能：\n * - 自动捕获未处理异常\n * - Express中间件集成\n * - 性能监控\n * - 请求上下文追踪\n *\n * 注意：适配 Sentry v10+ API\n */\n\nimport * as Sentry from '@sentry/node';\nimport { nodeProfilingIntegration } from '@sentry/profiling-node';\nimport type { Express } from 'express';\n\n/**\n * 初始化Sentry\n */\nexport function initSentry(app: Express): void {\n  // 仅在生产环境或明确启用时初始化\n  if (process.env.NODE_ENV === 'production' || process.env.SENTRY_ENABLED === 'true') {\n    const dsn = process.env.SENTRY_DSN;\n\n    if (!dsn) {\n      console.warn('Sentry DSN未配置，错误追踪已禁用');\n      return;\n    }\n\n    Sentry.init({\n      dsn,\n      environment: process.env.NODE_ENV || 'development',\n      release: process.env.APP_VERSION || 'unknown',\n\n      // 集成（Sentry v10+ 使用函数式API）\n      integrations: [\n        Sentry.httpIntegration(),\n        Sentry.expressIntegration(),\n        nodeProfilingIntegration(),\n      ],\n\n      // 性能监控\n      tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,\n      profilesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,\n\n      // 数据清理\n      beforeSend(event: Sentry.ErrorEvent, hint: Sentry.EventHint): Sentry.ErrorEvent | null {\n        // 移除敏感数据\n        if (event.request) {\n          delete event.request.cookies;\n\n          // 清理headers中的敏感信息\n          if (event.request.headers) {\n            delete event.request.headers.authorization;\n            delete event.request.headers['x-api-key'];\n            delete event.request.headers.cookie;\n          }\n\n          // 清理URL中的敏感参数\n          if (event.request.url) {\n            try {\n              const url = new URL(event.request.url, 'http://localhost');\n              url.searchParams.delete('apiKey');\n              url.searchParams.delete('token');\n              event.request.url = url.pathname + url.search;\n            } catch (e) {\n              // URL解析失败，保持原样\n            }\n          }\n        }\n\n        // 清理请求体中的敏感数据\n        if (event.request?.data) {\n          const data = event.request.data as Record<string, unknown>;\n          if (data.password) {\n            data.password = '[Filtered]';\n          }\n          if (data.apiKey) {\n            data.apiKey = '[Filtered]';\n          }\n          if (data.token) {\n            data.token = '[Filtered]';\n          }\n          if (data.api_key) {\n            data.api_key = '[Filtered]';\n          }\n        }\n\n        return event;\n      },\n    });\n\n    console.log('Sentry错误追踪已启用（后端）');\n  } else {\n    console.log('Sentry错误追踪已禁用（开发环境）');\n  }\n}\n\n/**\n * Express请求处理器（必须在所有路由之前）\n * v10中已自动集成到 expressIntegration，这里保留为空中间件以兼容\n */\nexport function sentryRequestHandler() {\n  return (_req: any, _res: any, next: any) => next();\n}\n\n/**\n * Express追踪处理器（必须在所有路由之前）\n * v10中已集成到 expressIntegration 中\n */\nexport function sentryTracingHandler() {\n  return (_req: any, _res: any, next: any) => next();\n}\n\n/**\n * Express错误处理器（必须在所有路由之后）\n */\nexport function sentryErrorHandler(): any {\n  return Sentry.expressErrorHandler();\n}\n\n/**\n * 设置用户上下文\n */\nexport function setSentryUser(user: { id: string; email?: string; username?: string }): void {\n  const userData: Sentry.User = {\n    id: user.id,\n  };\n  if (user.email) {\n    userData.email = user.email;\n  }\n  if (user.username) {\n    userData.username = user.username;\n  }\n\n  Sentry.setUser(userData);\n}\n\n/**\n * 清除用户上下文\n */\nexport function clearSentryUser(): void {\n  Sentry.setUser(null);\n}\n\n/**\n * 手动捕获错误\n */\nexport function captureError(error: Error, context?: Record<string, unknown>): void {\n  if (context) {\n    Sentry.captureException(error, {\n      extra: context,\n    });\n  } else {\n    Sentry.captureException(error);\n  }\n}\n\n/**\n * 添加面包屑\n */\nexport function addBreadcrumb(\n  message: string,\n  category: string,\n  level: Sentry.SeverityLevel = 'info',\n): void {\n  Sentry.addBreadcrumb({\n    message,\n    category,\n    level,\n    timestamp: Date.now() / 1000,\n  });\n}\n\n/**\n * 性能追踪中间件（简化版，v10推荐使用自动追踪）\n */\nexport function performanceMiddleware(name: string) {\n  return (_req: any, _res: any, next: any) => {\n    // v10中由 expressIntegration 自动处理\n    // 这里保留接口兼容性但不做实际操作\n    next();\n  };\n}\n\n// 导出Sentry实例供高级使用\nexport { Sentry };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/mnt/data/ss/wss/llmchat/backend/src/utils/tracing.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1967,1970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1967,1970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1981,1984],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1981,1984],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2766,2769],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2766,2769],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OpenTelemetry 分布式追踪配置\n * 支持 Jaeger/Zipkin/Tempo 等后端\n */\n\nimport { NodeSDK } from '@opentelemetry/sdk-node';\nimport { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';\nimport { defaultResource, resourceFromAttributes } from '@opentelemetry/resources';\nimport { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT } from '@opentelemetry/semantic-conventions';\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';\nimport logger from '@/utils/logger';\n\nlet sdk: NodeSDK | null = null;\n\n/**\n * 初始化 OpenTelemetry\n */\nexport function initOpenTelemetry(): NodeSDK | null {\n  // 仅在启用时初始化\n  if (process.env.OTEL_ENABLED !== 'true') {\n    logger.info('OpenTelemetry 追踪已禁用');\n    return null;\n  }\n\n  try {\n    // 配置追踪导出器\n    const traceExporter = new OTLPTraceExporter({\n      url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318/v1/traces',\n      headers: process.env.OTEL_EXPORTER_OTLP_HEADERS\n        ? JSON.parse(process.env.OTEL_EXPORTER_OTLP_HEADERS)\n        : {},\n    });\n\n    // 配置资源（服务标识）\n    const resource = defaultResource().merge(\n      resourceFromAttributes({\n        [ATTR_SERVICE_NAME]: process.env.OTEL_SERVICE_NAME || 'llmchat-backend',\n        [ATTR_SERVICE_VERSION]: process.env.APP_VERSION || '1.0.0',\n        [SEMRESATTRS_DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV || 'development',\n      }),\n    );\n\n    // 初始化 SDK\n    sdk = new NodeSDK({\n      resource,\n      spanProcessor: new BatchSpanProcessor(traceExporter, {\n        maxQueueSize: 1000,           // 最大队列大小\n        maxExportBatchSize: 100,      // 批量导出大小\n        scheduledDelayMillis: 5000,   // 导出延迟（5秒）\n      }),\n      instrumentations: [\n        // 自动注入（HTTP/Express/数据库等）\n        getNodeAutoInstrumentations({\n          '@opentelemetry/instrumentation-http': {\n            enabled: true,\n            requestHook: (span: any, request: any) => {\n              span.setAttribute('http.request_id', request.headers['x-request-id'] as string);\n            },\n          },\n          '@opentelemetry/instrumentation-express': {\n            enabled: true,\n          },\n          '@opentelemetry/instrumentation-pg': {\n            enabled: true,\n            enhancedDatabaseReporting: true,\n          },\n        }),\n      ],\n    });\n\n    // 启动 SDK\n    sdk.start();\n\n    logger.info('✓ OpenTelemetry 追踪已启用', {\n      serviceName: process.env.OTEL_SERVICE_NAME || 'llmchat-backend',\n      endpoint: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318/v1/traces',\n    });\n\n    // 优雅关闭\n    process.on('SIGTERM', () => {\n      sdk?.shutdown()\n        .then(() => logger.info('OpenTelemetry 已关闭'))\n        .catch((error: any) => logger.error('OpenTelemetry 关闭失败', { error }));\n    });\n\n    return sdk;\n  } catch (error) {\n    logger.error('OpenTelemetry 初始化失败', { error });\n    return null;\n  }\n}\n\n/**\n * 获取 SDK 实例\n */\nexport function getSDK(): NodeSDK | null {\n  return sdk;\n}\n\n/**\n * 手动关闭\n */\nexport async function shutdownOpenTelemetry(): Promise<void> {\n  if (sdk) {\n    await sdk.shutdown();\n    sdk = null;\n    logger.info('OpenTelemetry 已手动关闭');\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
