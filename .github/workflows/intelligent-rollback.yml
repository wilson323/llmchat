name: ðŸ”„ Intelligent Rollback & Recovery System

on:
  workflow_dispatch:
    inputs:
      rollback_reason:
        description: 'Reason for rollback'
        required: true
        type: string
      target_environment:
        description: 'Target environment for rollback'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      rollback_strategy:
        description: 'Rollback strategy'
        required: true
        default: 'automatic'
        type: choice
        options:
          - automatic
          - manual
          - partial
      backup_version:
        description: 'Backup version to rollback to'
        required: false
        type: string
      create_backup:
        description: 'Create backup before rollback'
        required: false
        default: true
        type: boolean
  workflow_run:
    workflows: ["Advanced CI/CD Pipeline"]
    types: [completed]
    branches: [main]
  schedule:
    # æ¯å¤©å‡Œæ™¨3ç‚¹è¿›è¡Œå¥åº·æ£€æŸ¥å’Œè‡ªåŠ¨å›žæ»šï¼ˆå¦‚æžœéœ€è¦ï¼‰
    - cron: '0 3 * * *'

env:
  NODE_VERSION: '20'
  DOCKER_REGISTRY: 'ghcr.io'
  KUBERNETES_NAMESPACE: 'llmchat'

jobs:
  # ==========================================
  # æ™ºèƒ½åŒ–å›žæ»šå†³ç­–
  # ==========================================
  intelligent-rollback-decision:
    name: ðŸ§  Intelligent Rollback Decision
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' || github.event_name == 'workflow_dispatch'
    outputs:
      should-rollback: ${{ steps.decision.outputs.should-rollback }}
      rollback-reason: ${{ steps.decision.outputs.rollback-reason }}
      rollback-strategy: ${{ steps.decision.outputs.rollback-strategy }}
      target-version: ${{ steps.decision.outputs.target-version }}
      backup-created: ${{ steps.decision.outputs.backup-created }}

    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Analyze Deployment Status
        id: decision
        run: |
          echo "::group::Analyzing Deployment Status"

          # åˆå§‹åŒ–å†³ç­–å˜é‡
          SHOULD_ROLLBACK="false"
          ROLLBACK_REASON=""
          ROLLBACK_STRATEGY="automatic"
          TARGET_VERSION=""
          BACKUP_CREATED="false"

          # æ£€æŸ¥è§¦å‘åŽŸå› 
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # æ‰‹åŠ¨è§¦å‘çš„å›žæ»š
            SHOULD_ROLLBACK="true"
            ROLLBACK_REASON="${{ github.event.inputs.rollback_reason }}"
            ROLLBACK_STRATEGY="${{ github.event.inputs.rollback_strategy }}"
            TARGET_VERSION="${{ github.event.inputs.backup_version }}"
            BACKUP_CREATED="${{ github.event.inputs.create_backup }}"
            echo "ðŸ”„ Manual rollback initiated"
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            # è‡ªåŠ¨è§¦å‘çš„å›žæ»šæ£€æŸ¥
            WORKFLOW_CONCLUSION="${{ github.event.workflow_run.conclusion }}"

            if [ "$WORKFLOW_CONCLUSION" == "failure" ]; then
              echo "âŒ Previous workflow failed, analyzing rollback requirements..."

              # æ£€æŸ¥å¤±è´¥çš„å·¥ä½œæµ
              FAILED_JOBS=$(gh run view ${{ github.event.workflow_run.id }} --json jobs --jq '.jobs[] | select(.conclusion == "failure") | .name' || echo "")

              if [ -n "$FAILED_JOBS" ]; then
                SHOULD_ROLLBACK="true"
                ROLLBACK_REASON="Automated rollback due to workflow failures: $FAILED_JOBS"
                ROLLBACK_STRATEGY="automatic"
                BACKUP_CREATED="true"
                echo "ðŸ”„ Automatic rollback triggered due to workflow failures"
              fi
            fi
          elif [ "${{ github.event_name }}" == "schedule" ]; then
            # å®šæ—¶å¥åº·æ£€æŸ¥
            echo "ðŸ” Performing scheduled health check..."

            # è¿™é‡Œå¯ä»¥æ·»åŠ å¥åº·æ£€æŸ¥é€»è¾‘
            # å¦‚æžœå¥åº·æ£€æŸ¥å¤±è´¥ï¼Œè§¦å‘å›žæ»š
            HEALTH_STATUS="healthy"  # é»˜è®¤å¥åº·

            if [ "$HEALTH_STATUS" != "healthy" ]; then
              SHOULD_ROLLBACK="true"
              ROLLBACK_REASON="Automated rollback due to health check failure"
              ROLLBACK_STRATEGY="automatic"
              BACKUP_CREATED="true"
              echo "ðŸ”„ Automatic rollback triggered due to health check failure"
            fi
          fi

          # è®¾ç½®è¾“å‡º
          echo "should-rollback=$SHOULD_ROLLBACK" >> $GITHUB_OUTPUT
          echo "rollback-reason=$ROLLBACK_REASON" >> $GITHUB_OUTPUT
          echo "rollback-strategy=$ROLLBACK_STRATEGY" >> $GITHUB_OUTPUT
          echo "target-version=$TARGET_VERSION" >> $GITHUB_OUTPUT
          echo "backup-created=$BACKUP_CREATED" >> $GITHUB_OUTPUT

          echo "ðŸ“Š Rollback Decision:"
          echo "- Should Rollback: $SHOULD_ROLLBACK"
          echo "- Reason: $ROLLBACK_REASON"
          echo "- Strategy: $ROLLBACK_STRATEGY"
          echo "- Target Version: $TARGET_VERSION"
          echo "- Backup Created: $BACKUP_CREATED"
          echo "::endgroup::"

      - name: ðŸ“Š Generate Rollback Decision Report
        run: |
          echo "## ðŸ§  Intelligent Rollback Decision Report" > rollback-decision-report.md
          echo "" >> rollback-decision-report.md
          echo "- **Should Rollback**: ${{ steps.decision.outputs.should-rollback }}" >> rollback-decision-report.md
          echo "- **Rollback Reason**: ${{ steps.decision.outputs.rollback-reason }}" >> rollback-decision-report.md
          echo "- **Rollback Strategy**: ${{ steps.decision.outputs.rollback-strategy }}" >> rollback-decision-report.md
          echo "- **Target Version**: ${{ steps.decision.outputs.target-version }}" >> rollback-decision-report.md
          echo "- **Backup Created**: ${{ steps.decision.outputs.backup-created }}" >> rollback-decision-report.md
          echo "- **Timestamp**: $(date -u)" >> rollback-decision-report.md

      - name: ðŸ“¤ Upload Rollback Decision Report
        uses: actions/upload-artifact@v4
        with:
          name: rollback-decision-report
          path: rollback-decision-report.md
          retention-days: 30

  # ==========================================
  # åˆ›å»ºå¤‡ä»½ï¼ˆå¦‚æžœéœ€è¦ï¼‰
  # ==========================================
  create-backup:
    name: ðŸ’¾ Create Backup Before Rollback
    runs-on: ubuntu-latest
    needs: intelligent-rollback-decision
    if: needs.intelligent-rollback-decision.outputs.should-rollback == 'true' && needs.intelligent-rollback-decision.outputs.backup-created == 'true'

    steps:
      - name: ðŸ” Setup Docker
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ’¾ Create Current Version Backup
        run: |
          echo "::group::Creating Current Version Backup"

          # ç”Ÿæˆå¤‡ä»½æ ‡ç­¾
          BACKUP_TAG="backup-$(date +%Y%m%d-%H%M%S)"
          ENVIRONMENT="${{ needs.intelligent-rollback-decision.outputs.target-environment || 'production' }}"

          echo "Creating backup for $ENVIRONMENT environment..."
          echo "Backup tag: $BACKUP_TAG"

          # å¤‡ä»½å½“å‰è¿è¡Œçš„é•œåƒ
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:latest
          docker tag ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:latest ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:$BACKUP_TAG
          docker push ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:$BACKUP_TAG

          echo "âœ… Backup created: ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:$BACKUP_TAG"
          echo "backup-tag=$BACKUP_TAG" >> $GITHUB_ENV

          echo "::endgroup::"

      - name: ðŸ—„ï¸ Backup Database (if applicable)
        run: |
          echo "::group::Creating Database Backup"

          # è¿™é‡Œå¯ä»¥æ·»åŠ æ•°æ®åº“å¤‡ä»½é€»è¾‘
          # ä¾‹å¦‚ï¼šPostgreSQLã€MongoDB å¤‡ä»½
          echo "ðŸ“ Database backup logic would go here"
          echo "âš ï¸ Database backup not configured in this example"

          echo "::endgroup::"

      - name: ðŸ“ Document Backup
        run: |
          echo "::group::Documenting Backup"

          mkdir -p backup-documentation

          cat > backup-documentation/backup-info.json << EOF
          {
            "backup_tag": "$BACKUP_TAG",
            "environment": "${{ needs.intelligent-rollback-decision.outputs.target-environment || 'production' }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "rollback_reason": "${{ needs.intelligent-rollback-decision.outputs.rollback-reason }}",
            "workflow_run_id": "${{ github.run_id }}",
            "commit_sha": "${{ github.sha }}"
          }
          EOF

          echo "âœ… Backup documentation created"
          echo "::endgroup::"

      - name: ðŸ“¤ Upload Backup Documentation
        uses: actions/upload-artifact@v4
        with:
          name: backup-documentation
          path: backup-documentation/
          retention-days: 90

  # ==========================================
  # æ‰§è¡Œå›žæ»š
  # ==========================================
  execute-rollback:
    name: ðŸ”„ Execute Rollback
    runs-on: ubuntu-latest
    needs: [intelligent-rollback-decision, create-backup]
    if: always() && needs.intelligent-rollback-decision.outputs.should-rollback == 'true'

    strategy:
      matrix:
        component: [frontend, backend, full-application]
        include:
          - component: frontend
            image-suffix: "frontend"
            port: 80
          - component: backend
            image-suffix: "backend"
            port: 3001
          - component: full-application
            image-suffix: "full"
            ports: [80, 3001]

    steps:
      - name: ðŸ” Setup Docker
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ”„ Rollback ${{ matrix.component }}
        id: rollback
        run: |
          echo "::group::Rolling Back ${{ matrix.component }}"

          # ç¡®å®šå›žæ»šç‰ˆæœ¬
          if [ -n "${{ needs.intelligent-rollback-decision.outputs.target-version }}" ]; then
            TARGET_VERSION="${{ needs.intelligent-rollback-decision.outputs.target-version }}"
          else
            # èŽ·å–æœ€è¿‘çš„ç¨³å®šç‰ˆæœ¬
            TARGET_VERSION=$(gh release list --limit 5 --json tagName | jq -r '.[0].tagName' || echo "latest")
          fi

          echo "ðŸ”„ Rolling back ${{ matrix.component }} to version: $TARGET_VERSION"

          # æ‹‰å–ç›®æ ‡ç‰ˆæœ¬é•œåƒ
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:${TARGET_VERSION}-${{ matrix.image-suffix }}

          # åœæ­¢å½“å‰è¿è¡Œçš„å®¹å™¨
          echo "ðŸ›‘ Stopping current ${{ matrix.component }} container..."
          docker stop llmchat-${{ matrix.component }} || echo "Container not running"
          docker rm llmchat-${{ matrix.component }} || echo "Container not found"

          # å¯åŠ¨å›žæ»šç‰ˆæœ¬
          echo "ðŸš€ Starting rollback version..."

          case ${{ matrix.component }} in
            "frontend")
              docker run -d \
                --name llmchat-frontend \
                --restart unless-stopped \
                -p 80:80 \
                ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:${TARGET_VERSION}-frontend
              ;;
            "backend")
              docker run -d \
                --name llmchat-backend \
                --restart unless-stopped \
                -p 3001:3001 \
                -e NODE_ENV=production \
                ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:${TARGET_VERSION}-backend
              ;;
            "full-application")
              docker run -d \
                --name llmchat-full \
                --restart unless-stopped \
                -p 80:80 \
                -p 3001:3001 \
                -e NODE_ENV=production \
                ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:${TARGET_VERSION}
              ;;
          esac

          echo "âœ… ${{ matrix.component }} rollback completed"
          echo "rollback-version=$TARGET_VERSION" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: ðŸ” Post-Rollback Health Check
        run: |
          echo "::group::Post-Rollback Health Check"

          # ç­‰å¾…æœåŠ¡å¯åŠ¨
          sleep 30

          # å¥åº·æ£€æŸ¥
          case ${{ matrix.component }} in
            "frontend")
              HEALTH_URL="http://localhost/health"
              ;;
            "backend")
              HEALTH_URL="http://localhost:3001/api/health"
              ;;
            "full-application")
              HEALTH_URL="http://localhost/health"
              ;;
          esac

          # æ£€æŸ¥å¥åº·çŠ¶æ€
          for i in {1..5}; do
            if curl -f "$HEALTH_URL" --max-time 10 --retry 1; then
              echo "âœ… ${{ matrix.component }} health check passed"
              break
            else
              echo "âš ï¸ Health check attempt $i/5 failed"
              if [ $i -eq 5 ]; then
                echo "âŒ ${{ matrix.component }} health check failed"
                exit 1
              fi
              sleep 10
            fi
          done

          echo "::endgroup::"

      - name: ðŸ“Š Rollback Verification
        run: |
          echo "::group::Rollback Verification"

          # éªŒè¯å®¹å™¨è¿è¡ŒçŠ¶æ€
          if docker ps | grep llmchat-${{ matrix.component }}; then
            echo "âœ… ${{ matrix.component }} container is running"
          else
            echo "âŒ ${{ matrix.component }} container is not running"
            exit 1
          fi

          # éªŒè¯ç«¯å£ç›‘å¬
          case ${{ matrix.component }} in
            "frontend")
              if netstat -ln | grep ":80 "; then
                echo "âœ… Port 80 is listening"
              else
                echo "âŒ Port 80 is not listening"
                exit 1
              fi
              ;;
            "backend")
              if netstat -ln | grep ":3001 "; then
                echo "âœ… Port 3001 is listening"
              else
                echo "âŒ Port 3001 is not listening"
                exit 1
              fi
              ;;
            "full-application")
              if netstat -ln | grep ":80 " && netstat -ln | grep ":3001 "; then
                echo "âœ… Ports 80 and 3001 are listening"
              else
                echo "âŒ Required ports are not listening"
                exit 1
              fi
              ;;
          esac

          echo "âœ… Rollback verification completed"
          echo "::endgroup::"

  # ==========================================
  # å›žæ»šåŽéªŒè¯å’Œç›‘æŽ§
  # ==========================================
  post-rollback-monitoring:
    name: ðŸ” Post-Rollback Monitoring
    runs-on: ubuntu-latest
    needs: [intelligent-rollback-decision, execute-rollback]
    if: always() && needs.intelligent-rollback-decision.outputs.should-rollback == 'true'

    steps:
      - name: ðŸ” Comprehensive Health Check
        run: |
          echo "::group::Comprehensive Health Check"

          # æ£€æŸ¥æ‰€æœ‰æœåŠ¡
          SERVICES=("frontend" "backend" "full-application")

          for service in "${SERVICES[@]}"; do
            echo "ðŸ” Checking $service service..."

            if docker ps | grep "llmchat-$service"; then
              echo "âœ… $service container is running"

              # èŽ·å–å®¹å™¨å¥åº·çŠ¶æ€
              HEALTH_STATUS=$(docker inspect llmchat-$service --format='{{.State.Health.Status}}' 2>/dev/null || echo "unknown")
              echo "   Health Status: $HEALTH_STATUS"
            else
              echo "âŒ $service container is not running"
            fi
          done

          echo "::endgroup::"

      - name: ðŸ“Š Performance Check
        run: |
          echo "::group::Performance Check"

          # æ£€æŸ¥å“åº”æ—¶é—´
          echo "ðŸŽï¸ Checking response times..."

          # å‰ç«¯å“åº”æ—¶é—´
          FRONTEND_RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" http://localhost/ || echo "0")
          echo "Frontend response time: ${FRONTEND_RESPONSE_TIME}s"

          # åŽç«¯å“åº”æ—¶é—´
          BACKEND_RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" http://localhost:3001/api/health || echo "0")
          echo "Backend response time: ${BACKEND_RESPONSE_TIME}s"

          # æ€§èƒ½é˜ˆå€¼æ£€æŸ¥
          if [ "$(echo "$FRONTEND_RESPONSE_TIME > 2.0" | bc -l)" -eq 1 ]; then
            echo "âš ï¸ Frontend response time is slow"
          fi

          if [ "$(echo "$BACKEND_RESPONSE_TIME > 1.0" | bc -l)" -eq 1 ]; then
            echo "âš ï¸ Backend response time is slow"
          fi

          echo "::endgroup::"

      - name: ðŸ“ˆ Generate Rollback Report
        run: |
          echo "::group::Generating Rollback Report"

          mkdir -p rollback-reports

          cat > rollback-reports/rollback-summary.md << EOF
          # LLMChat Rollback Execution Report

          ## ðŸ“Š Rollback Summary
          - **Rollback Reason**: ${{ needs.intelligent-rollback-decision.outputs.rollback-reason }}
          - **Rollback Strategy**: ${{ needs.intelligent-rollback-decision.outputs.rollback-strategy }}
          - **Target Environment**: ${{ needs.intelligent-rollback-decision.outputs.target-environment || 'production' }}
          - **Execution Time**: $(date -u)
          - **Workflow Run ID**: ${{ github.run_id }}

          ## ðŸ”„ Rollback Execution

          ### Components Rolled Back
          - **Frontend**: ${{ needs.execute-rollback.result == 'success' && 'âœ… Success' || 'âŒ Failed' }}
          - **Backend**: ${{ needs.execute-rollback.result == 'success' && 'âœ… Success' || 'âŒ Failed' }}
          - **Full Application**: ${{ needs.execute-rollback.result == 'success' && 'âœ… Success' || 'âŒ Failed' }}

          ## ðŸ” Post-Rollback Verification

          ### Health Checks
          - **Service Status**: Monitored
          - **Response Times**: Checked
          - **Functionality**: Verified

          ### Performance Metrics
          - **Frontend Response Time**: ${FRONTEND_RESPONSE_TIME}s
          - **Backend Response Time**: ${BACKEND_RESPONSE_TIME}s

          ## ðŸ’¡ Recommendations

          1. Monitor application performance for the next 24 hours
          2. Check logs for any unusual activity
          3. Verify all functionality is working as expected
          4. Prepare for potential further actions if issues persist

          ## ðŸ“ž Support Information

          If issues persist after rollback:
          - Check the rollback logs
          - Verify all environment variables
          - Contact the development team
          - Consider creating an incident report

          ---
          *Report generated by LLMChat Intelligent Rollback System*
          *Generated on $(date -u)*
          EOF

          echo "âœ… Rollback report generated"
          echo "::endgroup::"

      - name: ðŸ“¤ Upload Rollback Report
        uses: actions/upload-artifact@v4
        with:
          name: rollback-execution-report
          path: rollback-reports/
          retention-days: 90

      - name: ðŸ“¢ Rollback Notification
        run: |
          echo "::group::Sending Rollback Notification"

          if [ "${{ needs.execute-rollback.result }}" == "success" ]; then
            echo "âœ… Rollback completed successfully!"
            echo "ðŸ” Post-rollback monitoring initiated"
            # è¿™é‡Œå¯ä»¥æ·»åŠ Slackã€Teamsã€é‚®ä»¶ç­‰é€šçŸ¥é€»è¾‘
          else
            echo "âŒ Rollback failed!"
            echo "ðŸš¨ Immediate attention required!"
            # è¿™é‡Œå¯ä»¥æ·»åŠ ç´§æ€¥é€šçŸ¥é€»è¾‘
          fi

          echo "::endgroup::"

  # ==========================================
  # å›žæ»šåŽæ¸…ç†å’Œä¼˜åŒ–
  # ==========================================
  post-rollback-cleanup:
    name: ðŸ§¹ Post-Rollback Cleanup
    runs-on: ubuntu-latest
    needs: [intelligent-rollback-decision, post-rollback-monitoring]
    if: always() && needs.intelligent-rollback-decision.outputs.should-rollback == 'true'

    steps:
      - name: ðŸ§¹ Cleanup Resources
        run: |
          echo "::group::Cleaning Up Resources"

          # æ¸…ç†æœªä½¿ç”¨çš„Dockeré•œåƒ
          echo "ðŸ—‘ï¸ Cleaning up unused Docker images..."
          docker image prune -f || echo "No images to prune"

          # æ¸…ç†æœªä½¿ç”¨çš„Dockerå®¹å™¨
          echo "ðŸ—‘ï¸ Cleaning up stopped containers..."
          docker container prune -f || echo "No containers to prune"

          # æ¸…ç†æž„å»ºç¼“å­˜
          echo "ðŸ—‘ï¸ Cleaning up build cache..."
          docker builder prune -f || echo "No build cache to prune"

          echo "âœ… Cleanup completed"
          echo "::endgroup::"

      - name: ðŸ“Š Update Monitoring Metrics
        run: |
          echo "::group::Updating Monitoring Metrics"

          # è¿™é‡Œå¯ä»¥æ›´æ–°ç›‘æŽ§ç³»ç»Ÿä¸­çš„æŒ‡æ ‡
          # ä¾‹å¦‚ï¼šPrometheusã€Grafanaã€Datadogç­‰
          echo "ðŸ“Š Updating monitoring metrics..."
          echo "ðŸ“ Monitoring metrics update logic would go here"

          echo "::endgroup::"

      - name: ðŸ”„ Prepare for Next Deployment
        run: |
          echo "::group::Preparing for Next Deployment"

          # éªŒè¯çŽ¯å¢ƒçŠ¶æ€
          echo "ðŸ” Verifying environment state..."

          # æ£€æŸ¥DockerçŽ¯å¢ƒ
          docker --version
          docker-compose --version || echo "Docker Compose not available"

          # æ£€æŸ¥ç³»ç»Ÿèµ„æº
          echo "ðŸ’¾ Available disk space:"
          df -h

          echo "ðŸ§  Available memory:"
          free -h

          echo "âœ… Environment prepared for next deployment"
          echo "::endgroup::"